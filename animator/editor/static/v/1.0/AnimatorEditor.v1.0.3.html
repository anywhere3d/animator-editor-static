<!DOCTYPE html>
<html>

<head>
    
    <title>Animator Editor v.1.0.3</title>
    
    <style id="animator-editor-css">
        html, body { width: 100%; height: 100%; }
        body       { background-color: #ffffff; margin:0; padding:0px; overflow:hidden; font-family:arial, san-serif; }
        canvas     { position:absolute; top:0px; left:0px; widht:100%; height:100%; }
        #close-button { position:absolute; left:4px; top:4px; }
        #help-button  { position:absolute; right:4px; top:4px; }
        #help-icon, 
        #close-icon   { top:0px; left:0px; right:0px; height:24px; }
        #animation-editor { position:absolute; top:0px; left:0px; right:0px; bottom:0px; display:block; }
        #animator-render-container {
            position:absolute; top:0px; left:0px; right:0px; bottom:0px; margin:0px; 
            background-color: #000000; overflow:hidden; cursor:arrow; display:block;
        }
        #pauser {
            position:absolute; max-top:40%; min-top:30%; bottom:50%; left:5%; right:5%; padding:0px; margin:auto; 
            color:#ffffff; border: 0.0em solid #ffffff; border-radius:0.1em; 
            font-size:5em; text-align:center; text-vertical-align:middle;
            display:none; opacity:0.7; 
        }
        #animator-container {
            position:absolute; bottom:5px; left:80px; right:80px; height:40px; display:block;
            border:1px solid #ffffff;  border-radius:4px; color:#fff; text-align:left; 
        }
        #label-timer        { position:absolute; left:10px; bottom:5px; font-size:1.5em; }
        #output-timer       { position:absolute; left:70px; bottom:5px; font-size:1.5em; }
        #status-msgr        { position:absolute; left:10px; top:-25px; color:#fff; font-size:0.7em; display:none; }
        #animation-buttons  { position:absolute; top:4px; }
        #animation-play     { position:absolute; left:140px; }
        #animation-add      { position:absolute; left:200px; }
        #delete-framekey    { position:absolute; top:4px; right:4px; }
        #manual-play        { position:absolute; left:290px; bottom:14px; }
        #timer-container    { position:absolute; left:320px; right:120px; top:8px;border:0px solid #ffffff; }
        #time-container,
        #keys-container     { position:absolute; left:320px; right:120px; top:-60px; height:50px; border:0px solid #ffff00; }
        .keymark            { border:2px solid #ff0; border-radius:4px; /* -webkit-transform:translateX( -16px ); */ }
        #bones-adjustment {
            position:absolute; bottom:5px; left:5px; right:5px; height:30px;
            border:1px solid #ffffff;
            color:#fff; text-align:left; font-size:1.5em;
        }
        #droplist-label { position:absolute; right:180px; top:20px; }
        #droplist-bones { position:absolute; top:20px; right:30px; }
        #animator-container-controls { 
            position:absolute; right:10px; top:50px; width:350px; height:680px;
            padding-top:10px; padding-bottom:10px; padding-left:40px; padding-right:40px; 
            background-color:rgba(0,0,0, 0.5); color:#fff; text-align:left; font-size:0.7em;
            border:4px solid #ffffff; border-radius:12px;
            display:block;
        }
        .slider-row    { padding-top:10px;}
        #dims-label    { position:absolute; left:0px; right:0px; top:0px; font-size:1.5em; text-align:center; }
        #position-div  { top:50px; }
        #rotation-div  { top:165px; }
        #scale-uniform-div { top:280px; }
        #scale-div     { top:345px; }
        #animation-div { top:460px; height:180px;}
        #slider-scale-uniform  { position:absolute; left:100px; top:10px; width:53%; }
    /*
        #label-scale-uniform   { position:absolute; left:10px; top:10px; }
        #output-scale-uniform  { position:absolute; top:10px; right:10px; }
    */
        .dimsadjust { 
            position:absolute; left:30px; right:30px;
            padding-top:0px; padding-bottom:10px; 
            padding-left:10px; padding-right:10px; 
            border:1px solid #ffffff; border-radius:8px;
        }
        .dimoutput          { position:absolute; right:10px; font-size:1.5em; overflow:hidden; }
        .dimslider          { position:absolute; left:90px; width:55%; }
        .sclslider          { position:absolute; left:80px; width:58%; }
        .durslider          { position:absolute; left:95px; width:60%; }
        .timerslider        { width:100%; }
        #reset-position     { position:absolute; bottom:-20px; right:0px; }
        #reset-rotation     { position:absolute; bottom:-20px; right:0px; }
        #reset-scale        { position:absolute; bottom:-20px; right:0px; }
        #reset-pose         { position:absolute; bottom:-20px; right:0px; }
        #bones-helper       { position:absolute; bottom:-20px; left:0px; }
        #avatar-helper      { position:absolute; bottom:-20px; left:120px; }
    /*
        #crazy-pose         { position:absolute; bottom:-20px; right:0px; }
    */
        #finetune-down      { position:absolute; bottom:-20px; left:0px; }
        #finetune-text      { position:absolute; bottom:-20px; left:20px; }
        #finetune-up        { position:absolute; bottom:-20px; left:120px; }
        #load-skinned       { position:absolute; top:130px; left:30px; }
        #looper             { position:absolute; bottom:10px; right:10px; }
        #export-buttons     { position:absolute; bottom:-40px; left:5px; display:block; }
        #export-buttons a.button:link    {color:#fff;}
        #export-buttons a.button:visited {color:#888;}
        #export-buttons a.button:hover   {color:#fff;}
        #export-buttons a.button:active  {color:#fff;}
    /*
        #export-data        { position:absolute; }
        #export-pose        { position:absolute; }
        #export-batch       { position:absolute; }
    */
        #animation-importer { position:absolute; top:20px; left:20px; color:#fff;display:block; }
        #poser-importer     { position:absolute; bottom:80px; left:20px; color:#fff; display:block; }
        #test-importer      { position:absolute; top:90px; left:10px; color:#fff; display:none; }
        #pose-animator,
        #data-animator {
            position:fixed; left:35%; top:100px; width:300px; height:600px;
            padding-top:10px; padding-bottom:10px; padding-left:40px; padding-right:40px; 
            background-color:rgba(0,0,0, 0.85); color:#fff; text-align:left; font-size:1.2em;
            border:4px solid #ffffff; border-radius:12px;
            display:none;
        }
        #preview-pose-container,
        #preview-data-container {
            position:absolute; top:60px; left:61px; right:61px; height:256px;
            border:1px solid #0f0; context-align:center;
        }
        #animator-pose-label,
        #animator-data-label { position:absolute; left:30px; top:30px; right:30px; text-align:center }
        #animator-pose-form,
        #animator-data-form  { position:absolute; left:30px; top:340px; right:30px; height:250px; font-size:14px; border:0px solid #fff; }
        #pose-title-div,
        #data-title-div      { position:absolute; top:0px; width:100%; overflow:hidden; }
        #pose-skeleton-div,
        #data-skeleton-div   { position:absolute; top:50px; width:100%; overflow:hidden; }
        #pose-title,
        #data-title,
        #pose-skeleton,
        #data-skeleton { width:100%; }
        #pose-submit,
        #data-submit  { position:absolute; left:100px; bottom:0px; width:120px; }
        #preview-snap { position:absolute; left:125px; bottom:50px; width:120px; display:none; }
    </style>
    
    <style id="side-panels-css">
        * { box-sizing:border-box; -moz-box-sizing:border-box; margin:0px; /*padding:0px;*/ }
        html { color:#000; font-size:13px; background-color:#eee; margin:0px; overflow:hidden; }
        #left-side { left:0px; top:0px; bottom:0px; -webkit-transform:translateX( -380px ); }
    	#right-side { right:0px; top:0px; bottom:0px; -webkit-transform: translateX( 380px ); }
        #left-side, 
        #right-side { 
            color:#eee; font-size:11px; position:absolute;
            background-color:rgba(0,0,0,0.4); width:452px; line-height:1.4em;
            -webkit-transition: -webkit-transform 500ms ease-out;
        }
    	#left-side:hover, 
        #left-side.pinned,
        #right-side:hover, 
        #right-side.pinned { -webkit-transform: translateX(0); }
    	#left-side-content { 
            position:absolute; right:52px; top:0px; left:0px; bottom:0px; 
            padding:20px 20px 20px 20px; overflow:hidden; 
        }
        #right-side-content {
            position:absolute; left:52px; top:40px; right:10px; bottom:80px; 
            padding: 20px 20px 20px 20px; overflow:auto; 
        }
    	#left-side-pinbtn{ 
            position:absolute; top:20px; right:20px; width:32px; height:32px; 
            border:1px solid white; opacity:0.5; border-radius:4px; 
            background-image:url(icons/button-chat-remix.png);
            background-repeat:no-repeat; background-position:50% 50%; 
            background-size:contain; cursor:pointer;
            -webkit-transition:opacity 250ms ease-out; 
        }
        #right-side-pinbtn{ 
            position: absolute; top: 20px; left: 20px; width: 32px; height: 32px; 
            border: 1px solid white; opacity:0.5; border-radius: 4px; 
            background-image: url(icons/options-panel.png); 
            background-repeat:no-repeat; background-position: 50% 50%; 
            background-size:contain; cursor:pointer;
            -webkit-transition: opacity 250ms ease-out;
        }
        #left-side-pinbtn:hover, 
        #left-side-pinbtn.pinned,
        #right-side-pinbtn:hover, 
        #right-side-pinbtn.pinned { opacity:1; }
    	#hover { opacity:1; }
    	#right-side-content a:link    {color:#fff;}
        #right-side-content a:visited {color:#40f;}
        #right-side-content a:hover   {color:#0f0;}
        #right-side-content a:active  {color:#f00;}
    	/* a { color:white; text-shadow:0 1px 0 rgba(0,0,0,0.5) } */
    	#left-side h1, 
        #right-side h1 { margin-bottom:10px; font-size:14px;}
    	#left-side h2, 
        #right-side h2 { font-size:11px; margin-bottom:5px;}
    	#left-side p, 
        #right-side p  { font-size:13px; }
        .btn-light, 
        .btn-escape, 
        .btn-helper    { width:32px; height:32px; opacity:1; background:rgba(255,255,255,0); }
        .block         { margin-bottom:10px; float:left; width:280px; }
        .button:hover, 
        .button:active { background-position:0px -2px; }

    </style>
  
    <style id="camera-properties-css">
    /*
        #what-to-do { 
            position:absolute; left:30px; top:20px; color:#ffffff; background-color: #000000; font-size:1em; 
            text-align:justify; text-vertical-align:middle; border:0.0em solid #ffffff; border-radius:0.1em; 
            opacity:0,7; display:block; width:350px; paddign:20px;
        }
    */
        #what-to-do {
            width:auto; height:auto; position:absolute; left:20px; top:80px; right:40px; 
            padding-top:10px; padding-bottom:10px; padding-left:10px; padding-right:10px; 
            background-color:rgba(0,0,0,0.5); color:#fff; text-align:left; font-size:1.2em;
            border:4px solid #ffffff; border-radius:12px; display:block;
        }
        #camera-measure-panel {
            width:auto; height:auto; position:absolute; left:80px; top:60px; 
            padding-top:10px; padding-bottom:10px; padding-left:10px; padding-right:10px; 
            background-color:rgba(0,0,0,0.5); color:#fff; text-align:left; font-size:1em;
            border:4px solid #ffffff; border-radius:12px; display:block;
        }
        .btn-close {
            width:20px; height:20px; position:absolute; right:4px; top:4px; 
            border-width:0px; border-style:solid; border-color:#f00; border-radius:4px;
            background-image: url(icons/sign-error-close.png); 
            background-repeat:no-repeat; background-position: 50% 50%; 
            background-size:contain; cursor:pointer;
        }
    </style>

	<link rel="stylesheet" href="css/buttons.css" media="all">
	<link rel="stylesheet" href="css/spinner.css" media="all">
	<link rel="stylesheet" href="css/normalize.css" media="all">
    
    <script src="js/jquery.min.js"></script>

    <!-- threejs libraries -->
    <script src="js/three.js"></script>
    <script src="js/EditorControls.js"></script>
    <script src="js/Detector.js"></script>
    <script src="js/Projector.js"></script>
    <script src="js/KeyboardState.js"></script>
    <script src="js/Animation.js" language="javascript" type="text/javascript"></script>
    <script src="js/AnimationHandler.js" language="javascript" type="text/javascript"></script>
    <script src="js/KeyFrameAnimation.js" language="javascript" type="text/javascript"></script>

    <script>
    
    //  Animator Timer timeliner.
        
        var STORAGE_PREFIX = 'timeliner-';
        
        var Z_INDEX = 999;
        
    /**************************/
    // Settings
    /**************************/
        
        var duration = 4 // sec.
        var DEFAULT_TIME_SCALE = 300; // pixels.
        
    //  Dimensions.
        
        var Settings = {
        	LINE_HEIGHT: 26,
        	DIAMOND_SIZE: 15,
        	MARKER_TRACK_HEIGHT: 0,
        	width: duration * DEFAULT_TIME_SCALE + 40,
        	height: 100,
        	TIMELINE_SCROLL_HEIGHT: 0,
        	LEFT_PANE_WIDTH: 0,
        	time_scale: DEFAULT_TIME_SCALE, // number of pixels to 1 second.
            default_length: 1, // seconds
        };

    /**************************/
    // Theme
    /**************************/
        
        var Theme = {
    	//  Photoshop colors.
        	a: '#343434',
        	b: '#535353',
        	c: '#b8b8b8',
        	d: '#d6d6d6',
        };

    /**************************/
    // Do
    /**************************/
        
        function Do(parent) {
        	var listeners = [];
        	this.do = function(callback) {
        		listeners.push(callback);
        	};
        	this.undo = function(callback) {
        		listeners.splice(listeners.indexOf(callback), 1);
        	};
        	this.fire = function() {
        		for (var v = 0; v < listeners.length; v++) {
        			listeners[v].apply(parent, arguments);
        		}
        	};
        }
        
    /**************************/
    // Dispatcher
    /**************************/
        
        function Dispatcher() {
        
        	var event_listeners = {
        
        	};
        
        	function on(type, listener) {
        		if (!(type in event_listeners)) {
        			event_listeners[type] = [];
        		}
        		var listeners = event_listeners[type];
        		listeners.push(listener);
        	}
        
        	function fire(type) {
        		var args = Array.prototype.slice.call(arguments);
        		args.shift();
        		var listeners = event_listeners[type];
        		if (!listeners) return;
        		for (var i = 0; i < listeners.length; i++) {
        			var listener = listeners[i];
        			listener.apply(listener, args);
        		}
        	}
        
        	this.on = on;
        	this.fire = fire;
        
        }

    /**************************/
    // DataStore
    /**************************/
        
    //  Data Store with a source of truth.
        function DataStore() {
        	this.DELIMITER = ':';
        	this.blank();
        	this.onOpen = new Do();
        	this.onSave = new Do();
        
        	this.listeners = [];
        }
        
        DataStore.prototype.addListener = function(path, cb) {
        	this.listeners.push({
        		path: path,
        		callback: cb
        	});
        };
        
        DataStore.prototype.blank = function() {
        	var data = {};
        
        	data.version = "1.4.0";
        	data.modified = new Date().toString();
        	data.title = 'Untitled';
        
        	data.ui = {
        		currentTime: 0,
        		totalTime: Settings.default_length,
        		scrollTime: 0,
        		timeScale: Settings.time_scale
        	};
        
        	data.layers = [];
        
        	this.data = data;
        };
        
        DataStore.prototype.update = function() {
        	var data = this.data;
        
        	data.version = "1.4.0";
        	data.modified = new Date().toString();
        };
        
        DataStore.prototype.setJSONString = function(data) {
        	this.data = JSON.parse(data);
        };
        
        DataStore.prototype.setJSON = function(data) {
        	this.data = data;
        };
        
        DataStore.prototype.getJSONString = function(format) {
        	return JSON.stringify(this.data, null, format);
        };
        
        DataStore.prototype.getValue = function(paths) {
        	var descend = paths.split(this.DELIMITER);
        	var reference = this.data;
        	for (var i = 0, il = descend.length; i < il; i++) {
        		var path = descend[i];
        		if (reference[path] === undefined) {
        			console.warn('Cant find ' + paths);
        			return;
        		}
        		reference = reference[path];
        	}
        	return reference;
        };
        
        DataStore.prototype.setValue = function(paths, value) {
        	var descend = paths.split(this.DELIMITER);
        	var reference = this.data;
        	for (var i = 0, il = descend.length - 1; path = descend[i], i < il ; i++) {
        		reference = reference[path];
        	}
        
        	reference[path] = value;
        
        	this.listeners.forEach(function(l) {
        		if (paths.indexOf(l.path) > -1) l.callback();
        	})
        };
        
        DataStore.prototype.get = function(path, suffix) {
        	if (suffix) path = suffix + this.DELIMITER + path;
        	return new DataProx(this, path);
        };
        
        function DataProx(store, path) {
        	this.path = path;
        	this.store = store;
        }
        
        DataProx.prototype = {
        	get value() {
        		return this.store.getValue(this.path);
        	},
        	set value(val) {
        		this.store.setValue(this.path, val);
        	}
        };
        
        DataProx.prototype.get = function(path) {
        	return this.store.get(path, this.path);
        };

    /**************************/
    // Utilities
    /**************************/

        function fakeClick(target) {
        	var e = document.createEvent("MouseEvents");
        	e.initMouseEvent(
        		'click', true, false, window, 0, 0, 0, 0, 0,
        		false, false, false, false, 0, null
        	);
        	target.dispatchEvent(e);
        }
        
        function firstDefined() {
        	for(var i = 0; i < arguments.length; i++) {
        		if(typeof arguments[i] !== 'undefined') {
        			return arguments[i];
        		}
        	}
        	return undefined;
        }
        
        function style(element, var_args) {
        	for (var i = 1; i < arguments.length; ++i) {
        		var styles = arguments[i];
        		for (var s in styles) {
        			element.style[s] = styles[s];
        		}
        	}
        }
        
        function saveToFile(string, filename) {
        	var a = document.createElement("a");
        	document.body.appendChild(a);
        	a.style = "display: none";
        
        	var blob = new Blob([string], { type: 'octet/stream' }), // application/json
        		url = window.URL.createObjectURL(blob);
        	
        	a.href = url;
        	a.download = filename;
        
        	fakeClick(a);
        
        	setTimeout(function() {
        		// cleanup and revoke
        		window.URL.revokeObjectURL(url);
        		document.body.removeChild(a);
        	}, 500);
        }
        
        function openAs(callback, target) {
        	console.log('openfile...');
        	openCallback = callback;
        
        	if (!input) {
        		input = document.createElement('input');
        		input.style.display = 'none';
        		input.type = 'file';
        		input.addEventListener('change', handleFileSelect);
        		target = target || document.body;
        		target.appendChild(input);
        	}
        	
        	fakeClick(input);
        }
        
        function format_friendly_seconds(s, type) {
    	//  TODO: Refactor to 60fps???
    	//  20 mins * 60 sec = 1080 
    	//  1080s * 60fps = 1080 * 60 < Number.MAX_SAFE_INTEGER
        
        	var raw_secs = s | 0;
        	var secs_micro = s % 60;
        	var secs = raw_secs % 60;
        	var raw_mins = raw_secs / 60 | 0;
        	var mins = raw_mins % 60;
        	var hours = raw_mins / 60 | 0;
        
        	var secs_str = (secs / 100).toFixed(2).substring(2);
        
        	var str = mins + ':' + secs_str;
        
        	if (s % 1 > 0) {
        		var t2 = (s % 1) * 60;
        		if (type === 'frames') str = secs + '+' + t2.toFixed(0) + 'f';
        		else str += ((s % 1).toFixed(2)).substring(1);
    		//  else str = mins + ':' + secs_micro;
    		//  else str = secs_micro + 's'; /// .toFixed(2)
        	}
        	return str;	
        }
        
    //  Get object at time.
        function findTimeinLayer(layer, time) {
        	var values = layer.values;
        	var i, il;
        
    	//  TODO: optimize by checking time / binary search.
        
        	for (i=0, il=values.length; i<il; i++) {
        		var value = values[i];
        		if (value.time === time) {
        			return {
        				index: i,
        				object: value
        			};
        		} else if (value.time > time) {
        			return i;
        		}
        	}
        
        	return i;
        }
        
        function timeAtLayer(layer, t) {
    	//  Find the value of layer at t seconds.
    	//  this expect layer to be sorted
    	//  not the most optimized for now, but would do.
        
        	var values = layer.values;
        	var i, il, entry, prev_entry;
        
        	il = values.length;
        
    	//  Can't do anything.
        	if (il === 0) return;
        
        	if (layer._mute) return
        
    	//  Find boundary cases
        	entry = values[0];
        	if (t < entry.time) {
        		return {
        			value: entry.value,
        			can_tween: false, // cannot tween.
        			keyframe: false   // not on keyframe.
        		};
        	}
        
        	for (i=0; i<il; i++) {
        		prev_entry = entry;
        		entry = values[i];
        
        		if (t === entry.time) {
    			//  Only exception is on the last KF, where we display tween from prev entry.
        			if (i === il - 1) {
        				return {
        					// index: i,
        					entry: prev_entry,
        					tween: prev_entry.tween,
        					can_tween: il > 1,
        					value: entry.value,
        					keyframe: true
        				};
        			}
        			return {
    				//  index: i,
        				entry: entry,
        				tween: entry.tween,
        				can_tween: il > 1,
        				value: entry.value,
        				keyframe: true // il > 1
        			};
        		}
        		if (t < entry.time) {
    			//  Possibly a tween.
        			if (!prev_entry.tween) { // or if value is none.
        				return {
        					value: prev_entry.value,
        					tween: false,
        					entry: prev_entry,
        					can_tween: true,
        					keyframe: false
        				};
        			}
        
    			//  Calculate tween.
        			var time_diff = entry.time - prev_entry.time;
        			var value_diff = entry.value - prev_entry.value;
        			var tween = prev_entry.tween;
        
        			var dt = t - prev_entry.time;
        			var k = dt / time_diff;
        			var new_value = prev_entry.value + Tweens[tween](k) * value_diff;
        
        			return {
        				entry: prev_entry,
        				value: new_value,
        				tween: prev_entry.tween,
        				can_tween: true,
        				keyframe: false
        			};
        		}
        	}
        	
    	//  Time is after all entries.
        	return {
        		value: entry.value,
        		can_tween: false,
        		keyframe: false
        	}; 
        
        }
        
        function proxy_ctx(ctx) {
    	//  Creates a proxy 2d context wrapper which 
    	//  allows the fluent / chaining API.
        	var wrapper = {};
        
        	function proxy_function(c) {
        		return function() {
    			//  Warning: this doesn't return value of function call
        			ctx[c].apply(ctx, arguments);
        			return wrapper;
        		};
        	}
        
        	function proxy_property(c) {
        		return function(v) {
        			ctx[c] = v;
        			return wrapper;
        		};
        	}
        
        	wrapper.run = function(args) {
        		args(wrapper);
        		return wrapper;
        	};
        
        	for (var c in ctx) {
    		//  if (!ctx.hasOwnProperty(c)) continue;
    		//  console.log(c, typeof(ctx[c]), ctx.hasOwnProperty(c));
    		//  string, number, boolean, function, object
        
        		var type = typeof(ctx[c]);
        		switch(type) {
        			case 'object':
        				break;
        			case 'function':
        				wrapper[c] = proxy_function(c);
        				break;
        			default:
        				wrapper[c] = proxy_property(c);
        				break;
        		}
        	}
        
        	return wrapper;
        }
        
    /**************************/
    // handleDrag
    /**************************/
        
        function handleDrag(element, ondown, onmove, onup, down_criteria) {
        	var pointer = null;
        	var bounds = element.getBoundingClientRect();
        	
        	element.addEventListener('mousedown', onMouseDown);
        
        	function onMouseDown(e) {
        		handleStart(e);
        
        		if (down_criteria && !down_criteria(pointer)) {
        			pointer = null;
        			return;
        		}
        
        		
        		document.addEventListener('mousemove', onMouseMove);
        		document.addEventListener('mouseup', onMouseUp);
        		
        		ondown(pointer);
        
        		e.preventDefault();
        	}
        	
        	function onMouseMove(e) {
        		handleMove(e);
        		onmove(pointer);
        	}
        
        	function handleStart(e) {
        		bounds = element.getBoundingClientRect();
        		var currentx = e.clientX, currenty = e.clientY;
        		pointer = {
        			startx: currentx,
        			starty: currenty,
        			x: currentx,
        			y: currenty,
        			dx: 0,
        			dy: 0,
        			offsetx: currentx - bounds.left,
        			offsety: currenty - bounds.top,
        			moved: false
        		};
        	}
        	
        	function handleMove(e) {
        		bounds = element.getBoundingClientRect();
        		var currentx = e.clientX,
        		currenty = e.clientY,
        		offsetx = currentx - bounds.left,
        		offsety = currenty - bounds.top;
        		pointer.x = currentx;
        		pointer.y = currenty;
        		pointer.dx = e.clientX - pointer.startx;
        		pointer.dy = e.clientY - pointer.starty;
        		pointer.offsetx = offsetx;
        		pointer.offsety = offsety;
        
        		// If the pointer dx/dy is _ever_ non-zero, then it's moved
        		pointer.moved = pointer.moved || pointer.dx !== 0 || pointer.dy !== 0;
        	}
        	
        	function onMouseUp(e) {
        		handleMove(e);
        		onup(pointer);
        		pointer = null;
        		
        		document.removeEventListener('mousemove', onMouseMove);
        		document.removeEventListener('mouseup', onMouseUp);
        	}
        
        	element.addEventListener('touchstart', onTouchStart);
        
        	function onTouchStart(te) {
        		
        		if (te.touches.length == 1) {
        			
        			var e = te.touches[0];
        			if (down_criteria && !down_criteria(e)) return;
        			te.preventDefault();
        			handleStart(e);
        			ondown(pointer);
        		}
        		
        		element.addEventListener('touchmove', onTouchMove);
        		element.addEventListener('touchend', onTouchEnd);
        	}
        	
        	function onTouchMove(te) {
        		var e = te.touches[0];
        		onMouseMove(e);
        	}
        
        	function onTouchEnd(e) {
        		// var e = e.touches[0];
        		onMouseUp(e);
        		element.removeEventListener('touchmove', onTouchMove);
        		element.removeEventListener('touchend', onTouchEnd);
        	}
        
        
        	this.release = function() {
        		element.removeEventListener('mousedown', onMouseDown);
        		element.removeEventListener('touchstart', onTouchStart);
        	};
        }
        
    /**************************/
    // ui_canvas
    /**************************/
    
    /*
     * Usage: canvas = new Canvas(width, height);
     * canvas.resize();
     */
        
    //  children
    //  1: override repaint
    //  2: add objects
    //  Canvas.uses(CanvasChild);
    //  CanvasItem
    //  width, height, x, y
    //  allow Drag
    //  allow Click
    //  mouseOver
        
        function Canvas(w, h) {
        
        	var canvas, ctx, width, height, dpr;
        
        	var canvasItems = [];
        	var child;
        
        	function create() {
        		canvas = document.createElement('canvas');
        		ctx = canvas.getContext('2d');
        	}
        
        	function setSize(w, h) {
        		width = w;
        		height = h;
        		dpr = window.devicePixelRatio;
        		canvas.width = width * dpr;
        		canvas.height = height * dpr;
        		canvas.style.width = width + 'px';
        		canvas.style.height = height + 'px';
        
        		if (child) child.setSize(w, h);
        	}
        
        	function paint(ctx) {
        		if (child) {
        			if (!child.paint) console.warn('implement repaint()')
        			child.paint(ctx);
        		}
        
        		var item;
        		for (var i = 0; i < canvasItems.length; i++) {
        			item = canvasItems[i];
        			item.paint()
        		}
        	}
        
        	function repaint() {
        		paint(ctx);
        	}
        
        	function add(item) {
        		canvasItems.push(item)
        	}
        
        	function remove(item) {
        		canvasItems.splice(canvasItems.indexOf(item), 1);
        	}
        
        	function uses(c) {
        		child = c;
        		child.add = this.add;
        		child.remove = this.remove;
        	}
        
        	create();
        	setSize(w, h);
        	this.setSize = setSize;
        	this.repaint = repaint;
        	this.uses = uses;
        
        	this.dom = canvas;
        
        	handleDrag(canvas,
        		function down(e) {
        			if (child.onDown) { child.onDown(e) };
        		},
        		function move(e) {
        			if (child.onMove) { child.onMove(e) };
        		},
        		function up(e) {
        			if (child.onUp) { child.onUp(e) };
        		}
    		//  function hit(e) {
    		//      if (child.onHit) { child.onHit(e) };
    		//  }
        	);
        }

    /**************************/
    // Tweens
    /**************************/
        
        var Tweens = {
        	none: function(k) {
        		return 0;
        	},
        	linear: function(k) {
        		return k;
        	},
        	quadEaseIn: function(k) {
        		return k * k;
        	},
        	quadEaseOut: function(k) {
        		return - k * ( k - 2 );
        	},
        	quadEaseInOut: function(k) {
        		if ( ( k *= 2 ) < 1 ) return 0.5 * k * k;
        		return - 0.5 * ( --k * ( k - 2 ) - 1 );
        	}
        };

    /**************************/
    // UINumber
    /**************************/
        
        function UINumber(config) {
        	config = config || {};
        	var min = config.min === undefined ? -Infinity : config.min;
        
    	//  config.xstep and config.ystep allow configuring adjustment
    	//  speed across each axis.
    	//  config.wheelStep and config.wheelStepFine allow configuring
    	//  adjustment speed for mousewheel, and mousewheel while holding <alt>
    
    	//  If only config.step is specified, all other adjustment speeds
    	//  are set to the same value.
    	
        	var xstep = firstDefined(config.xstep, config.step, 0.001);
        	var ystep = firstDefined(config.ystep, config.step, 0.1);
        	var wheelStep = firstDefined(config.wheelStep, ystep);
        	var wheelStepFine = firstDefined(config.wheelStepFine, xstep);
        
        	var precision = config.precision || 3;
    	//  Range.
    	//  Max.
        
        	var span = document.createElement('input');
    	//  span.type = 'number'; // spinner.
        	
        	style(span, {
        		textAlign: 'center',
        		fontSize: '10px',
        		padding: '1px',
        		cursor: 'ns-resize',
        		width: '40px',
        		margin: 0,
        		marginRight: '10px',
        		appearance: 'none',
        		outline: 'none',
        		border: 0,
        		background: 'none',
        		borderBottom: '1px dotted '+ Theme.c,
        		color: Theme.c
        	});
        
        	var me = this;
        	var state, value = 0, unchanged_value;
        
        	this.onChange = new Do();
        
        	span.addEventListener('change', function(e) {
        		console.log('input changed', span.value);
        		value = parseFloat(span.value, 10);
        
        		fireChange();
        	});
        
    	//  Allow keydown presses in inputs, don't allow parent to block them.
        	span.addEventListener('keydown', function(e) {
        		e.stopPropagation();
        	})
        
        	span.addEventListener('focus', function(e) {
        		span.setSelectionRange(0, span.value.length);
        	})
        
        	span.addEventListener('wheel', function(e) {
    		//  Disregard pixel/line/page scrolling and just
    		//  use event direction.
        		var inc = e.deltaY > 0? 1 : -1;
        		if(e.altKey) {
        			inc *= wheelStepFine;
        		} else {
        			inc *= wheelStep;
        		}
        		value = clamp(value + inc);
        		fireChange();
        	})
        
        	handleDrag(span, onDown, onMove, onUp);
        
        	function clamp(value) {
        		return Math.max(min, value);
        	}
        
        	function onUp(e) {
        		if (e.moved) fireChange();
        		else {
    			//  Single click.
        			span.focus();
        		}
        	}
        
        	function onMove(e) {
        		var dx = e.dx;
        		var dy = e.dy;
        	
        		value = unchanged_value + (dx * xstep) + (dy * -ystep);
        
        		value = clamp(value);
        
    		//  value = +value.toFixed(precision); // or toFixed toPrecision.
        		me.onChange.fire(value, true);
        	}
        
        	function onDown(e) {
        		unchanged_value = value;
        	}
        
        	function fireChange() {
        		me.onChange.fire(value);
        	}
        
        	this.dom = span;
        
    	//  Public.
        	this.setValue = function(v) {
        		value = v;
        		span.value = value.toFixed(precision);
        	};
        
        	this.paint = function() {
        		if (value && document.activeElement !== span) {
        			span.value = value.toFixed(precision);
        		}
        	};
        }
        

    /**************************/
    // View Time Srcoller
    /**************************/
        
        
        function Rect() {
        	
        }
        
        Rect.prototype.set = function(x, y, w, h, color, outline) {
        	this.x = x;
        	this.y = y;
        	this.w = w;
        	this.h = h;
        	this.color = color;
        	this.outline = outline;
        };
        
        Rect.prototype.paint = function(ctx) {
        	ctx.fillStyle = Theme.b;  // // 'yellow';
        	ctx.strokeStyle = Theme.c;
        
        	this.shape(ctx);
        
        	ctx.stroke();
        	ctx.fill();
        };
        
        Rect.prototype.shape = function(ctx) {
        	ctx.beginPath();
        	ctx.rect(this.x, this.y, this.w, this.h);
        };
        
        Rect.prototype.contains = function(x, y) {
        	return x >= this.x && y >= this.y
        	 && x <= this.x + this.w && y <= this.y + this.h;
        };
        
        
        
        function ScrollCanvas(dispatcher, data) {
        	var width, height;
        
        	this.setSize = function(w, h) {
        		width = w;
        		height = h;
        	}
        
        	var TOP_SCROLL_TRACK = 20;
        	var MARGINS = 15;
        
        	var scroller = {
        		left: 0,
        		grip_length: 0,
        		k: 1
        	};
        
        	var scrollRect = new Rect();
        
        	this.paint = function(ctx) {
        		var totalTime = data.get('ui:totalTime').value;
        		var scrollTime = data.get('ui:scrollTime').value;
        		var currentTime = data.get('ui:currentTime').value;
        		
        		var pixels_per_second = data.get('ui:timeScale').value;
        
        		ctx.save();
        
        		var w = width - 2 * MARGINS;
        		var h = 16; // TOP_SCROLL_TRACK; 16
        		var h2 = h;
        
        
        		ctx.clearRect(0, 0, width, height);
        		ctx.translate(MARGINS, 5);
        
        		// outline scroller
        		ctx.beginPath();
        		ctx.strokeStyle = Theme.b;
        		ctx.rect(0, 0, w, h);
        		ctx.stroke();
        		
        		var totalTimePixels = totalTime * pixels_per_second;
        		var k = w / totalTimePixels;
        		scroller.k = k;
        
        		var grip_length = w * k;
        
        		scroller.grip_length = grip_length;
        
        		scroller.left = scrollTime / totalTime * w;
        		
        		scrollRect.set(scroller.left, 0, scroller.grip_length, h);
        		scrollRect.paint(ctx);
        
        		var r = currentTime / totalTime * w;		
        
        		ctx.fillStyle =  Theme.c;
        		ctx.lineWidth = 2;
        		
        		ctx.beginPath();
        		
    		//  circle
    		//  ctx.arc(r, h2 / 2, h2 / 1.5, 0, Math.PI * 2);
        
    		//  Line.
        		ctx.rect(r, 0, 2, h + 5);
        		ctx.fill()
        
        		ctx.fillText(currentTime && currentTime.toFixed(2), r, h + 14);
    		//  ctx.fillText(currentTime && currentTime.toFixed(3), 10, 10);
        		ctx.fillText(totalTime, 300, 14);
        
        		ctx.restore();
        	}
        
        	/** Handles dragging for scroll bar **/
        
        	var draggingx = null;
        
        	this.onDown = function(e) {
    		//  console.log('ondown', e);
        
        		if (scrollRect.contains(e.offsetx - MARGINS, e.offsety -5)) {
        			draggingx = scroller.left;
        			return;
        		}
        		
        		var totalTime = data.get('ui:totalTime').value;
        		var pixels_per_second = data.get('ui:timeScale').value;
        		var w = width - 2 * MARGINS;
        
        		var t = (e.offsetx - MARGINS) / w * totalTime;
    		//  t = Math.max(0, t);
        
    		//  data.get('ui:currentTime').value = t;
        		dispatcher.fire('time.update', t);
        		
        	};
        
        	this.onMove = function move(e) {
        		if (draggingx != null) {
        			var totalTime = data.get('ui:totalTime').value;
        			var w = width - 2 * MARGINS;
        			
        			dispatcher.fire('update.scrollTime', 
        				(draggingx + e.dx)  / w * totalTime);
        
        		} else {
        			this.onDown(e);	
        		}
        		
        	};
        
        	this.onUp = function(e) {
        		draggingx = null;
        	}
        
        	/*** End handling for scrollbar ***/
        }

    /**************************/
    // View Panel
    /**************************/
        
        var
        	LINE_HEIGHT = Settings.LINE_HEIGHT,
        	DIAMOND_SIZE = Settings.DIAMOND_SIZE,
        	TIME_SCROLLER_HEIGHT = 0;
        	MARKER_TRACK_HEIGHT = 25,
        	LEFT_PANE_WIDTH = Settings.LEFT_PANE_WIDTH,
        	time_scale = Settings.time_scale,
        	TOP = 10;
        
        
        var frame_start = 0; // this is the current scroll position.
        
        
        /*
         * This class contains the view for the right main section of timeliner
         */
        
        
        // TODO
        // dirty rendering
        // drag block
        // DON'T use time.update for everything
        
        var tickMark1;
        var tickMark2;
        var tickMark3;
        
        function time_scaled() {
    	/*
    	 * Subdivison LOD
    	 * time_scale refers to number of pixels per unit
    	 * Eg. 1 inch - 60s, 1 inch - 60fps, 1 inch - 6 mins
    	 */
        	var div = 60;
        
        	tickMark1 = time_scale / div;
        	tickMark2 = 2 * tickMark1;
        	tickMark3 = 10 * tickMark1;
        
        }
        
        time_scaled();

    /**************************/
    // Timeline Panel
    /**************************/
        
        function TimelinePanel(data, dispatcher) {
        
        	var dpr = window.devicePixelRatio;
        	var canvas = document.createElement('canvas');
        
        	var scrollTop = 0, scrollLeft = 0, SCROLL_HEIGHT;
        	var layers = data.get('layers').value;
        
        	this.scrollTo = function(s, y) {
        		scrollTop = s * Math.max(layers.length * LINE_HEIGHT - SCROLL_HEIGHT, 0);
        		repaint();
        	};
        
        	this.resize = function() {
        		var h = (Settings.height - TIME_SCROLLER_HEIGHT);
        		dpr = window.devicePixelRatio;
        		canvas.width = Settings.width * dpr;
        		canvas.height = h * dpr;
        		canvas.style.width = Settings.width + 'px';
        		canvas.style.height = h + 'px';
        		SCROLL_HEIGHT = Settings.height - TIME_SCROLLER_HEIGHT;
        		scroll_canvas.setSize(Settings.width, TIME_SCROLLER_HEIGHT);
        	};
        
        	var div = document.createElement('div');
        
        	var scroll_canvas = new Canvas(Settings.width, TIME_SCROLLER_HEIGHT);
        	// data.addListener('ui', repaint );
        
        	style(canvas, {
        		position: 'absolute',
        		top: TIME_SCROLLER_HEIGHT + 'px',
        		left: '0px'
        	});
        
        	style(scroll_canvas.dom, {
        		position: 'absolute',
        		top: '0px',
        		left: '10px'
        	});
        
        	scroll_canvas.uses(new ScrollCanvas(dispatcher, data));
        
        
        	div.appendChild(canvas);
        //	div.appendChild(scroll_canvas.dom);
        
    	//  this.dom = canvas;
        	this.dom = div;
        	this.resize();
        
        	var ctx = canvas.getContext('2d');
        	var ctx_wrap = proxy_ctx(ctx);
        
        	var currentTime; // measured in seconds.
    	//  Technically it could be in frames or  have it in string format (0:00:00:1-60).
        
        	var LEFT_GUTTER = 20;
        	var i, x, y, il, j;
        
        	var needsRepaint = false;
        	var renderItems = [];
        
        	function EasingRect(x1, y1, x2, y2, frame, frame2, values, layer, j) {
        		var self = this;
        
        		this.path = function() {
        			ctx_wrap.beginPath()
        			.rect(x1, y1, x2-x1, y2-y1)
        			.closePath();
        		};
        
        		this.paint = function() {
        			this.path();
        			ctx.fillStyle = frame._color;
        			ctx.fill();
        		};
        
        		this.mouseover = function() {
        			canvas.style.cursor = 'pointer'; // pointer move ew-resize
        		};
        
        		this.mouseout = function() {
        			canvas.style.cursor = 'default';
        		};
        
        		this.mousedrag = function(e) {
        			var t1 = x_to_time(x1 + e.dx);
        			t1 = Math.max(0, t1);
    			//  TODO: limit moving to neighbours.
        			frame.time = t1;
        
        			var t2 = x_to_time(x2 + e.dx);
        			t2 = Math.max(0, t2);
        			frame2.time = t2;
        
    			//  dispatcher.fire('time.update', t1);
        		};
        	}
        
        	function Diamond(frame, y) {
        		var x, y2;
        
        		x = time_to_x(frame.time);
        		y2 = y + LINE_HEIGHT * 0.5  - DIAMOND_SIZE / 2;
        
        		var self = this;
        
        		var isOver = false;
        
        		this.path = function(ctx_wrap) {
        			ctx_wrap
        				.beginPath()
        				.moveTo(x, y2)
        				.lineTo(x + DIAMOND_SIZE / 2, y2 + DIAMOND_SIZE / 2)
        				.lineTo(x, y2 + DIAMOND_SIZE)
        				.lineTo(x - DIAMOND_SIZE / 2, y2 + DIAMOND_SIZE / 2)
        				.closePath();
        		};
        
        		this.paint = function(ctx_wrap) {
        			self.path(ctx_wrap);
        			if (!isOver)
        				ctx_wrap.fillStyle(Theme.c);
        			else
        				ctx_wrap.fillStyle('yellow'); // Theme.d
        
        			ctx_wrap.fill()
        			.stroke();
        		};
        
        		this.mouseover = function() {
        			isOver = true;
        			canvas.style.cursor = 'move'; // pointer move ew-resize
        			self.paint(ctx_wrap);
        		};
        
        		this.mouseout = function() {
        			isOver = false;
        			canvas.style.cursor = 'default';
        			self.paint(ctx_wrap);
        		};
        
        		this.mousedrag = function(e) {
        			var t = x_to_time(x + e.dx);
        			t = Math.max(0, t);
        			// TODO limit moving to neighbours
        			frame.time = t;
        			dispatcher.fire('time.update', t);
        			// console.log('frame', frame);
        			// console.log(s, format_friendly_seconds(s), this);
        		};
        
        	}
        
        	function repaint() {
        		needsRepaint = true;
        	}
        
        
        	function drawLayerContents() {
        		renderItems = [];
    		//  Horizontal Layer lines.
        		for (i = 0, il = layers.length; i <= il; i++) {
        			ctx.strokeStyle = Theme.b;
        			ctx.beginPath();
        			y = i * LINE_HEIGHT;
        			y = ~~y - 0.5;
        
        			ctx_wrap
        			.moveTo(0, y)
        			.lineTo(width, y)
        			.stroke();
        		}
        
        
        		var frame, frame2, j;
        
    		//  Draw Easing Rects.
        		for (i = 0; i < il; i++) {
    			//  Check for keyframes.
        			var layer = layers[i];
        			var values = layer.values;
        
        			y = i * LINE_HEIGHT;
        
        			for (j = 0; j < values.length - 1; j++) {
        				frame = values[j];
        				frame2 = values[j + 1];
        
        				// Draw Tween Rect
        				x = time_to_x(frame.time);
        				x2 = time_to_x(frame2.time);
        
        				if (!frame.tween || frame.tween == 'none') continue;
        
        				var y1 = y + 2;
        				var y2 = y + LINE_HEIGHT - 2;
        
        				renderItems.push(new EasingRect(x, y1, x2, y2, frame, frame2));
                    /*
    				//  Draw easing graph.
                        var color = parseInt(frame._color.substring(1,7), 16);
                        color = 0xffffff ^ color;
                        color = color.toString(16);           // convert to hex.
                        color = '#' + ('000000' + color).slice(-6);
                        
                        ctx.strokeStyle = color;
                        var x3;
                        ctx.beginPath();
                        ctx.moveTo(x, y2);
                        var dy = y1 - y2;
                        var dx = x2 - x;
                        
                        for (x3=x; x3 < x2; x3++) {
                            ctx.lineTo(x3, y2 + Tweens[frame.tween]((x3 - x)/dx) * dy);
                        }
                        ctx.stroke();
    				*/
        			}
        
        			for (j = 0; j < values.length; j++) {
    				//  Diamonds.
        				frame = values[j];
        				renderItems.push(new Diamond(frame, y));
        			}
        		}
        
    		//  Render items.
        		var item;
        		for (i = 0, il = renderItems.length; i < il; i++) {
        			item = renderItems[i];
        			item.paint(ctx_wrap);
        		}
        	}
        
        	function setTimeScale() {
        
        		var v = data.get('ui:timeScale').value;
        		if (time_scale !== v) {
        			time_scale = v;
        			time_scaled();
        		}
        	}
        
        	var over = null;
        	var mousedownItem = null;
        
        	function check() {
        		var item;
        		var last_over = over;
    		//  over = [];
        		over = null;
        		for (i = renderItems.length; i-- > 0;) {
        			item = renderItems[i];
        			item.path(ctx_wrap);
        
        			if (ctx.isPointInPath(pointer.x * dpr, pointer.y * dpr)) {
    				//  over.push(item);
        				over = item;
        				break;
        			}
        		}
        
    		//  Clear old mousein.
        		if (last_over && last_over != over) {
        			item = last_over;
        			if (item.mouseout) item.mouseout();
        		}
        
        		if (over) {
        			item = over;
        			if (item.mouseover) item.mouseover();
        
        			if (mousedown2) {
        				mousedownItem = item;
        			}
        		}

    		//  console.log(pointer)
        	}
        
        	function pointerEvents() {
        		if (!pointer) return;
        
        		ctx_wrap
        			.save()
        			.scale(dpr, dpr)
        			.translate(0, MARKER_TRACK_HEIGHT)
        			.beginPath()
        			.rect(0, 0, Settings.width, SCROLL_HEIGHT)
        			.translate(-scrollLeft, -scrollTop)
        			.clip()
        				.run(check)
        			.restore();
        	}
        
        	function _paint() {
        		if (!needsRepaint) {
        			pointerEvents();
        			return;
        		}
        
        		scroll_canvas.repaint();
        
        		setTimeScale();
        
        		currentTime = data.get("ui:currentTime").value;
        		frame_start =  data.get("ui:scrollTime").value;
        
    		/**************************/
    		// Background.
            /**************************/
                
        		ctx.fillStyle = Theme.a;
        		ctx.clearRect(0, 0, canvas.width, canvas.height);
        		ctx.save();
        		ctx.scale(dpr, dpr);
        
        		//
        
        		ctx.lineWidth = 1; // .5, 1, 2
        
        		width = Settings.width,
        		height = Settings.height;
        
        		var units = time_scale / tickMark1;
        		var offsetUnits = (frame_start * time_scale) % units;
        
        		var count = (width - LEFT_GUTTER + offsetUnits) / units;
        
    		//  console.log('time_scale', time_scale, 'tickMark1', tickMark1, 'units', units, 'offsetUnits', offsetUnits, frame_start);
        
    		//  time_scale = pixels to 1 second (40)
    		//  tickMark1 = marks per second (marks / s)
    		//  units = pixels to every mark (40)
        
    		//  Labels only.
        		for (i = 0; i < count; i++) {
        			x = i * units + LEFT_GUTTER - offsetUnits;
        
    			//  Vertical lines.
        			ctx.strokeStyle = Theme.b;
        			ctx.beginPath();
        			ctx.moveTo(x, 0);
        			ctx.lineTo(x, height);
        			ctx.stroke();
        
        			ctx.fillStyle = Theme.d;
        			ctx.textAlign = 'center';
        
        			var t = (i * units - offsetUnits) / time_scale + frame_start;
        			t = format_friendly_seconds(t);
        			ctx.fillText(t, x, 38);
        		}
        
        		units = time_scale / tickMark2;
        		count = (width - LEFT_GUTTER + offsetUnits) / units;
        
    		//  Marker lines - main.
        		for (i = 0; i < count; i++) {
        			ctx.strokeStyle = Theme.c;
        			ctx.beginPath();
        			x = i * units + LEFT_GUTTER - offsetUnits;
        			ctx.moveTo(x, MARKER_TRACK_HEIGHT - 0);
        			ctx.lineTo(x, MARKER_TRACK_HEIGHT - 16);
        			ctx.stroke();
        		}
        
        		var mul = tickMark3 / tickMark2;
        		units = time_scale / tickMark3;
        		count = (width - LEFT_GUTTER + offsetUnits) / units;
        
    		//  Small ticks.
        		for (i = 0; i < count; i++) {
        			if (i % mul === 0) continue;
        			ctx.strokeStyle = Theme.c;
        			ctx.beginPath();
        			x = i * units + LEFT_GUTTER - offsetUnits;
        			ctx.moveTo(x, MARKER_TRACK_HEIGHT - 0);
        			ctx.lineTo(x, MARKER_TRACK_HEIGHT - 10);
        			ctx.stroke();
        		}
        
    		//  Encapsulate a scroll rect for the layers.
        		ctx_wrap
        			.save()
        			.translate(0, MARKER_TRACK_HEIGHT)
        			.beginPath()
        			.rect(0, 0, Settings.width, SCROLL_HEIGHT)
        			.translate(-scrollLeft, -scrollTop)
        			.clip()
        				.run(drawLayerContents)
        			.restore();
        /*
    		//  Current Marker / Cursor.
        		ctx.strokeStyle = 'red'; // Theme.c
        		x = (currentTime - frame_start) * time_scale + LEFT_GUTTER;
        
        		var txt = format_friendly_seconds(currentTime);
        		var textWidth = ctx.measureText(txt).width;
        
        		var base_line = MARKER_TRACK_HEIGHT - 5, half_rect = textWidth / 2 + 4;
        
        		ctx.beginPath();
        		ctx.moveTo(x, base_line);
        		ctx.lineTo(x, height);
        		ctx.stroke();
        
        		ctx.fillStyle = 'red'; // black
        		ctx.textAlign = 'center';
        		ctx.beginPath();
        		ctx.moveTo(x, base_line + 5);
        		ctx.lineTo(x + 5, base_line);
        		ctx.lineTo(x + half_rect, base_line);
        		ctx.lineTo(x + half_rect, base_line - 14);
        		ctx.lineTo(x - half_rect, base_line - 14);
        		ctx.lineTo(x - half_rect, base_line);
        		ctx.lineTo(x - 5, base_line);
        		ctx.closePath();
        		ctx.fill();
        
        		ctx.fillStyle = 'white';
        		ctx.fillText(txt, x, base_line - 4);
        
        		ctx.restore();
        
        		needsRepaint = false;
    		//  pointerEvents();
        */
        	}
        
        	function y_to_track(y) {
        		if (y - MARKER_TRACK_HEIGHT < 0) return -1;
        		return (y - MARKER_TRACK_HEIGHT + scrollTop) / LINE_HEIGHT | 0;
        	}
        
        
        	function x_to_time(x) {
        		var units = time_scale / tickMark3;
        
    		//  return frame_start + (x - LEFT_GUTTER) / time_scale;
        
        		return frame_start + ((x - LEFT_GUTTER) / units | 0) / tickMark3;
        	}
        
        	function time_to_x(s) {
        		var ds = s - frame_start;
        		ds *= time_scale;
        		ds += LEFT_GUTTER;
        
        		return ds;
        	}
        
        	var me = this;
        	this.repaint = repaint;
        	this._paint = _paint;
        
        	repaint();
        
        	var mousedown = false, selection = false;
        
        	var dragObject;
        	var canvasBounds;
        
        	canvas.addEventListener('mousemove', onMouseMove);
        
        	canvas.addEventListener('dblclick', function(e) {
        		canvasBounds = canvas.getBoundingClientRect();
        		var mx = e.clientX - canvasBounds.left , my = e.clientY - canvasBounds.top;
        
        
        		var track = y_to_track(my);
        		var s = x_to_time(mx);
        
        
        		dispatcher.fire('keyframe', layers[track], currentTime);
        
        	});
        
        	function onMouseMove(e) {
        		canvasBounds = canvas.getBoundingClientRect();
        		var mx = e.clientX - canvasBounds.left , my = e.clientY - canvasBounds.top;
        		onPointerMove(mx, my);
        	}
        
        	var pointerdidMoved = false;
        	var pointer = null;
        
        	function onPointerMove(x, y) {
        		if (mousedownItem) return;
        		pointerdidMoved = true;
        		pointer = {x: x, y: y};
        	}
        
        	canvas.addEventListener('mouseout', function() {
        		pointer = null;
        	});
        
        	var mousedown2 = false, mouseDownThenMove = false;
        	handleDrag(canvas, function down(e) {
        			mousedown2 = true;
        			pointer = {
        				x: e.offsetx,
        				y: e.offsety
        			};
        			pointerEvents();
        
        			if (!mousedownItem) dispatcher.fire('time.update', x_to_time(e.offsetx));
        			// Hit criteria
        		}, function move(e) {
        			mousedown2 = false;
        			if (mousedownItem) {
        				mouseDownThenMove = true;
        				if (mousedownItem.mousedrag) {
        					mousedownItem.mousedrag(e);
        				}
        			} else {
        				dispatcher.fire('time.update', x_to_time(e.offsetx));
        			}
        		}, function up(e) {
        			if (mouseDownThenMove) {
        				dispatcher.fire('keyframe.move');
        			}
        			else {
        				dispatcher.fire('time.update', x_to_time(e.offsetx));
        			}
        			mousedown2 = false;
        			mousedownItem = null;
        			mouseDownThenMove = false;
        		}
        	);
        
        	this.setState = function(state) {
        		layers = state.value;
        		repaint();
        	};
        
        }

    /*******************************************/
    // View Layer
    /*******************************************/
        
        function LayerView(layer, dispatcher) {
        	var dom = document.createElement('div');
        
        	var label = document.createElement('span');
        	
        	label.style.cssText = 'font-size: 12px; padding: 4px;';
        
        	var dropdown = document.createElement('select');
        	var option;
        	dropdown.style.cssText = 'font-size: 10px; width: 60px; margin: 0; float: right; text-align: right;';
        
        	for (var k in Tweens) {
        		option = document.createElement('option');
        		option.text = k;
        		dropdown.appendChild(option);
        	}
        
        	dropdown.addEventListener('change', function(e) {
        		dispatcher.fire('ease', layer, dropdown.value);
        	});
        	var height = (Settings.LINE_HEIGHT - 1);
        
        	var keyframe_button = document.createElement('button');
        	keyframe_button.innerHTML = '&#9672;'; // '&diams;' &#9671; 9679 9670 9672
        	keyframe_button.style.cssText = 'background: none; font-size: 12px; padding: 0px; font-family: monospace; float: right; width: 20px; height: ' + height + 'px; border-style:none; outline: none;'; //  border-style:inset;
        	
        	keyframe_button.addEventListener('click', function(e) {
        		console.log('clicked:keyframing...', state.get('_value').value);
        		dispatcher.fire('keyframe', layer, state.get('_value').value);
        	});
        
    	/*
    	//  Prev Keyframe
        	var button = document.createElement('button');
        	button.textContent = '<';
        	button.style.cssText = 'font-size: 12px; padding: 1px; ';
        	dom.appendChild(button);
        
    	//  Next Keyframe
        	button = document.createElement('button');
        	button.textContent = '>';
        	button.style.cssText = 'font-size: 12px; padding: 1px; ';
        	dom.appendChild(button);
    	*/
        
        	function ToggleButton(text) {
    		//  For css based button see http://codepen.io/mallendeo/pen/eLIiG.
        
        		var button = document.createElement('button');
        		button.textContent = text;
        
        		style(button, {
        			fontSize: '12px',
        			padding: '1px',
        			borderSize: '2px',
        			outline: 'none',
        			background: '#fff'
        		});
        
        		this.pressed = false;''
        
        		button.onclick = function() {
        			this.pressed = !this.pressed;
        
        			style(button, {
        				borderStyle: this.pressed ? 'inset' : 'outset', // inset outset groove ridge
        			})
        
        			if (this.onClick) this.onClick();
        		}.bind(this);
        
        		this.dom = button;
        
        	}
        
    	//  Solo. 
        	var solo_toggle = new ToggleButton('S');
        	dom.appendChild(solo_toggle.dom);
        
        	solo_toggle.onClick = function() {
        		dispatcher.fire('action:solo', layer, solo_toggle.pressed);
        	}
        
    	//  Mute.
        	var mute_toggle = new ToggleButton('M');
        	dom.appendChild(mute_toggle.dom);
        
        	mute_toggle.onClick = function() {
        		dispatcher.fire('action:mute', layer, mute_toggle.pressed);
        	}
        
        
        	var number = new UINumber(layer, dispatcher);
        
        	number.onChange.do(function(value, done) {
        		state.get('_value').value = value;
        		dispatcher.fire('value.change', layer, value, done);
        	});
        
        	style(number.dom, {
        		float: 'right'
        	});
        
        	dom.appendChild(label);
        	dom.appendChild(keyframe_button);
        	dom.appendChild(number.dom);
        	dom.appendChild(dropdown);
        	
        
        	style(dom, {
        		textAlign: 'left',
        		margin: '0px 0px 0px 5px',
        		borderBottom: '1px solid ' + Theme.b,
        		top: 0,
        		left: 0,
        		height: (Settings.LINE_HEIGHT - 1 ) + 'px',
        		color: Theme.c
        	});
        
        	this.dom = dom;
        
        	this.repaint = repaint;
        	var state;
        
        	this.setState = function(l, s) {
        		layer = l;
        		state = s;
        
        		var tmp_value = state.get('_value');
        		if (tmp_value.value === undefined) {
        			tmp_value.value = 0;
        		}
        
        		number.setValue(tmp_value.value);
        		label.textContent = state.get('name').value;
        
        		repaint();
        	};
        
        	function repaint(s) {
        
        		dropdown.style.opacity = 0;
        		dropdown.disabled = true;
        		keyframe_button.style.color = Theme.b;
    		//  keyframe_button.disabled = false;
    		//  keyframe_button.style.borderStyle = 'solid';
        
        		var tween = null;
        		var o = timeAtLayer(layer, s);
        
        		if (!o) return;
        
        		if (o.can_tween) {
        			dropdown.style.opacity = 1;
        			dropdown.disabled = false;
    			//  if (o.tween)
        			dropdown.value = o.tween ? o.tween : 'none';
        			if (dropdown.value === 'none') dropdown.style.opacity = 0.5;
        		}
        
        		if (o.keyframe) {
        			keyframe_button.style.color = Theme.c;
    			//  keyframe_button.disabled = true;
    			//  keyframe_button.style.borderStyle = 'inset';
        		}
        
        		state.get('_value').value = o.value;
        		number.setValue(o.value);
        		number.paint();
        
        		dispatcher.fire('target.notify', layer.name, o.value);
        	}
        
        }
        
        
    /*******************************************/
    // View Layer Cabinet
    /*******************************************/
        
        
        function LayerCabinet(data, dispatcher) {
        	var layer_store = data.get('layers');
        
        	var div = document.createElement('div');
        
        	var top = document.createElement('div');
        	top.style.cssText = 'margin: 0px; top: 0; left: 0; height: ' + Settings.MARKER_TRACK_HEIGHT + 'px';
    	//  top.style.textAlign = 'right';
        
        	var layer_scroll = document.createElement('div');
        	style(layer_scroll, {
        		position: 'absolute',
        		top: Settings.MARKER_TRACK_HEIGHT + 'px',
    		//  height: (Settings.height - Settings.MARKER_TRACK_HEIGHT) + 'px'
        		left: 0,
        		right: 0,
        		bottom: 0,
        		overflow: 'hidden'
        	});
        
        	div.appendChild(layer_scroll);
        
        	var playing = false;
        
        
        	var button_styles = {
        		width: '22px',
        		height: '22px',
        		padding: '2px'
        	};
        
        	var op_button_styles = {
        		width: '32px',
        		padding: '3px 4px 3px 4px'
        	};
        
        /*
        	var play_button = new IconButton(16, 'play', 'play', dispatcher);
        	style(play_button.dom, button_styles, { marginTop: '2px' } );
        	play_button.onClick(function(e) {
        		e.preventDefault();
        		dispatcher.fire('controls.toggle_play');
        	});
        
        	var stop_button = new IconButton(16, 'stop', 'stop', dispatcher);
        	style(stop_button.dom, button_styles, { marginTop: '2px' } );
        	stop_button.onClick(function(e) {
        		dispatcher.fire('controls.stop');
        	});
        */
        /*
        	var undo_button = new IconButton(16, 'undo', 'undo', dispatcher);
        	style(undo_button.dom, op_button_styles);
        	undo_button.onClick(function() {
        		dispatcher.fire('controls.undo');
        	});
        
        	var redo_button = new IconButton(16, 'repeat', 'redo', dispatcher);
        	style(redo_button.dom, op_button_styles);
        	redo_button.onClick(function() {
        		dispatcher.fire('controls.redo');
        	});
        */
        	var range = document.createElement('input');
        	range.type = "range";
        	range.value = 0;
        	range.min = -1;
        	range.max = +1;
        	range.step = 0.125;
        
        	style(range, {
        		width: '90px',
        		margin: '0px',
        		marginLeft: '2px',
        		marginRight: '2px'
        	});
        
        	var draggingRange = 0;
        
        	range.addEventListener('mousedown', function() {
        		draggingRange = 1;
        	});
        
        	range.addEventListener('mouseup', function() {
        		draggingRange = 0;
        		changeRange();
        	});
        
        	range.addEventListener('mousemove', function() {
        		if (!draggingRange) return;
        		changeRange();
        	});
        
        	div.appendChild(top);
        
        	var time_options = {
        		min: 0,
        		step: 0.125
        	};
        
        	var currentTime = new UINumber(time_options);
        	var totalTime = new UINumber(time_options);
        
        	var currentTimeStore = data.get('ui:currentTime');
        	var totalTimeStore = data.get('ui:totalTime');
        /*
        	UI2StoreBind(view, datastore) {
                view.onChange.do(function(v) {
        	 		datastore.value = view;
        	 	})
        
        	 	datastore.onChange.do(function(v) {
        	 		view.setValue = v;
        	 	})
            }
        */
        	currentTime.onChange.do(function(value, done) {
        		dispatcher.fire('time.update', value);
        		// repaint();
        	});
        
        	totalTime.onChange.do(function(value, done) {
        		totalTimeStore.value = value;
        		repaint();
        	});
        
    	//  Play Controls.
        //	top.appendChild(currentTime.dom);
        //	top.appendChild(document.createTextNode('/')); // 0:00:00 / 0:10:00
        //	top.appendChild(totalTime.dom)
        //	top.appendChild(play_button.dom);
        //	top.appendChild(stop_button.dom);
        //	top.appendChild(range);
        
        
        	var operations_div = document.createElement('div');
        	style(operations_div, {
        		marginTop: '4px',
    		//  borderBottom: '1px solid ' + Theme.b
        	});
        	top.appendChild(operations_div);
    	//  top.appendChild(document.createElement('br'));
        
        
    	//  Open _alt.
        //	var file_open = new IconButton(16, 'folder_open_alt', 'Open', dispatcher);
        //	style(file_open.dom, op_button_styles);
        //	operations_div.appendChild(file_open.dom);
        
        	function populateOpen() {
        		while (dropdown.length) {
        			dropdown.remove(0);
        		}
        
        		var option;
        		option = document.createElement('option');
        		option.text = 'New';
        		option.value = '*new*';
        		dropdown.add(option);
        
        		option = document.createElement('option');
        		option.text = 'Import JSON';
        		option.value = '*import*';
        		dropdown.add(option);
        
    		//  Doesn't work.
    		//  option = document.createElement('option');
    		//  option.text = 'Select File';
    		//  option.value = '*select*';
    		//  dropdown.add(option);
        
        		option = document.createElement('option');
        		option.text = '==Open==';
        		option.disabled = true;
        		option.selected = true;
        		dropdown.add(option);
        
        		var regex = new RegExp(STORAGE_PREFIX + '(.*)');
        		for (var key in localStorage) {
        			// console.log(key);
        
        			var match = regex.exec(key);
        			if (match) {
        				option = document.createElement('option');
        				option.text = match[1];
        
        				dropdown.add(option);
        			}
        		}
        
        	}
        
    	//  Listen on other tabs.
        	window.addEventListener('storage', function(e) {
        		var regex = new RegExp(STORAGE_PREFIX + '(.*)');
        		if (regex.exec(e.key)) {
        			populateOpen();
        		}
        	});
        
        	dispatcher.on('save:done', populateOpen);
        
        	var dropdown = document.createElement('select');
        
        	style(dropdown, {
        		position: 'absolute',
    		//  right: 0,
    		//  margin: 0,
        		opacity: 0,
        		width: '16px',
        		height: '16px',
    		//  zIndex: 1,
        	});
        
        	dropdown.addEventListener('change', function(e) {
    		//  console.log('changed', dropdown.length, dropdown.value);
        
        		switch (dropdown.value) {
        			case '*new*':
        				dispatcher.fire('new');
        				break;
        			case '*import*':
        				dispatcher.fire('import');
        				break;
        			case '*select*':
        				dispatcher.fire('openfile');
        				break;
        			default:
        				dispatcher.fire('open', dropdown.value);
        				break;
        		}
        	});
        
        //	file_open.dom.insertBefore(dropdown, file_open.dom.firstChild);
        
        	populateOpen();
        
    	//  Json import.
    	
    	/*
        	var import_json = new IconButton(16, 'signin', 'Import JSON', dispatcher);
        	operations_div.appendChild(import_json.dom);
        	import_json.onClick(function() {
        	   dispatcher.fire('import');
        	});
        
    	//  New.
        	var file_alt = new IconButton(16, 'file_alt', 'New', dispatcher);
        	operations_div.appendChild(file_alt.dom);
        */
        
    	//  Save.
    	
    	/*
        	var save = new IconButton(16, 'save', 'Save', dispatcher);
        	style(save.dom, op_button_styles);
        	operations_div.appendChild(save.dom);
        	save.onClick(function() {
        		dispatcher.fire('save');
        	});
        */
        
    	//  Save as.
    	
    	/*
        	var save_as = new IconButton(16, 'paste', 'Save as', dispatcher);
        	style(save_as.dom, op_button_styles);
        	operations_div.appendChild(save_as.dom);
        	save_as.onClick(function() {
        		dispatcher.fire('save_as');
        	});
        */
        
    	//  Download json (export).
    	
    	/*
        	var download_alt = new IconButton(16, 'download_alt', 'Download / Export JSON to file', dispatcher);
        	style(download_alt.dom, op_button_styles);
        	operations_div.appendChild(download_alt.dom);
        	download_alt.onClick(function() {
        		dispatcher.fire('export');
        	});
        
        	var upload_alt = new IconButton(16, 'upload_alt', 'Load from file', dispatcher);
        	style(upload_alt.dom, op_button_styles);
        	operations_div.appendChild(upload_alt.dom);
        	upload_alt.onClick(function() {
        		dispatcher.fire('openfile');
        	});
        
        	var span = document.createElement('span');
        	span.style.width = '20px';
        	span.style.display = 'inline-block';
        	operations_div.appendChild(span);
        
        	operations_div.appendChild(undo_button.dom);
        	operations_div.appendChild(redo_button.dom);
        	operations_div.appendChild(document.createElement('br'));
        */
        
    	//  Cloud Download / Upload edit pencil.
        
    	/*
    	//  Show layer.
    	//  var eye_open = new IconButton(16, 'eye_open', 'eye_open', dispatcher);
    	//  operations_div.appendChild(eye_open.dom);
        
    	//  Hide / disable layer.
    	//  var eye_close = new IconButton(16, 'eye_close', 'eye_close', dispatcher);
    	//  operations_div.appendChild(eye_close.dom);
        
    	//  Remove layer.
        	var minus = new IconButton(16, 'minus', 'minus', dispatcher);
        	operations_div.appendChild(minus.dom);
        
    	//  Check.
        	var ok = new IconButton(16, 'ok', 'ok', dispatcher);
        	operations_div.appendChild(ok.dom);
        
    	//  Cross.
        	var remove = new IconButton(16, 'remove', 'remove', dispatcher);
        	operations_div.appendChild(remove.dom);
    	*/
        
        
    	//  range.addEventListener('change', changeRange);
        
        
        	function convertPercentToTime(t) {
        		var min_time = 10 * 60; // 10 minutes
        		min_time = data.get('ui:totalTime').value;
        		var max_time = 1;
        		var v = Settings.width * 0.8 / (t * (max_time - min_time) + min_time);
        		return v;
        	}
        
        	function convertTimeToPercent(v) {
        		var min_time = 10 * 60; // 10 minutes
        		min_time = data.get('ui:totalTime').value;
        		var max_time = 1;
        		var t  = ((Settings.width * 0.8 / v) - min_time)  / (max_time - min_time);
        		return t;
        	}
        
        	function changeRange() {
        
        		dispatcher.fire('update.scale', Math.pow(100, -range.value) );
        	}
        
        	var layer_uis = [], visible_layers = 0;
        	var unused_layers = [];
        
        	this.layers = layer_uis;
        
        	this.setControlStatus = function(v) {
        		playing = v;
        		if (playing) {
                //  play_button.setIcon('pause');
                //  play_button.setTip('pause');
        		}
        		else {
                //  play_button.setIcon('play');
                //  play_button.setTip('play');
        		}
        	};
        
        	this.setState = function(state) {
        /*
        		layer_store = state;
        		layers = layer_store.value;
        		 layers = state;
        		console.log(layer_uis.length, layers);
        		var i, layer;
        		for (i = 0; i < layers.length; i++) {
        			layer = layers[i];
        
        			if (!layer_uis[i]) {
        				var layer_ui;
        				if (unused_layers.length) {
        					layer_ui = unused_layers.pop();
        					layer_ui.dom.style.display = 'block';
        				} else {
        					 new
        					layer_ui = new ViewLayer(layer, dispatcher);
        					layer_scroll.appendChild(layer_ui.dom);
        				}
        				layer_uis.push(layer_ui);
        			}
        
        			 layer_uis[i].setState(layer);
        		}
        
        		console.log('Total layers (view, hidden, total)', layer_uis.length, unused_layers.length,
        			layer_uis.length + unused_layers.length);
        */
        	};
        
        	function repaint(s) {
        
        		s = currentTimeStore.value;
        		currentTime.setValue(s);
        		totalTime.setValue(totalTimeStore.value);
        		currentTime.paint();
        		totalTime.paint();
        
        		var i;
        
        		s = s || 0;
        		for (i = layer_uis.length; i-- > 0;) {
        			// quick hack
        			if (i >= layers.length) {
        				layer_uis[i].dom.style.display = 'none';
        				unused_layers.push(layer_uis.pop());
        				continue;
        			}
        
        			layer_uis[i].setState(layers[i], layer_store.get(i));
    			//  layer_uis[i].setState('layers'+':'+i);
        			layer_uis[i].repaint(s);
        		}
        
        		visible_layers = layer_uis.length;
        
        	}
        
        	this.repaint = repaint;
        	this.setState(layer_store);
        
        	this.scrollTo = function(x) {
        		layer_scroll.scrollTop = x * (layer_scroll.scrollHeight - layer_scroll.clientHeight);
        	};
        
        	this.dom = div;
        
        	repaint();
        }
        
        
        
    /*******************************************/
    // Timeliner
    /*
     * @author Joshua Koo http://joshuakoo.com
     */
    /*******************************************/
        
        
        var Z_INDEX = 999;
        
        
        function LayerProp(name) {
        	this.name = name;
        	this.values = [];
        
        	this._value = 0;
        
        	this._color = '#' + (Math.random() * 0xffffff | 0).toString(16);
    	/*
        	this.max
        	this.min
        	this.step
    	*/
        }
        
        
        function Timeliner(target) {
    	//  Dispatcher for coordination.
        	var dispatcher = new Dispatcher();
        
    	//  Data.
        	var data = new DataStore();
        	var layer_store = data.get('layers');
        	var layers = layer_store.value;
        
        	window._data = data; // expose it for debugging
        
    	//  Undo manager.
        //	var undo_manager = new UndoManager(dispatcher);
        
        	// Views
        	var timeline = new TimelinePanel(data, dispatcher);
        	var layer_panel = new LayerCabinet(data, dispatcher);
        
        //	setTimeout(function() {
    		//  Hack!
        //		undo_manager.save(new UndoState(data, 'Loaded'), true);
        //	});
        
        
        	dispatcher.on('keyframe', function(layer, value) {
        		var index = layers.indexOf(layer);
        
        		var t = data.get('ui:currentTime').value;
        		var v = findTimeinLayer(layer, t);
        
    		//  console.log(v, '...keyframe index', index, format_friendly_seconds(t), typeof(v));
    		//  console.log('layer', layer, value);
        
        		if (typeof(v) === 'number') {
        			layer.values.splice(v, 0, {
        				time: t,
        				value: value,
        				_color: '#' + (Math.random() * 0xffffff | 0).toString(16)
        			});

                //  undo_manager.save(new UndoState(data, 'Add Keyframe'));
                
        		} else {
        			console.log('remove from index', v);
        			layer.values.splice(v.index, 1);
                //  undo_manager.save(new UndoState(data, 'Remove Keyframe'));
        		}
        
        		repaintAll();
        
        	});
        
        
        	dispatcher.on('keyframe.move', function(layer, value) {
            //  undo_manager.save(new UndoState(data, 'Move Keyframe'));
        	});
        
    	//  dispatcher.fire('value.change', layer, me.value);
        	dispatcher.on('value.change', function(layer, value, dont_save) {
        		if (layer._mute) return;
        
        		var t = data.get('ui:currentTime').value;
        		var v = findTimeinLayer(layer, t);
        
    		//  console.log(v, 'value.change', layer, value, format_friendly_seconds(t), typeof(v));
        		if (typeof(v) === 'number') {
        			layer.values.splice(v, 0, {
        				time: t,
        				value: value,
        				_color: '#' + (Math.random() * 0xffffff | 0).toString(16)
        			});
                //  if (!dont_save) undo_manager.save(new UndoState(data, 'Add value'));
        		} else {
        			v.object.value = value;
                //  if (!dont_save) undo_manager.save(new UndoState(data, 'Update value'));
        		}
        
        		repaintAll();
        	});
        
        	dispatcher.on('action:solo', function(layer, solo) {
        		layer._solo = solo;
        
        		console.log(layer, solo);
        
    		//  When a track is solo-ed, playback only changes values
    		//  of that layer.
        	});
        
        	dispatcher.on('action:mute', function(layer, mute) {
        		layer._mute = mute;
        
    		//  When a track is mute, playback does not play
    		//  frames of those muted layers.
    
    		//  also feels like hidden feature in photoshop
    
    		//  when values are updated, eg. from slider,
    		//  no tweens will be created.
    		//  we can decide also to "lock in" layers
    		//  no changes to tween will be made etc.
        	});
        
        	dispatcher.on('ease', function(layer, ease_type) {
        		var t = data.get('ui:currentTime').value;
        		var v = timeAtLayer(layer, t);
        		// console.log('Ease Change > ', layer, value, v);
        		if (v && v.entry) {
        			v.entry.tween  = ease_type;
        		}
        
        //		undo_manager.save(new UndoState(data, 'Add Ease'));
        
        		repaintAll();
        	});
        
        	var start_play = null,
        		played_from = 0; // requires some more tweaking
        
        	dispatcher.on('controls.toggle_play', function() {
        		if (start_play) {
        			pausePlaying();
        		} else {
        			startPlaying();
        		}
        	});
        
        	dispatcher.on('controls.restart_play', function() {
        		if (!start_play) {
        			startPlaying();
        		}
        
        		setCurrentTime(played_from);
        	});
        
        	dispatcher.on('controls.play', startPlaying);
        	dispatcher.on('controls.pause', pausePlaying);
        
        	function startPlaying() {
        		// played_from = timeline.current_frame;
        		start_play = performance.now() - data.get('ui:currentTime').value * 1000;
        //		layer_panel.setControlStatus(true);
        		// dispatcher.fire('controls.status', true);
        	}
        
        	function pausePlaying() {
        		start_play = null;
        //		layer_panel.setControlStatus(false);
        		// dispatcher.fire('controls.status', false);
        	}
        
        	dispatcher.on('controls.stop', function() {
        		if (start_play !== null) pausePlaying();
        		setCurrentTime(0);
        	});
        
        	var currentTimeStore = data.get('ui:currentTime');
        	dispatcher.on('time.update', setCurrentTime);
        
        	dispatcher.on('update.scrollTime', function(v) {
        		v = Math.max(0, v);
        		data.get('ui:scrollTime').value = v;
        		repaintAll();
        	});
        
        	function setCurrentTime(value) {
        		value = Math.max(0, value);
        		currentTimeStore.value = value;
        
        		if (start_play) start_play = performance.now() - value * 1000;
        		repaintAll();
        		 layer_panel.repaint(s);
        	}
        
        	dispatcher.on('target.notify', function(name, value) {
        		if (target) target[name] = value;
        	});
        
        	dispatcher.on('update.scale', function(v) {
        		console.log('range', v);
        		data.get('ui:timeScale').value = v;
        
        		timeline.repaint();
        	});
        
    	//  Handle undo / redo.
        	dispatcher.on('controls.undo', function() {
        //		var history = undo_manager.undo();
        //		data.setJSONString(history.state);
        
        		updateState();
        	});
        
        	dispatcher.on('controls.redo', function() {
        //		var history = undo_manager.redo();
        //		data.setJSONString(history.state);
        
        		updateState();
        	});
        
    	/*
    		Paint Routines.
    	*/
        
        	function paint() {
        		requestAnimationFrame(paint);
        
        		if (start_play) {
        			var t = (performance.now() - start_play) / 1000;
        			setCurrentTime(t);
        
        
        			if (t > data.get("ui:totalTime").value) {
        				// simple loop
        				start_play = performance.now();
        			}
        		}
        
        		if (needsResize) {
        			div.style.width = width + "px";
        			div.style.height = height + "px";
        
        			restyle(layer_panel.dom, timeline.dom);
        
        			timeline.resize();
        			repaintAll();
        			needsResize = false;
        
        			dispatcher.fire("resize");
        		}
        
        		timeline._paint();
        	}
        
        	paint();
        
    	/*
    		End Paint Routines.
    	*/
        
        
        	function save(name) {
        		if (!name) name = 'autosave';
        
        		var json = data.getJSONString();
        
        		try {
        			localStorage[STORAGE_PREFIX + name] = json;
        			dispatcher.fire('save:done');
        		} catch (e) {
        			console.log('Cannot save', name, json);
        		}
        	}
        
        	function saveAs(name) {
        		if (!name) name = data.get('name').value;
        		name = prompt('Pick a name to save to (localStorage)', name);
        		if (name) {
        			data.data.name = name;
        			save(name);
        		}
        	}
        
        	function saveSimply() {
        		var name = data.get('name').value;
        		if (name) {
        			save(name);
        		} else {
        			saveAs(name);
        		}
        	}
        
        	function exportJSON() {
        		var json = data.getJSONString();
        		var ret = prompt('Hit OK to download otherwise Copy and Paste JSON', json);
        
        		console.log(JSON.stringify(data.data, null, '\t'));
        		if (!ret) return;
        
        		// make json downloadable
        		json = data.getJSONString('\t');
        		var fileName = 'timeliner-test' + '.json';
        
        		saveToFile(json, fileName);
        	}
        
        	function loadJSONString(o) {
        		// should catch and check errors here
        		var json = JSON.parse(o);
        		load(json);
        	}
        
        	function load(o) {
        		data.setJSON(o);
        		//
        		if (data.getValue('ui') === undefined) {
        			data.setValue('ui', {
        				currentTime: 0,
        				totalTime: Settings.default_length,
        				scrollTime: 0,
        				timeScale: Settings.time_scale
        			});
        		}
        
        //		undo_manager.clear();
        //		undo_manager.save(new UndoState(data, 'Loaded'), true);
        
        		updateState();
        	}
        
        	function updateState() {
        		layers = layer_store.value; // FIXME: support Arrays
        		layer_panel.setState(layer_store);
        		timeline.setState(layer_store);
        
        		repaintAll();
        	}
        
        	function repaintAll() {
        		var content_height = layers.length * Settings.LINE_HEIGHT;
        //		scrollbar.setLength(Settings.TIMELINE_SCROLL_HEIGHT / content_height);
        
        		layer_panel.repaint();
        		timeline.repaint();
        	}
        
        	function promptImport() {
        		var json = prompt('Paste JSON in here to Load');
        		if (!json) return;
        		console.log('Loading.. ', json);
        		loadJSONString(json);
        	}
        
        	function open(title) {
        		if (title) {
        			loadJSONString(localStorage[STORAGE_PREFIX + title]);
        		}
        	}
        
        	this.openLocalSave = open;
        
        	dispatcher.on('import', function() {
        		promptImport();
        	}.bind(this));
        
        	dispatcher.on('new', function() {
        		data.blank();
        		updateState();
        	});
        
        	dispatcher.on('openfile', function() {
        		openAs(function(data) {
        			// console.log('loaded ' + data);
        			loadJSONString(data);
        		}, div);
        	});
        
        	dispatcher.on('open', open);
        	dispatcher.on('export', exportJSON);
        
        	dispatcher.on('save', saveSimply);
        	dispatcher.on('save_as', saveAs);
        
    	//  Expose API.
        	this.save = save;
        	this.load = load;

    	/*
    		Start DOM Stuff (should separate file).
    	*/
        	var div = document.createElement('div');
        	div.style.cssText = 'position: absolute;';
        	div.style.top = '22px';
        
        	var pane = document.createElement('div');
        
        	style(pane, {
        		position: 'absolute',
        		top: '0px',
        		left: '0px',
        		margin: 0,
        		border: '0px solid ' + Theme.a,
        		padding: 0,
        		overflow: 'hidden',
        		backgroundColor: Theme.a,
        		color: Theme.d,
        		zIndex: Z_INDEX,
        		fontFamily: 'monospace',
        		fontSize: '12px'
        	});
        
        
        	var header_styles = {
        		position: 'absolute',
        		top: '0px',
        		width: '100%',
        		height: '22px',
        		lineHeight: '22px',
        		overflow: 'hidden'
        	};
        
        	var button_styles = {
        		width: '20px',
        		height: '20px',
        		padding: '2px',
        		marginRight: '2px'
        	};
        /*
        	var pane_title = document.createElement('div');
        	style(pane_title, header_styles, {
        		borderBottom: '1px solid ' + Theme.b,
        		textAlign: 'center'
        	});
        
        	var title_bar = document.createElement('span');
        	pane_title.appendChild(title_bar);
        
        	title_bar.innerHTML = 'Timeliner ' + package_json.version;
        	pane_title.appendChild(title_bar);
        
        	var top_right_bar = document.createElement('div');
        	style(top_right_bar, header_styles, {
        		textAlign: 'right'
        	});
        
        	pane_title.appendChild(top_right_bar);
        */
        
        /*
    	//  Resize minimize.
   	        var resize_small = new IconButton(10, 'resize_small', 'minimize', dispatcher);
            top_right_bar.appendChild(resize_small.dom);
        
    	//  Resize full.
        	var resize_full = new IconButton(10, 'resize_full', 'maximize', dispatcher);
        	style(resize_full.dom, button_styles, { marginRight: '2px' });
        	top_right_bar.appendChild(resize_full.dom);
        
        //	var pane_status = document.createElement('div');
        */
        
        	var footer_styles = {
        		position: 'absolute',
        		width: '100%',
        		height: '22px',
        		lineHeight: '22px',
        		bottom: '0',
        		// padding: '2px',
        		background: Theme.a,
        		fontSize: '11px'
        	};
        
        //	style(pane_status, footer_styles, {
        //		borderTop: '1px solid ' + Theme.b,
        //	});
        
        	pane.appendChild(div);
        //	pane.appendChild(pane_status);
        //	pane.appendChild(pane_title);
        
        //	var label_status = document.createElement('span');
        //	label_status.textContent = 'hello!';
        //	label_status.style.marginLeft = '10px';
        
        //	this.setStatus = function(text) {
        //		label_status.textContent = text;
        //	};
        
        	dispatcher.on('state:save', function(description) {
        		dispatcher.fire('status', description);
        		save('autosave');
        	});
        
        	dispatcher.on('status', this.setStatus);
        
        //	var bottom_right = document.createElement('div');
        //	style(bottom_right, footer_styles, {
        //		textAlign: 'right'
        //	});
        
        /*
            var button_save = document.createElement('button');
            style(button_save, button_styles);
            button_save.textContent = 'Save';
            button_save.onclick = function() {
                save();
            };
            
            var button_load = document.createElement('button');
            style(button_load, button_styles);
            button_load.textContent = 'Import';
            button_load.onclick = this.promptLoad;
            
            var button_open = document.createElement('button');
            style(button_open, button_styles);
            button_open.textContent = 'Open';
            button_open.onclick = this.promptOpen;
            
            
            bottom_right.appendChild(button_load);
            bottom_right.appendChild(button_save);
            bottom_right.appendChild(button_open);
            
            pane_status.appendChild(label_status);
            pane_status.appendChild(bottom_right);
        */
        
        /**/
        	
        /*
    	//  Zoom in.
        	var zoom_in = new IconButton(12, 'zoom_in', 'zoom in', dispatcher);
    	//  Zoom out.
        	var zoom_out = new IconButton(12, 'zoom_out', 'zoom out', dispatcher);
    	//  Settings.
        	var cog = new IconButton(12, 'cog', 'settings', dispatcher);
        
            bottom_right.appendChild(zoom_in.dom);
        	bottom_right.appendChild(zoom_out.dom);
       	    bottom_right.appendChild(cog.dom);
        
    	//  Add layer.
        	var plus = new IconButton(12, 'plus', 'New Layer', dispatcher);
        	plus.onClick(function() {
        		var name = prompt('Layer name?');
        		addLayer(name);
        
        		undo_manager.save(new UndoState(data, 'Layer added'));
        
        		repaintAll();
        	});
        	style(plus.dom, button_styles);
        	bottom_right.appendChild(plus.dom);
        
        
    	//  Trash.
        	var trash = new IconButton(12, 'trash', 'Delete save', dispatcher);
        	trash.onClick(function() {
        		var name = data.get('name').value;
        		if (name && localStorage[STORAGE_PREFIX + name]) {
        			var ok = confirm('Are you sure you wish to delete ' + name + '?');
        			if (ok) {
        				delete localStorage[STORAGE_PREFIX + name];
        				dispatcher.fire('status', name + ' deleted');
        				dispatcher.fire('save:done');
        			}
        		}
        	});
        	style(trash.dom, button_styles, { marginRight: '2px' });
        	bottom_right.appendChild(trash.dom);
        */
        
        
    	//  pane_status.appendChild(document.createTextNode(' | TODO <Dock Full | Dock Botton | Snap Window Edges | zoom in | zoom out | Settings | help>'));
        
    	/*
    			End DOM Stuff
    	*/
        
        	var ghostpane = document.createElement('div');
        	ghostpane.id = 'ghostpane';
        	style(ghostpane, {
        		background: '#999',
        		opacity: 0.2,
        //		position: 'absolute',
        		margin: 0,
        		padding: 0,
        		zIndex: (Z_INDEX - 1),
        		// transition: 'all 0.25s ease-in-out',
        		transitionProperty: 'top, left, width, height, opacity',
         		transitionDuration: '0.25s',
        		transitionTimingFunction: 'ease-in-out'
        	});
        
        
    	
        //  -------------------------------------------------------------
        //
        //  Handle DOM Views.
        //
	    //  ------------------------------------------------------------- 
        
    	//  Shadow Root.
        	var root = document.createElement('timeliner');
        	$("#time-container")[0].appendChild(root);
        	if (root.createShadowRoot) root = root.createShadowRoot();
        
        	window.r = root;
        
	    //  ------------------------------------------------------------- 
        
    	//  var iframe = document.createElement('iframe');
    	//  document.body.appendChild(iframe);
    	//  root = iframe.contentDocument.body;
        
        //	root.appendChild(pane);
        //	root.appendChild(ghostpane);
        
        //	div.appendChild(layer_panel.dom);
        
	    //  ------------------------------------------------------------- 
	    
        	root.appendChild(timeline.dom);
        
	    //  ------------------------------------------------------------- 
        
        //	var scrollbar = new ScrollBar(200, 10);
        //	div.appendChild(scrollbar.dom);
        
        
    	//  Percentages.
    	/*
        	scrollbar.onScroll.do(function(type, scrollTo) {
        		switch(type) {
        			case 'scrollto':
        				layer_panel.scrollTo(scrollTo);
        				timeline.scrollTo(scrollTo);
        				break;
        			case 'pageup':
        	 			scrollTop -= pageOffset;
        	 			me.draw();
        	 			me.updateScrollbar();
        	 			break;
        	 		case 'pagedown':
        	 			scrollTop += pageOffset;
        	 			me.draw();
        	 			me.updateScrollbar();
        	 			break;
        		}
        	});
        
        	 document.addEventListener('keypress', function(e) {
        	 	console.log('kp', e);
        	 });
        	 document.addEventListener('keyup', function(e) {
        	 	if (undo) console.log('UNDO');
        
        	 	console.log('kd', e);
        	 });
        
        //  TODO: Keyboard Shortcuts.
        //  Esc - Stop and review to last played from / to the start?
        //  Space - play / pause from current position.
        //  Enter - play all.
        //  k - keyframe.
        */
        	document.addEventListener('keydown', function(e) {
        		var play = e.keyCode == 32; // space
        		var enter = e.keyCode == 13; //
        		var undo = e.metaKey && e.keyCode == 91 && !e.shiftKey;
        
        		var active = document.activeElement;
        		// console.log( active.nodeName );
        
        		if (active.nodeName.match(/(INPUT|BUTTON|SELECT|TIMELINER)/)) {
        			active.blur();
        		}
        
        		if (play) {
        			dispatcher.fire('controls.toggle_play');
        		}
        		else if (enter) {
        			// FIXME: Return should play from the start or last played from?
        			dispatcher.fire('controls.restart_play');
        			// dispatcher.fire('controls.undo');
        		}
        		else if (e.keyCode == 27) {
        			// Esc = stop. FIXME: should rewind head to last played from or Last pointed from?
        			dispatcher.fire('controls.pause');
        		}
        		else console.log('keydown', e.keyCode);
        	});
        
        
        	var needsResize = true;
        
        	function resize(width, height) {
        		// data.get('ui:bounds').value = {
        		// 	width: width,
        		// 	height: height
        		// };
    		//  TODO: remove ugly hardcodes.
        		width -= 4;
        		height -= 44;
        
        		Settings.width = width - Settings.LEFT_PANE_WIDTH;
        		Settings.height = height;
        
        		Settings.TIMELINE_SCROLL_HEIGHT = height - Settings.MARKER_TRACK_HEIGHT;
        		var scrollable_height = Settings.TIMELINE_SCROLL_HEIGHT;
        
        //		scrollbar.setHeight(scrollable_height - 2);
        		// scrollbar.setThumb
        
        //		style(scrollbar.dom, {
        //			top: Settings.MARKER_TRACK_HEIGHT + 'px',
        //			left: (width - 16) + 'px',
        //		});
        
        		needsResize = true;
        	}
        
        	function restyle(left, right) {
        		left.style.cssText = 'position: absolute; left: 0px; top: 0px; height: ' + Settings.height + 'px;';
        		style(left, {
        			// background: Theme.a,
        			overflow: 'hidden'
        		});
        		left.style.width = Settings.LEFT_PANE_WIDTH + 'px';
        
        		// right.style.cssText = 'position: absolute; top: 0px;';
        		right.style.position = 'absolute';
        		right.style.top = '0px';
        		right.style.left = Settings.LEFT_PANE_WIDTH + 'px';
        	}
        
        	function addLayer(name) {
        		var layer = new LayerProp(name);
        
        		layers = layer_store.value;
        		layers.push(layer);
        
        //		layer_panel.setState(layer_store);
        	}
        
        	this.addLayer = addLayer;
        
        	this.setTarget = function(t) {
        		timeline = t;
        	};
        
        	function getValueRanges(ranges, interval) {
        		interval = interval ? interval : 0.15;
        		ranges = ranges ? ranges : 2;
        
    		//  Not optimized!
        		var t = data.get('ui:currentTime').value;
        
        		var values = [];
        
        		for (var u = -ranges; u <= ranges; u++) {
        			// if (u == 0) continue;
        			var o = {};
        
        			for (var l = 0; l < layers.length; l++) {
        				var layer = layers[l];
        				var m = timeAtLayer(layer, t + u * interval);
        				o[layer.name] = m.value;
        			}
        
        			values.push(o);
        
        		}
        
        		return values;
        	}
        
        	this.getValues = getValueRanges;
        
        
        	(function DockingWindow() {
        		"use strict";
        
    		//  Minimum resizable area.
        		var minWidth = 100;
        		var minHeight = 80;
        
    		//  Thresholds.
        		var FULLSCREEN_MARGINS = 2;
        		var SNAP_MARGINS = 8;
        		var MARGINS = 2;
        
    		//  End of what's configurable.
        
        		var clicked = null;
        		var onRightEdge, onBottomEdge, onLeftEdge, onTopEdge;
        
        		var preSnapped;
        
        		var b, x, y;
        
        		var redraw = false;
        
        		// var pane = document.getElementById('pane');
        		// var ghostpane = document.getElementById('ghostpane');
        
        		var mouseOnTitle = false;
        		var snapType;
            /*
        		pane_title.addEventListener('mouseover', function() {
        			mouseOnTitle = true;
        		});
        
        		pane_title.addEventListener('mouseout', function() {
        			mouseOnTitle = false;
        		});
        
        		resize_full.onClick(function() {
    			//  TOOD toggle back to restored size.
        			if (!preSnapped) preSnapped = {
        				width: b.width,
        				height: b.height
        			};
        
        			snapType = 'full-screen';
        			resizeEdges();
        		});
            
        		 pane_status.addEventListener('mouseover', function() {
        		 	mouseOnTitle = true;
        		 });
        
        		 pane_status.addEventListener('mouseout', function() {
        		 	mouseOnTitle = false;
        		 });
        */
        		window.addEventListener('resize', function() {
        			if (snapType)
        				resizeEdges();
        			else
        				needsResize = true;
        		});
        
    		//  Utilities.
        		function setBounds(element, x, y, w, h) {
        			element.style.left = x + 'px';
        			element.style.top = y + 'px';
        			element.style.width = w + 'px';
        			element.style.height = h + 'px';
        
        			if (element === pane) {
        				resize(w, h);
        			}
        		}
        
        		function hintHide() {
        			setBounds(ghostpane, b.left, b.top, b.width, b.height);
        			ghostpane.style.opacity = 0;
        		}
        
        		setBounds(pane, 0, 0, Settings.width, Settings.height);
        		setBounds(ghostpane, 0, 0, Settings.width, Settings.height);
        
    		//  Mouse events.
        		pane.addEventListener('mousedown', onMouseDown);
        		document.addEventListener('mousemove', onMove);
        		document.addEventListener('mouseup', onUp);
        
    		//  Touch events.
        		pane.addEventListener('touchstart', onTouchDown);
        		document.addEventListener('touchmove', onTouchMove);
        		document.addEventListener('touchend', onTouchEnd);
        
        
        		function onTouchDown(e) {
        			onDown(e.touches[0]);
        			e.preventDefault();
        		}
        
        		function onTouchMove(e) {
        			onMove(e.touches[0]);
        		}
        
        		function onTouchEnd(e) {
        			if (e.touches.length == 0) onUp(e.changedTouches[0]);
        		}
        
        		function onMouseDown(e) {
        			onDown(e);
        		}
        
        		function onDown(e) {
        			calc(e);
        
        			var isResizing = onRightEdge || onBottomEdge || onTopEdge || onLeftEdge;
        			var isMoving = !isResizing && canMove();
        
        			clicked = {
        				x: x,
        				y: y,
        				cx: e.clientX,
        				cy: e.clientY,
        				w: b.width,
        				h: b.height,
        				isResizing: isResizing,
        				isMoving: isMoving,
        				onTopEdge: onTopEdge,
        				onLeftEdge: onLeftEdge,
        				onRightEdge: onRightEdge,
        				onBottomEdge: onBottomEdge
        			};
        
        			if (isResizing || isMoving) {
        				e.preventDefault();
        				e.stopPropagation();
        			}
        		}
        
        		function canMove() {
        			return mouseOnTitle;
        			// return x > 0 && x < b.width && y > 0 && y < b.height
        			// && y < 18;
        		}
        
        		function calc(e) {
        			b = pane.getBoundingClientRect();
        			x = e.clientX - b.left;
        			y = e.clientY - b.top;
        
        			onTopEdge = y < MARGINS;
        			onLeftEdge = x < MARGINS;
        			onRightEdge = x >= b.width - MARGINS;
        			onBottomEdge = y >= b.height - MARGINS;
        		}
        
        		var e; // current mousemove event
        
        		function onMove(ee) {
        			e = ee;
        			calc(e);
        
        			redraw = true;
        		}
        
        		function animate() {
        
        			requestAnimationFrame(animate);
        
        			if (!redraw) return;
        
        			redraw = false;
        
        			if (clicked && clicked.isResizing) {
        
        				if (clicked.onRightEdge) pane.style.width = Math.max(x, minWidth) + 'px';
        				if (clicked.onBottomEdge) pane.style.height = Math.max(y, minHeight) + 'px';
        
        				if (clicked.onLeftEdge) {
        					var currentWidth = Math.max(clicked.cx - e.clientX  + clicked.w, minWidth);
        					if (currentWidth > minWidth) {
        						pane.style.width = currentWidth + 'px';
        						pane.style.left = e.clientX + 'px';
        					}
        				}
        
        				if (clicked.onTopEdge) {
        					var currentHeight = Math.max(clicked.cy - e.clientY  + clicked.h, minHeight);
        					if (currentHeight > minHeight) {
        						pane.style.height = currentHeight + 'px';
        						pane.style.top = e.clientY + 'px';
        					}
        				}
        
        				hintHide();
        
        				resize(b.width, b.height);
        
        				return;
        			}
        
        			if (clicked && clicked.isMoving) {
        
        				switch(checks()) {
        					case 'full-screen':
        						setBounds(ghostpane, 0, 0, window.innerWidth, window.innerHeight);
        						ghostpane.style.opacity = 0.2;
        						break;
        					case 'snap-top-edge':
        						setBounds(ghostpane, 0, 0, window.innerWidth, window.innerHeight / 2);
        						ghostpane.style.opacity = 0.2;
        						break;
        					case 'snap-left-edge':
        						setBounds(ghostpane, 0, 0, window.innerWidth / 2, window.innerHeight);
        						ghostpane.style.opacity = 0.2;
        						break;
        					case 'snap-right-edge':
        						setBounds(ghostpane, window.innerWidth / 2, 0, window.innerWidth / 2, window.innerHeight);
        						ghostpane.style.opacity = 0.2;
        						break;
        					case 'snap-bottom-edge':
        						setBounds(ghostpane, 0, window.innerHeight / 2, window.innerWidth, window.innerHeight / 2);
        						ghostpane.style.opacity = 0.2;
        						break;
        					default:
        						hintHide();
        				}
        
        				if (preSnapped) {
        					setBounds(pane,
        						e.clientX - preSnapped.width / 2,
        						e.clientY - Math.min(clicked.y, preSnapped.height),
        						preSnapped.width,
        						preSnapped.height
        					);
        					return;
        				}
        
    				//  Moving.
        				pane.style.top = (e.clientY - clicked.y) + 'px';
        				pane.style.left = (e.clientX - clicked.x) + 'px';
        
        				return;
        			}
        
    			//  This code executes when mouse moves without clicking.
        
    			//  Style cursor.
        			if (onRightEdge && onBottomEdge || onLeftEdge && onTopEdge) {
        				pane.style.cursor = 'nwse-resize';
        			} else if (onRightEdge && onTopEdge || onBottomEdge && onLeftEdge) {
        				pane.style.cursor = 'nesw-resize';
        			} else if (onRightEdge || onLeftEdge) {
        				pane.style.cursor = 'ew-resize';
        			} else if (onBottomEdge || onTopEdge) {
        				pane.style.cursor = 'ns-resize';
        			} else if (canMove()) {
        				pane.style.cursor = 'move';
        			} else {
        				pane.style.cursor = 'default';
        			}
        		}
        
        		function checks() {
    			/*
        			var rightScreenEdge, bottomScreenEdge;
        
        			rightScreenEdge = window.innerWidth - MARGINS;
        			bottomScreenEdge = window.innerHeight - MARGINS;
        
    			//  Edge Checkings.
        			// hintFull();
        			if (b.top < FULLSCREEN_MARGINS || b.left < FULLSCREEN_MARGINS || b.right > window.innerWidth - FULLSCREEN_MARGINS || b.bottom > window.innerHeight - FULLSCREEN_MARGINS)
        				return 'full-screen';
        
        			// hintTop();
        			if (b.top < MARGINS) return 'snap-top-edge';
        
        			// hintLeft();
        			if (b.left < MARGINS) return 'snap-left-edge';
        
        			// hintRight();
        			if (b.right > rightScreenEdge) return 'snap-right-edge';
        
        			// hintBottom();
        			if (b.bottom > bottomScreenEdge) return 'snap-bottom-edge';
    			*/
        
        			if (e.clientY < FULLSCREEN_MARGINS) return 'full-screen';
        
        			if (e.clientY < SNAP_MARGINS) return 'snap-top-edge';
        
        			// hintLeft();
        			if (e.clientX < SNAP_MARGINS) return 'snap-left-edge';
        
        			// hintRight();
        			if (window.innerWidth - e.clientX < SNAP_MARGINS) return 'snap-right-edge';
        
        			// hintBottom();
        			if (window.innerHeight- e.clientY < SNAP_MARGINS) return 'snap-bottom-edge';
        
        		}
        
        		animate();
        
        		function resizeEdges() {
        			switch(snapType) {
        				case 'full-screen':
        					// hintFull();
        					setBounds(pane, 0, 0, window.innerWidth, window.innerHeight);
        					break;
        				case 'snap-top-edge':
        					// hintTop();
        					setBounds(pane, 0, 0, window.innerWidth, window.innerHeight / 2);
        					break;
        				case 'snap-left-edge':
        					// hintLeft();
        					setBounds(pane, 0, 0, window.innerWidth / 2, window.innerHeight);
        					break;
        				case 'snap-right-edge':
        					setBounds(pane, window.innerWidth / 2, 0, window.innerWidth / 2, window.innerHeight);
        					break;
        				case 'snap-bottom-edge':
        					setBounds(pane, 0, window.innerHeight / 2, window.innerWidth, window.innerHeight / 2);
        					break;
        			}
        		}
        
        		function onUp(e) {
        			calc(e);
        
        			if (clicked && clicked.isMoving) {
    				//  Snap.
        				snapType = checks();
        				if (snapType) {
        					preSnapped = {
        						width: b.width,
        						height: b.height
        					};
        					resizeEdges();
        				} else {
        					preSnapped = null;
        				}
        
        				hintHide();
        
        			}
        
        			clicked = null;
        
        		}
        	})();
        
        }
        
        window.Timeliner = Timeliner;
    
    </script>
    
</head>
    
    
<body onload="animatorEditorRuntime();">

    <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-87777501-1', 'auto');
        ga('send', 'pageview');
        ga('set', 'userId', '{{googleAnalytics_userId}}'); // Set the user ID using signed-in user_id.
    </script>
    
    
    <div id="animation-editor" tabindex="-1">
    
        <div id="animator-render-container" tabindex="-1"></div>

        <div id="camera-measure-panel" style="display:none;">
            <div id="close-button" class="btn-close" onclick="hidePanel('camera-measure-panel');"></div><br>
            <li><strong>frame:&nbsp;</strong><span id="framer">value</span></li>
            <br>
            <li><strong>Camera Properties</strong>
                <ul>
                    <li>position&nbsp;x:<span id="cam-pos-x">value</span></li>
                    <li>position&nbsp;y:<span id="cam-pos-y">value</span></li>
                    <li>position&nbsp;z:<span id="cam-pos-z">value</span></li>
                    <br>
                    <li>rotation&nbsp;x:<span id="cam-rot-x">value</span></li>
                    <li>rotation&nbsp;y:<span id="cam-rot-y">value</span></li>
                    <li>rotation&nbsp;z:<span id="cam-rot-z">value</span></li>
                    <br>
                    <li>quaternion&nbsp;w:<span id="cam-quat-w">value</span></li>
                    <li>quaternion&nbsp;x:<span id="cam-quat-x">value</span></li>
                    <li>quaternion&nbsp;y:<span id="cam-quat-y">value</span></li>
                    <li>quaternion&nbsp;z:<span id="cam-quat-z">value</span></li>
                    <br>
                    <li>far:&nbsp;<span id="cam-far">value</span></li>
                    <li>fov:&nbsp;<span id="cam-fov">value</span></li>
                </ul>
            </li>
            <br>
            <li><strong>Mouse Properties</strong>
                <ul>
                    <li>screen&nbsp;x:<span id="mouse-x">value</span></li>
                    <li>screen&nbsp;y:<span id="mouse-y">value</span></li>
                </ul>
            </li>
        </div>

        <div id="animator-container" tabindex="-1">
            <label for="slider-timer" id="label-timer"><strong>time:</strong></label>
            <div id="timer-container">
                <input type="range" min="0" max="3" value="0" class="timerslider" id="slider-timer" step="0.01"> <!-- onmousedown="staticSliderPressed('timer', true);" onmouseup="staticSliderPressed('timer', false);" -->
            </div>
            <div id="time-container" tabindex="-1"></div>
            <div id="keys-container" tabindex="-1"></div>
            <strong><output for="slider-timer" class="timeroutput" id="output-timer">0</output></strong>
            <div id="animation-buttons">
                <a href="#" id="animation-play" class="button">Play</a> <!-- onclick="playAnimation(avatar);" -->
                <a href="#" id="animation-add" class="button">Add Key</a> <!-- onclick="insertNewAnimateDataTimeFrameKey();" -->
            </div>
            <a href="#" id="delete-framekey" class="button">Delete</a> <!-- onclick="deleteCurrentAnimationDataKey();" -->
            <input type="checkbox" id="manual-play" name="manual" checked>
            <div id="status-msgr">Status messager</div>
        </div>
        
        <div id="left-side">
            <div id="left-side-pinbtn"></div>
            <div id="left-side-content">
            
                <div id="what-to-do" tabindex="-1">
                    <div class="btn-close" onclick="hidePanel('what-to-do');"></div>
                    <h3>What to do</h3><br>
                    <ol>
                        <li>
                            Drag <span style="color:orange;">time slider</span> on buttom of page to set keyframe time possition
                            and press <span style="color:orange;"><b>"Add Key"</b></span><br>button to insert a new keyframe.
                        </li>
                        <li>
                            Open <span style="color:orange;">animator control panel</span> on right of page and select a bone
                            in <span style="color:aqua;"><b>"Selected Bone"</b></span> droplist.<br>
                            Adjust position, rotation or scale using the control sliders.
                            Repeat for as many bones you like.
                        </li>
                        <li>
                            When you are ready, press <span style="color:aqua;"><b>"Play"</b></span> button on bottom left of page.<br><br>
                            <span style="color:gold;"><b>MannyTheSkeleton</b></span> salute you. Enjoy.<br><br>
                        </li>
                    </ol>
                </div>
                
                <div id="animation-importer">
                    <label for="load-data"><strong>Import Animation:&nbsp;</strong></label><br>
                    <input type="file" id="load-data" class="upload" name="loaddata" onchange="importAnimationDataFromJSON();">
                </div>

                <div id="poser-importer">
                    <label for="load-pose"><strong>Import Pose:&nbsp;</strong></label><br>
                    <input type="file" id="load-pose" class="upload" name="loadpose" onchange="importAnimationPoseKeyFromJSON();">
                </div>

                <div id="test-importer">
                    <label for="load-test"><strong>Test Import JSON:&nbsp;</strong></label><br>
                    <input type="file" id="load-test" class="upload" name="loadtest" onchange="importObjectFromJSONfile();">
                </div>
            </div>
        </div>
        
    <!-- Beginning of right side control panel -->
        
        <div id="right-side">
            <div id="right-side-pinbtn"></div>
            <div id="right-side-content"> <!-- onmouseover="controls.enabled=false;" onmouseout="controls.enabled=true;" -->

                <div id="dims-label"><strong>Bone <span id="dims-label-selected-name"></span> Animator</strong></div>
                
                <label for="droplist-bones" id="droplist-label"><strong>Selected Bone:</strong></label>
                
                <select id="droplist-bones" name="BONES" size="1" style="" onchange="newCurrentBoneSelected();">
                    <option value="Armature" selected>Armature</option>
                    <option value="Head">Head</option>
                    <option value="Neck">Neck</option>
                    <option value="Torso">Torso</option>
                    <option value="Hip">Hip</option>
                    <option value="Arms">Arms</option>
                    <option value="Legs">Legs</option>
                </select>

                <div class="dimsadjust" id="position-div">
                    <div class="slider-row">
                        <label for="slider-pos-x">Position <strong>X-axis:</strong></label>
                        <input type="range" min="-9999" max="9999" value="0" class="dimslider" id="slider-pos-x" step="1" onmousedown="dynamicSliderPressed('pos-x', true, 0);" onmouseup="dynamicSliderPressed('pos-x', false, 0);">
                        <strong><output for="slider-pos-x" class="dimoutput" id="output-pos-x">-9999</output></strong>
                    </div>
                    <div class="slider-row">
                        <label for="slider-pos-y">Position <strong>Y-axis:</strong></label>
                        <input type="range" min="-9999" max="9999" value="0" class="dimslider" id="slider-pos-y" step="1" onmousedown="dynamicSliderPressed('pos-y', true, 0);" onmouseup="dynamicSliderPressed('pos-y', false, 0);">
                        <strong><output for="slider-pos-y" class="dimoutput" id="output-pos-y">-9999</output></strong>
                    </div>
                    <div class="slider-row">
                        <label for="slider-pos-z">Position <strong>Z-axis:</strong></label>
                        <input type="range" min="-9999" max="9999" value="0" class="dimslider" id="slider-pos-z" step="1" onmousedown="dynamicSliderPressed('pos-z', true, 0);" onmouseup="dynamicSliderPressed('pos-z', false, 0);">
                        <strong><output for="slider-pos-z" class="dimoutput" id="output-pos-z">-9999</output></strong>
                    </div>
                        <strong> <a href="#"><span id="reset-position" onclick="bonesResetPosition(avatar);">Reset bones position</span></a></strong>
                    
                </div>
                

                <div class="dimsadjust" id="rotation-div">
                    <div class="slider-row">
                        <label for="slider-rot-x">Rotation <strong>X-axis:</strong></label>
                        <input type="range" min="-180" max="180" value="0" class="dimslider" id="slider-rot-x" step="1" onmousedown="staticSliderPressed('rot-x', true);" onmouseup="staticSliderPressed('rot-x', false);">
                        <strong><output for="slider-rot-x" class="dimoutput" id="output-rot-x">-180</output></strong>
                    </div>
                    <div class="slider-row">
                        <label for="slider-rot-y">Rotation <strong>Y-axis:</strong></label>
                        <input type="range" min="-180" max="180" value="0" class="dimslider" id="slider-rot-y" step="1" onmousedown="staticSliderPressed('rot-y', true);" onmouseup="staticSliderPressed('rot-y', false);">
                        <strong><output for="slider-rot-y" class="dimoutput" id="output-rot-y">-180</output></strong>
                    </div>
                    <div class="slider-row">
                        <label for="slider-rot-z">Rotation <strong>Z-axis:</strong></label>
                        <input type="range" min="-180" max="180" value="0" class="dimslider" id="slider-rot-z" step="1" onmousedown="staticSliderPressed('rot-z', true);" onmouseup="staticSliderPressed('rot-z', false);">
                        <strong><output for="slider-rot-z" class="dimoutput" id="output-rot-z">-180</output></strong>
                    </div>
                    <span id="finetune-text">Rotation Fine Tune</span>
                    <strong id="finetune">
                        <a href="#"><span id="finetune-down" onclick="void(0);">&#9668;</span></a>
                        <a href="#"><span id="finetune-up" onclick="void(0);">&#9658;</span></a>                        
                    </strong>
                    <strong><a href="#"><span id="reset-rotation" onclick="bonesResetQuaternion(avatar);">Reset bones rotation</span></a></strong>
                </div>

                <div class="dimsadjust" id="scale-uniform-div">
                    <div class="slider-row">
                        <label for="slider-scale-uniform" id="label-scale-uniform">Scale <strong>XYZ-axes:</strong></label>
                        <input type="range" min="1" max="400" value="1" class="sclslider" id="slider-scale-uniform" step="1" onmousedown="dynamicSliderPressed('scale-uniform', true, 1);" onmouseup="dynamicSliderPressed('scale-uniform', false, 1);">
                        <strong><output for="slider-scale-uniform" class="dimoutput" id="output-scale-uniform">100</output></strong>
                    </div>
                    <strong><a href="#"><span id="reset-scale" onclick="bonesResetScale(avatar);">Reset bones scale</span></a></strong>
                </div>

                <div class="dimsadjust" id="scale-div">
                    <div class="slider-row">
                        <label for="slider-scl-x">Scale <strong>X-axis:</strong></label>
                        <input type="range" min="1" max="400" value="1" class="sclslider" id="slider-scl-x" step="1" onmousedown="dynamicSliderPressed('scl-x', true, 1);" onmouseup="dynamicSliderPressed('scl-x', false, 1);">
                        <strong><output for="slider-scl-x" class="dimoutput" id="output-scl-x">100</output></strong>
                    </div>
                    <div class="slider-row">
                        <label for="slider-scl-y">Scale <strong>Y-axis:</strong></label>
                        <input type="range" min="1" max="400" value="1" class="sclslider" id="slider-scl-y" step="1" onmousedown="dynamicSliderPressed('scl-y', true, 1);" onmouseup="dynamicSliderPressed('scl-y', false, 1);">
                        <strong><output for="slider-scl-y" class="dimoutput" id="output-scl-y">100</output></strong>
                    </div>
                    <div class="slider-row">
                        <label for="slider-scl-z">Scale <strong>Z-axis:</strong></label>
                        <input type="range" min="1" max="400" value="1" class="sclslider" id="slider-scl-z" step="1" onmousedown="dynamicSliderPressed('scl-z', true, 1);" onmouseup="dynamicSliderPressed('scl-z', false, 1);">
                        <strong><output for="slider-scl-z" class="dimoutput" id="output-scl-z">100</output></strong>
                    </div>
                    <strong>
                        <a href="#"><span id="avatar-helper" onclick="showhideHelper(avatar);">Show/Hide Avatar</span></a>
                        <a href="#"><span id="bones-helper" onclick="showhideHelper(armatureHelper);">Show/Hide Bones</span></a>
                        <a href="#"><span id="reset-pose" onclick="avatarRestPose(avatar);">Avatar Rest Pose</span></a>
                    </strong>
                </div>

                <div class="dimsadjust" id="animation-div">
                    <div class="slider-row">
                        <label for="slider-dur"><strong>Duration (sec):</strong></label>
                        <input type="range" min="-100" max="100" value="0" class="durslider" id="slider-dur" step="1" onmousedown="dynamicSliderPressed('dur', true, 0);" onmouseup="dynamicSliderPressed('dur', false, 0);">
                        <strong><output for="slider-dur" class="dimoutput" id="output-dur">2</output></strong>
                    </div>
                    <div class="slider-row">
                        <label for="slider-timescale"><strong>Time Speed(x):</strong></label>
                        <input type="range" min="0" max="2" value="1" class="durslider" id="slider-timescale" step="0.1" oninput="outputUpdate('output-timescale', value);">
                        <strong><output for="slider-timescale" class="dimoutput" id="output-timescale">1</output></strong>
                    </div>
                    <div class="slider-row">
                        <label for="slider-fps"><strong>Animation fps:</strong></label>
                        <input type="range" min="0" max="60" value="30" class="durslider" id="slider-fps" step="1" oninput="outputUpdate('output-fps', value);">
                        <strong><output for="slider-fps" class="dimoutput" id="output-fps">30</output></strong>
                    </div>
                    <div class="slider-row">
                        <label for="animation-name"><strong>Animation Name:&nbsp;&nbsp;</strong></label>
                        <input type="text" class="dimoutput" id="animation-name" name="animation" maxLength="128" placeholder="animation name (required)" value="new animation" required="true" onchange="submitAnimationName();">
                    </div>
                    <div class="slider-row">
                        <label for="load-skinned"><strong>Load&nbsp;Skinned&nbsp;Mesh:&nbsp;</strong></label>
                        <input type="file" id="load-skinned" class="button" name="loadskinned" onchange="loadJsonSkinnedAnimatedMesh(event);">
                        <div id="looper">
                            <label for="animation-loop"><strong>Loop&nbsp;</strong></label>
                            <input type="checkbox" id="animation-loop" name="loop" checked="true">
                        </div>
                    </div>
                    <div id="export-buttons">
                        <a href="#" id="export-data" class="button" onclick="saveJSONtoFile( exportAnimationDataAsJSON() );">Export JSON</a>
                        <a href="#" id="export-pose" class="button" onclick="saveJSONtoFile( exportAnimationPoseAsJSON() );">Export Pose</a>
                        <a href="#" id="export-batch" class="button" onclick="void(0);">Batch...</a>
                        <a href="#" id="crazy-pose" class="button" onmousedown="staticSliderPressed('timer', true);" onmouseup="staticSliderPressed('timer', false);" onclick="currentCrazyPosesScript();">Random Pose</a>
                    </div>                    
                </div>

            </div>
        </div>  
        
    <!-- End of right side control panel -->

    </div>

    <script>
        window.debugMode = true;
        rightSidePinBtn = $("#right-side-pinbtn")[0];
        leftSidePinBtn = $("#left-side-pinbtn")[0];
        
        rightSidePinBtn.pinned = false;
        rightSidePinBtn.onclick = function(){ 
            this.pinned = !this.pinned; 
            this.classList.toggle( "pinned", this.pinned );
        	this.parentElement.classList.toggle( "pinned", this.pinned );
        };
        leftSidePinBtn.pinned = false;
        leftSidePinBtn.onclick = function(){ 
            this.pinned = !this.pinned; 
            this.classList.toggle( "pinned", this.pinned );
        	this.parentElement.classList.toggle( "pinned", this.pinned );
        };
        
        var HtmlCollection = document.all;
        for (var i=0; i < HtmlCollection.length; i++) {
            HtmlCollection[i].tabindex = -1;
        }
        
        function hidePanel( id ){
            $("#" + id)[0].style.display = "none";
        }
        
        function showPanel( id ){
            $("#" + id)[0].style.display = "";
        }
    </script>

    <script>
        
    //  Simple add event.
        
        function addEventSimple(obj,evt,fn) {
        	if (obj.addEventListener)
        		obj.addEventListener(evt,fn,false);
        	else if (obj.attachEvent)
        		obj.attachEvent('on'+evt,fn);
        }
        
        function removeEventSimple(obj,evt,fn) {
        	if (obj.removeEventListener)
        		obj.removeEventListener(evt,fn,false);
        	else if (obj.detachEvent)
        		obj.detachEvent('on'+evt,fn);
        }
        
        
    //  Key drag&drop object.
        keyDragDrop = {
        	keyHTML: "<a href='#' class='keyLink'></a>",
        	keySpeed: 1, // pixels per keypress event
        	initialMouseX: undefined,
        	initialMouseY: undefined,
        	startX: undefined,
        	startY: undefined,
        	dXKeys: undefined,
        	dYKeys: undefined,
        	draggedObject: undefined,
        	
        	initElement: function (element) {
        		if (typeof element == "string")
        			element = document.getElementById(element);
        		element.onmousedown = keyDragDrop.startDragMouse;
        		element.innerHTML += keyDragDrop.keyHTML;
        		var links = element.getElementsByTagName("a");
        		var lastLink = links[links.length-1];
        		lastLink.relatedElement = element;
        		lastLink.onclick = keyDragDrop.startDragKeys;
        	},
        	startDragMouse: function (e) {
        		keyDragDrop.startDrag(this);
        		var evt = e || window.event;
        		keyDragDrop.initialMouseX = evt.clientX;
        		keyDragDrop.initialMouseY = evt.clientY;
        		addEventSimple(document,"mousemove",keyDragDrop.dragMouse);
        		addEventSimple(document,"mouseup",keyDragDrop.releaseElement);
        		return false;
        	},
        	startDragKeys: function () {
        		keyDragDrop.startDrag(this.relatedElement);
        		keyDragDrop.dXKeys = keyDragDrop.dYKeys = 0;
        		addEventSimple(document,"keydown",keyDragDrop.dragKeys);
        		addEventSimple(document,"keypress",keyDragDrop.switchKeyEvents);
        		this.blur();
        		return false;
        	},
        	startDrag: function (obj) {
        		if (keyDragDrop.draggedObject)
        			keyDragDrop.releaseElement();
        		keyDragDrop.startX = obj.offsetLeft;
        		keyDragDrop.startY = obj.offsetTop;
        		keyDragDrop.draggedObject = obj;
        		obj.className = "dragged";
        	},
        	dragMouse: function (e) {
        		var evt = e || window.event;
        		var dX = evt.clientX - keyDragDrop.initialMouseX;
        		var dY = evt.clientY - keyDragDrop.initialMouseY;
        		keyDragDrop.setPosition(dX,dY);
        		return false;
        	},
        	dragKeys: function(e) {
        		var evt = e || window.event;
        		var key = evt.keyCode;
        		switch (key) {
        			case 37:	// left
        			case 63234:
        				keyDragDrop.dXKeys -= keyDragDrop.keySpeed;
        				break;
        			case 38:	// up
        			case 63232:
        				keyDragDrop.dYKeys -= keyDragDrop.keySpeed;
        				break;
        			case 39:	// right
        			case 63235:
        				keyDragDrop.dXKeys += keyDragDrop.keySpeed;
        				break;
        			case 40:	// down
        			case 63233:
        				keyDragDrop.dYKeys += keyDragDrop.keySpeed;
        				break;
        			case 13: 	// enter
        			case 27: 	// escape
        				keyDragDrop.releaseElement();
        				return false;
        			default:
        				return true;
        		}
        		keyDragDrop.setPosition(keyDragDrop.dXKeys,keyDragDrop.dYKeys);
        		if (evt.preventDefault)
        			evt.preventDefault();
        		return false;
        	},
        	setPosition: function (dx,dy) {
        	    if ( keyDragDrop.startX + dx > 0 && keyDragDrop.startX + dx < document.getElementById("keys-container").offsetWidth - keyDragDrop.draggedObject.offsetWidth){
        	        var x = (keyDragDrop.startX + dx) / (document.getElementById("keys-container").offsetWidth - keyDragDrop.draggedObject.offsetWidth);
        	        
        	        if (x < 0) {
                        x = 0;
                    }
        	        else if (x > document.getElementById("keys-container").offsetWidth - keyDragDrop.draggedObject.offsetWidth) {
                        x = 1;
                    }
                    
                 // Round x to second fractal digit;
                    x = 100 * Math.round(x * 10000)/10000;
                 
                    keyDragDrop.draggedObject.style.left = x + "%";
           		}
        		//  keyDragDrop.draggedObject.style.top = keyDragDrop.startY + dy + 'px';
        	},
        	switchKeyEvents: function () {
    		// for Opera and Safari 1.3
        		removeEventSimple(document,'keydown',keyDragDrop.dragKeys);
        		removeEventSimple(document,'keypress',keyDragDrop.switchKeyEvents);
        		addEventSimple(document,'keypress',keyDragDrop.dragKeys);
        	},
        	releaseElement: function() {
        		removeEventSimple(document,'mousemove',keyDragDrop.dragMouse);
        		removeEventSimple(document,'mouseup',keyDragDrop.releaseElement);
        		removeEventSimple(document,'keypress',keyDragDrop.dragKeys);
        		removeEventSimple(document,'keypress',keyDragDrop.switchKeyEvents);
        		removeEventSimple(document,'keydown',keyDragDrop.dragKeys);
        		keyDragDrop.draggedObject.className = keyDragDrop.draggedObject.className.replace(/dragged/, "keymark");
        		keyDragDrop.draggedObject = undefined;
        	}
        }

    </script>
    
    
    
    
    
    
    <script>

        function importObjectFromJSONfile(){
            console.log("Importing data object from JSON file.");
            
        //  JSON TEXT CONTENTS READER.
            var reader = new FileReader();
            
        //  FileList object.
            var file = event.target.files[0];
            var filename = file.name;
            var extension = filename.split( '.' ).pop().toLowerCase();
            var name = filename.split( '.' )[0];
            
            console.log("file:", file);
            console.log("filename:", filename);
    		console.log("extension:", extension);
    		console.log("name:", name);

        //  Read json file as a text string.
            reader.readAsText(file);
            
        //  When reading competed...
            var contents, dataObject;
            reader.onloadend = function( event ){
                contents = event.target.result;
                console.log("JSON contents readed as text string.", contents);
                dataObject = JSON.parse( contents );
                console.log("JSON contents parsed as data:", dataObject);
            //  ...............................................................  //
            //                                                                   //
            //          Add code what to do with json data here.                 //
            //                                                                   //
            //  ...............................................................  //
                console.log("Importing json object from JSON file completed.");
            };
        }
        
        
        
        function importAnimationDataFromJSON(){
            console.log("Importing animation data object from JSON file.");
            var inputfile = document.getElementById("load-data");
            
       //  JSON TEXT CONTENTS READER.
            var reader = new FileReader();
            
        //  FileList object.
            var file = event.target.files[0];
            var filename = file.name;
            var extension = filename.split( '.' ).pop().toLowerCase();
            var name = filename.split( '.' )[0];
            
        //  Read json file as a text string.
            reader.readAsText(file);
            
        //  When reading competed...
            var contents, dataObject;
            reader.onloadend = function( event ){
                contents = event.target.result;
                dataObject = JSON.parse( contents );
				console.log("animation dataObject:", dataObject);
				
            //  Replace the animation.
                THREE.AnimationHandler.animations = [];
                animation = new THREE.Animation( avatar, dataObject );
                animation.currentTime = 0;
                durOutput.value = animation.data.length;
                animtimerSlider.max = animation.data.length;
                timescaleSlider.value = 0;
                nameAnimField.value = animation.data.name;
                // animation.isPlaying = true;
                animation.play(0);
                playButton.innerHTML = "Play";
            //
                console.log("Animation created:", animation);
            };
        }
        
        
        
        function importAnimationPoseKeyFromJSON(){
            console.log("Importing animation pose keys from JSON file.");
            var inputfile = document.getElementById("load-pose");
            
        //  JSON TEXT CONTENTS READER.
            var reader = new FileReader();
            
        //  FileList object.
            var file = event.target.files[0];
            var filename = file.name;
    		var extension = filename.split( '.' ).pop().toLowerCase();
    		var name = filename.split( '.' )[0];
    		
    		console.log("file:", file);
    		console.log("filename:", filename);
    		console.log("extension:", extension);
    		console.log("name:", name);
            
//      1. First we read json file as text.

        //  Read json file as a text string.
            reader.readAsText(file);
            
        //  When reading competed...
            reader.onloadend = function(event){
                //console.log(event.target.result);
                var contents = event.target.result;
            //  Pose Json data for pose animation collection input.
                var PoseJsonData = event.target.result;
                //console.log("contents:", contents);
                console.log("json contents readed as text string.");
                
//      2. Then we parse json string as json data with JSON parser.
            //  Parse json contents string as json data.
                var poseArray = JSON.parse( contents );
                console.log("json contents parsed as poseArray:", poseArray);

				bcaFrameKeyIndexesArray( animtimerSlider.value );
				if (animationDataKeyExist){
    			//  Replace key if exist.
                    for (var i in poseArray){
                        animation.data.hierarchy[i].keys[currentAnimationKeyIndex].pos = poseArray[i].pos;
                        animation.data.hierarchy[i].keys[currentAnimationKeyIndex].rot.fromArray(poseArray[i].rot);
                        animation.data.hierarchy[i].keys[currentAnimationKeyIndex].scl = poseArray[i].scl;
                    }
                    console.log("Animation pose key", currentAnimationKeyIndex, "replaced at", animtimerSlider.value, "sec.", animation.data.hierarchy);
    			}
    			else if (!animationDataKeyExist) {
    			//  Insert key if not exists.
                    var b = bcaAnimationDataIndexKeys[0];
                    var c = bcaAnimationDataIndexKeys[1];
                    var a = bcaAnimationDataIndexKeys[2];
                    if ( b &&  a ) { idx = b; spl = a; }          // splice to next key index.
                    else if (!b &&  a) { idx = 0; spl = a; }      // splice to next key index.
                    else if ( b && !a) { idx = b; spl = b + 1; }  // push to end of keys array.
                    else if (!b && !a) { idx = 0; spl = 0; }      // keys array is empty. unshift to beginning of keys array.
                    
                    for (var i in animation.data.hierarchy){
                        var newKey = {"index":spl, "pos":[], "rot":new THREE.Quaternion(), "scl":[], "time":Number(animtimerSlider.value)};
                        newKey.pos = poseArray[i].pos;
                        newKey.rot.fromArray(poseArray[i].rot);
                        newKey.scl = poseArray[i].scl;
                    //  Add new key in animation data hierarchy keys array.
                        if (spl < animation.data.hierarchy[i].keys.length) 
                            animation.data.hierarchy[i].keys.splice(spl, 0, newKey);      // add new key before the after key.
                        else animation.data.hierarchy[i].keys.push(newKey);               // add new key at end of keys array.
                    //  Ensure keys indexing.
                        for (var j in animation.data.hierarchy[i].keys){
                            animation.data.hierarchy[i].keys[j].index = Number(j);
                        }
                    }
                    console.log("New animation data key imported at", animtimerSlider.value, "sec.", animation.data.hierarchy);
                }
                ensureLooping();
                ensureKeysIndexing();
                bcaFrameKeyIndexesArray( animtimerSlider.value );
                console.log("Animation pose key completed.");
                
                animation.isPlaying = true;
                timescaleSlider.value = 0;
                animation.play( animation.currentTime );
                playButton.innerHTML = "Play";
                
            //  Update bca indexes to get the new currentAnimationKeyIndex.
                bcaFrameKeyIndexesArray( animtimerSlider.value );
            //  Get currentAnimationKeyIndex and then define currentAnimationKeyObject.
                newCurrentBoneSelected();
            };
        }
        
        
        
        function exportAnimationDataAsJSON(){
            console.log("Exporting animation data as JSON.");
            ensureLooping();
            ensureKeysIndexing();
            bcaFrameKeyIndexesArray( animtimerSlider.value );
            
            var jsonExport;
            if (animationDataKeyExist) {
                var dataExport = {"name":"", "fps":0, "length":0, "hierarchy":[]}
                dataExport.name = animation.data.name;
                dataExport.fps = animation.data.fps;
                dataExport.length = animation.data.length;
                
                for (var i in animation.data.hierarchy){
                    var keysExport = {keys:[]}
                    for (var j in animation.data.hierarchy[i].keys){
                        var key = {"pos":[], "rot":[], "scl":[], "time":0};
                        key.pos = animation.data.hierarchy[i].keys[j].pos;
                        key.rot = animation.data.hierarchy[i].keys[j].rot.toArray();
                        key.scl = animation.data.hierarchy[i].keys[j].scl;
                        key.time = animation.data.hierarchy[i].keys[j].time;
                        keysExport.keys.push(key);
                    }
                    dataExport.hierarchy.push(keysExport);
                }
                console.log(dataExport);
            //
                jsonExport = JSON.stringify(dataExport);
                console.log(jsonExport);
            //
                alert("Animation data exported succesfully.");
            }
            else {
                var a = "Current animation data key does not exists.";
                var b = "You can not export animation data.";
                console.log(a, b, "\n" + jsonExport, "returned.");
                alert(a + "\n" + b);
            }
            return jsonExport;
        }
        
        
        
        function exportAnimationPoseAsJSON(){
            console.log("Exporting animation key Pose as JSON.");
            var poseExport = [];
            for (var i in animation.hierarchy) {
            //  Create a new animation data key with current time bones values.
            //  var poseKey = {"index":0, "pos":[], "rot":[], "scl":[], "time":0};
                var poseKey = {"pos":[], "rot":[], "scl":[]};
            //  Get bones values at current time from animation.hierarchy.
                poseKey.pos = animation.hierarchy[i].position.toArray();
                poseKey.rot = (animation.hierarchy[i].quaternion).toArray();
                poseKey.scl = animation.hierarchy[i].scale.toArray();
                poseExport.push(poseKey);
            }
            poseExport = JSON.stringify(poseExport);
            console.log(poseExport);
            alert("Animation pose exported succesfully.");
            return poseExport;
        }
        
        
        
        function exportAnimationExistedKeyPoseAsJSON(keyIdx){
            console.log("Exporting animation existed key Pose as JSON.");
            // ensureLooping();
            ensureKeysIndexing();
            bcaFrameKeyIndexesArray( animtimerSlider.value );
            
            if (animationDataKeyExist) {
                var poseExport = [];
                for (var i in animation.data.hierarchy){
                //  poseExport.push(animation.data.hierarchy[i].keys[currentAnimationKeyIndex])
                    var poseKey = {"pos":[], "rot":[], "scl":[]};
                //  Get bones values at current time from animation.data.hierarchy.
                    poseKey.pos = animation.data.hierarchy[i].keys[keyIdx].pos;
                    poseKey.rot = animation.data.hierarchy[i].keys[keyIdx].rot.toArray();
                    poseKey.scl = animation.data.hierarchy[i].keys[keyIdx].scl;
                    poseExport.push(poseKey);
                }
                poseExport = JSON.stringify(poseExport);
                console.log(poseExport);
                return poseExport;
            }
            else if (!animationDataKeyExist) {
                console.log("Current animation data key does not exists.", "You can not export animation pose keys.");
                return undefined;
            }
        }
        
        
        function saveJSONtoFile(jsonData){
            if (jsonData){
                var blob = new Blob([jsonData], {type: "application/json"});
                var url  = URL.createObjectURL(blob);
                var a = document.createElement("a");
                
                a.download = "exported json.txt";
                a.href = url;
                a.onclick = destroyClickedElement;
                a.style.display = "none";
                document.body.appendChild(a);
                a.click();
            }
        }
        
        
        function destroyClickedElement(event) {
        	document.body.removeChild(event.target);
        }
        
        

    </script>
        
        
        
    <script>
        
    //  Current slider and bone.
        currentSliderStatus = false;            // boolean
        currentSpeed = 1;                       // number slider value
        currentSlider = undefined;              // slider element
        currentOutput = undefined;              // output element
        currentBoneIndex = undefined;           // number for animation.hierarchy[currentBoneIndex]
        currentBone = undefined;                // object animation.hierarchy[currentBoneIndex]
        currentDataBone = undefined;            // object animation.data.hierarchy[currentBoneIndex]
        currentAnimationKeyIndex = undefined;   // number for animation.data.hierarchy[currentBoneIndex].keys[currentAnimationKeyIndex]
        currentAnimationKeyObject = undefined;  // object animation.data.hierarchy[currentBoneIndex].keys[currentAnimationKeyIndex]
        currentFrameTime = undefined;           // number Number( document.getElementById("slider-timer").value )
        animationDataKeyExist = false;          // boolean
        bcaAnimationDataIndexKeys = [undefined, undefined, undefined];
        
    //  Define an empty script for random pose generator button.
        function currentCrazyPosesScript(){};   // script for random pose generator.
    //  How it is works: When we change avatar from Animator-Avatars menu, we parse also the assocciated random poses function in currentCrazyPosesScript function.
    //  When we click the Random Pose button we call the currentCrazyPosesScript() function that is the assocciated random poses function for the selected avatar.
    //  Do not forget that it is important to parse the assocciated random pose avatar function in menu Animator-Avatars-[the selected avatar] menu item.
        
        
        bonesDroplist = document.getElementById("droplist-bones");
        
    //  Position sliders.
        posSliderX = document.getElementById("slider-pos-x");
        posSliderY = document.getElementById("slider-pos-y");
        posSliderZ = document.getElementById("slider-pos-z");
        posOutputX = document.getElementById("output-pos-x");
        posOutputY = document.getElementById("output-pos-y");
        posOutputZ = document.getElementById("output-pos-z");
        
    //  Rotation sliders.
        rotSliderX = document.getElementById("slider-rot-x");
        rotSliderY = document.getElementById("slider-rot-y");
        rotSliderZ = document.getElementById("slider-rot-z");
        rotOutputX = document.getElementById("output-rot-x");
        rotOutputY = document.getElementById("output-rot-y");
        rotOutputZ = document.getElementById("output-rot-z");
        
    //  Uniform Scale slider.
        sclUniformSlider = document.getElementById("slider-scale-uniform");
        sclUniformOutput = document.getElementById("output-scale-uniform");
        
    //  Scale sliders.
        sclSliderX = document.getElementById("slider-scl-x");
        sclSliderY = document.getElementById("slider-scl-y");
        sclSliderZ = document.getElementById("slider-scl-z");
        sclOutputX = document.getElementById("output-scl-x");
        sclOutputY = document.getElementById("output-scl-y");
        sclOutputZ = document.getElementById("output-scl-z");
    //
        durSlider = document.getElementById("slider-dur");
        durOutput = document.getElementById("output-dur");
        timescaleSlider = document.getElementById("slider-timescale");
        timescaleOutput = document.getElementById("output-timescale");
        fpsSlider = document.getElementById("slider-fps");
        nameAnimField = document.getElementById("animation-name");
        loopCheckbox = document.getElementById("animation-loop");
    //
        animtimerSlider = document.getElementById("slider-timer");
        animtimerOutput = document.getElementById("output-timer");
        playButton = document.getElementById("animation-play");
        addButton = document.getElementById("animation-add");
        playManual = document.getElementById("manual-play");
    //
        imgRotSlider = document.getElementById("slider-rot-img-y");
        imgPosSlider = document.getElementById("slider-pos-img-y");
        imgRotOutput = document.getElementById("output-rot-img-y");
        imgPosOutput = document.getElementById("output-pos-img-y");

    //  Initialize manual play.
        playManual.checked = false;
        
    //  Initialize Position sliders.
        var pmin, pmax, pstep;
        pmin = -1; pmax = 1; pstep = 0.01; 
        initSlider(posSliderX, pmin, pmax, pstep);
        initSlider(posSliderY, pmin, pmax, pstep);
        initSlider(posSliderZ, pmin, pmax, pstep);
        
    //  Initialize Static Rotation sliders.
        var rmin, rmax, rstep;
        rmin = -180; rmax = 180; rstep = 1;
        initSlider(rotSliderX, rmin, rmax, rstep);
        initSlider(rotSliderY, rmin, rmax, rstep);
        initSlider(rotSliderZ, rmin, rmax, rstep);
        
    //  Initialize Scale sliders.
        var sclmin, sclmax, sclstep;
        sclmin = 0.99; sclmax = 1.01; sclstep = 0.001;
        initSlider(sclSliderX, sclmin, sclmax, sclstep);
        initSlider(sclSliderY, sclmin, sclmax, sclstep);
        initSlider(sclSliderZ, sclmin, sclmax, sclstep);
        initSlider(sclUniformSlider, sclmin, sclmax, sclstep);
        
    //  Initialize Animation sliders.
        var durmin, durmax, durstep;
        durmin = -0.2; durmax = 0.2; durstep = 0.01;
        initSlider(durSlider, durmin, durmax, durstep);
        
        
        function initSlider(domSlider, min, max, step){
            domSlider.min = min;
            domSlider.max = max;
            domSlider.step = step;
        }
        
        
        
        function outputUpdate(domId, theValue) { document.getElementById(domId).value = theValue; }
        
        
        
        function newCurrentBoneSelected(){ 
            getCurrentBone();           
            initBonesAdjustValues();
        }
        
        
        
        function getCurrentBone(){
        //  var bonesDroplist = document.getElementById("droplist-bones");
            currentBoneIndex = bonesDroplist.selectedIndex;                      // number  //  We can put this line in update().
            currentBone = animation.hierarchy[currentBoneIndex];                 // object  //  We can put this line in update().
            currentDataBone = animation.data.hierarchy[currentBoneIndex];        // object  //  We can put this line in update().
            $("#dims-label-selected-name")[0].innerHTML = currentBone.name;
        }
        
        
        
        function initBonesAdjustValues(){
        
        //  INITIALAZE POSITION OUTPUT VALUES.
            posOutputX.value = currentBone.position.x.toFixed(0);     // string
            posOutputY.value = currentBone.position.y.toFixed(0);     // string
            posOutputZ.value = currentBone.position.z.toFixed(0);     // string
            
        //  INITIALAZE ROTATION OUTPUT VALUES.
            var xrad = currentBone.rotation._x;                       // number rad
            var yrad = currentBone.rotation._y;                       // number rad
            var zrad = currentBone.rotation._z;                       // number rad
        //  Always return first rotation y because of quaternion.
            rotOutputY.value = THREE.Math.radToDeg(yrad).toFixed(0);  // string degrees
            rotOutputX.value = THREE.Math.radToDeg(xrad).toFixed(0);  // string degrees
            rotOutputZ.value = THREE.Math.radToDeg(zrad).toFixed(0);  // string degrees
        //  Always return first rotation y because of quaternion.
            rotSliderY.value = Number(rotOutputY.value);             // number degrees
            rotSliderX.value = Number(rotOutputX.value);             // number degrees
            rotSliderZ.value = Number(rotOutputZ.value);             // number degrees
            
        //  INITIALAZE SCALE OUTPUT VALUES.
            sx = currentBone.scale.x * 100;      // number
            sy = currentBone.scale.y * 100;      // number
            sz = currentBone.scale.z * 100;      // number
            sclOutputX.value = sx.toFixed(1);    // string
            sclOutputY.value = sy.toFixed(1);    // string
            sclOutputZ.value = sz.toFixed(1);    // string
            sclUniformOutput.value = sclOutputY.value;
        //
        //  document.getElementById("animator-container-controls").style.display = "block";
        }
        
        

        function staticSliderPressed(identifier, status){ 
            currentSlider = document.getElementById( "slider-" + identifier );
            currentOutput = document.getElementById( "output-" + identifier );
            currentSliderStatus = status;
            // getCurrentBone();
        }
        
        
        
        function dynamicSliderPressed(identifier, status, restore){ 
            currentSlider = document.getElementById( "slider-" + identifier );
            currentOutput = document.getElementById( "output-" + identifier );
            currentSliderStatus = status;
            currentSlider.value = restore;
            // getCurrentBone();
        }
        
        
        
        function fineTuneSliderUp(slider){
            var n = Number(slider.step);
            slider.stepUp(n);
        }
        
        
        
        function fineTuneSliderDown(){
            var n = Number(slider.step);
            slider.stepDown(n);
        }
        
        
        
        
//////////////////////////////////// start of animation editing ////////////////////////////////////

        
        
        
        var keymarksArray = [];
        
        

        function insertNewAnimateDataTimeFrameKey(){
            
        //  Pause the animation.
            timescaleSlider.value = 0;  
            
        //  Check first if animation key exists. If not, create it. Then set currentAnimationKeyIndex again.
            bcaFrameKeyIndexesArray( animtimerSlider.value );
            var b = bcaAnimationDataIndexKeys[0];
            var c = bcaAnimationDataIndexKeys[1];
            var a = bcaAnimationDataIndexKeys[2];
            
        //  Calculate the index position to insert the new animation data key.
            if (!animationDataKeyExist){
                var idx, spl;
                if ( b &&  a ) { idx = b; spl = a; }          // splice to next key index.
                else if (!b &&  a) { idx = 0; spl = a; }      // splice to next key index.
                else if ( b && !a) { idx = b; spl = b + 1; }  // push to end of keys array.
                else if (!b && !a) { idx = 0; spl = 0; }      // keys array is empty. unshift to beginning of keys array.
                
                for (var i in animation.data.hierarchy){
                
                            /////////////////////////////////////////////////////////////////////////////////////////
                            //  IMPORTANT: animation.data.hierarchy[].keys[].rot WORKS ONLY WITH THREE.Quaternion  //
                            /////////////////////////////////////////////////////////////////////////////////////////
                            
                //  Create a new animation data key with current time bones values at animation.data.hierarchy[i].keys[idx].
                    var newKey = {"index":spl, "pos":[], "rot":new THREE.Quaternion(), "scl":[], "time":Number(animtimerSlider.value)};
                    
                //  Get bones values at current time from animation.hierarchy.
                    newKey.pos = animation.hierarchy[i].position.toArray();
                    newKey.rot.copy(animation.hierarchy[i].quaternion);
                    newKey.scl = animation.hierarchy[i].scale.toArray();
                    
                //  Add new key in animation data hierarchy keys array.
                    if (spl < animation.data.hierarchy[i].keys.length) {
                        animation.data.hierarchy[i].keys.splice(spl, 0, newKey);      // add new key before the after key.
                    } else {
                        animation.data.hierarchy[i].keys.push(newKey);                // add new key at end of keys array.
                    }
                                ///////////////////////////////////////////////////////////////////////////////
                                //  IMPORTANT: Every animation data key object must have "index": property.  //
                                ///////////////////////////////////////////////////////////////////////////////
            
                //  Ensure keys indexing.
                    for (var j in animation.data.hierarchy[i].keys){
                        animation.data.hierarchy[i].keys[j].index = Number(j);
                    }
                }
                console.log("New animation data key added at", animtimerSlider.value, "sec.", animation.data.hierarchy[0]);
                
                ensureKeysIndexing();
            }
            
        //  Update bca indexes to get the new currentAnimationKeyIndex.
            bcaFrameKeyIndexesArray( animtimerSlider.value );
            
        //  Get currentAnimationKeyIndex and then define currentAnimationKeyObject.
        //  currentDataBone = animation.data.hierarchy[currentBoneIndex];
            newCurrentBoneSelected();
            
            
        //  Sort animation data keys by time.
            for (var i in animation.data.hierarchy){
                animation.data.hierarchy[i].keys.sort(function(a,b){return parseFloat(a.time) - parseFloat(b.time);})
            }
            
        //  Delete existed keyframes handlers.
            document.getElementById("keys-container").innerHTML = "";
            
        //  Create new indexed keyframes handlers.
            for (var i in animation.data.hierarchy[0].keys){
                newTimeKeyMarker(i);
            }
            
        }

    //  Create Keyframes Handler.

        function newTimeKeyMarker(k){
        //  var v = Number(document.getElementById("slider-timer").value);
            var v = animation.data.hierarchy[0].keys[k].time;
            var m = Number(document.getElementById("slider-timer").max);
            
            var keymark = document.createElement("DIV");
        //  keymark.style.border = "1px solid #ff0";
            keymark.class = "keymark";
            keymark.style.position = "absolute";
            keymark.style.backgroundColor = "#ff0";
            keymark.style.cursor = "pointer";
            keymark.style.color = "#000";
            keymark.style.fontSize = "14px";
            keymark.style.fontWeight = "bold";
        //  keymark.style.minWidth = "1px";
            keymark.style.width = "auto";
            keymark.style.height = "16px";
            keymark.style.top = "10px";
        
            keymark.innerHTML = animation.data.hierarchy[0].keys[k].index.toString();
            var offset = ( 100 * v / m );  var half = ( keymark.offsetWidth / 2 );
            keymark.style.left = offset.toFixed(2) + "%";
            
            debugMode && console.log("keymark style left:", keymark.style.left, "half:", half);

            keymark.addEventListener("mousedown", onkeymarkMouseDown, false);
            keymark.addEventListener("mouseenter", onkeymarkMouseEnter, false);
            keymark.addEventListener("mouseleave", onkeymarkMouseLeave, false);
            
        //  Drag & Drop.
            keyDragDrop.initElement(keymark);
            
            document.getElementById("keys-container").appendChild(keymark);
            
        //  Keymark info.
            var keyinfo = document.createElement("DIV");
            keyinfo.style.position = "absolute";
        //  keyinfo.style.border = "1px solid #fff";
            keyinfo.style.color = "#fff";
            keyinfo.style.fontSize = "12px";
            keyinfo.style.fontWeight = "bold";
            keyinfo.style.top = "-25px";
            keyinfo.style.display = "block";
            keyinfo.innerHTML = animation.data.hierarchy[0].keys[k].time.toFixed(2);
            keyinfo.style.left = "-100%";
            
            keymark.appendChild(keyinfo);
            
            console.log("New animation key marker created at", keyinfo.innerHTML, "sec.");
            return [keymark, keyinfo];
        }
        
        
        
        var currentkeymark;
        var currentkeytime;
        var currentkeyindex;
        
        function onkeymarkMouseDown(){ 
            this.style.backgroundColor = "#f00";
            //console.log(this);
            currentkeymark = this;
            //console.log("currentkeymark:", currentkeymark);
            currentkeytime = this.children[1];
            //console.log("currentkeytime:", currentkeytime);
            
        //  Find corresponding Frame key before you add listeners.
            
            for (var i=0; i < document.getElementById("keys-container").children.length; i++){
                if (this == document.getElementById("keys-container").children[i]){
                    currentkeyindex = i;
                    break;
                }
            }
            
            console.log("currentkeyindex:", currentkeyindex);
            
        //  Ensure keys index.
        //  ensureKeysIndexing();
            
            document.addEventListener("mousemove", onkeymarkMouseMove, false);
            document.addEventListener("mouseup", onkeymarkMouseUp, false);
            
            var t = (currentkeymark.offsetLeft / keyscontainer.offsetWidth) * ( slidertimer.max );
            
            if (t > Number(slidertimer.max)) {
                t = Number(slidertimer.max);
            }
            t = Number(t.toFixed(2));
            currentkeytime.innerHTML = t;
        }
        
        
        function onkeymarkMouseEnter(){ 
            this.style.backgroundColor = "#0f0"; 
        }
        
        
        function onkeymarkMouseLeave(){ 
            this.style.backgroundColor = "#ff0"; 
        }
        
        
        var slidertimer = document.getElementById("slider-timer");
        var keyscontainer = document.getElementById("keys-container");
        
        
        function onkeymarkMouseMove(){
            //currentkeytime.innerHTML = currentkeytime.parentElement.style.left;
            var t = (currentkeytime.parentElement.offsetLeft / keyscontainer.offsetWidth) * ( slidertimer.max );
            if (t > Number(slidertimer.max)) {
                t = Number(slidertimer.max);
            }
            t = Number(t.toFixed(2));
            currentkeytime.innerHTML = t;
        }
        
        
        function onkeymarkMouseUp(){
            
        //  Update animation.data.hierarchy[i].keys[currentkeyindex].time.
            var t = Number(currentkeytime.innerHTML);
            console.log("currentkeytime", "=", t);
            
            for (var i in animation.data.hierarchy){
                animation.data.hierarchy[i].keys[currentkeyindex].time = t;
            //  Sort animation keys by time.
                animation.data.hierarchy[i].keys.sort( function(a,b){
                    return parseFloat(a.time) - parseFloat(b.time);
                })
            }
            
        //  Ensure keys index.
            ensureKeysIndexing();
            
        //  Remove event listeners.
            var keymarks = document.getElementById("keys-container").children;
            console.log("keymarks:", keymarks);
            for (var i in keymarks){
                console.log("keymarks[", i, "]:", keymarks[i]);
                var keymark = keymarks[i];
                console.log("keymark:", keymark);
                if (keymark == keymarks.length) {
                    console.log("keymark == keymarks.length:", keymark == keymarks.length);
                    break;
                }
                keymark.removeEventListener("mousedown", onkeymarkMouseDown);
                keymark.removeEventListener("mouseenter", onkeymarkMouseEnter);
                keymark.removeEventListener("mouseleave", onkeymarkMouseLeave);
            }
            console.log("==end of loop==");
            
        //  Delete existed keyframes handlers.
            document.getElementById("keys-container").innerHTML = "";
            
        //  Create new indexed keyframes handlers.
            for (var i in animation.data.hierarchy[0].keys){
                newTimeKeyMarker(i);
            }
            
        //  Initialize current key variables.
            currentkeymark = undefined;
            currentkeytime = undefined;
            currentkeyindex = undefined;
            
        //  Remove event listeners.
            document.removeEventListener("mousemove", onkeymarkMouseMove);
            document.removeEventListener("mouseup", onkeymarkMouseUp);
        }
        
    
        
//////////////////////////////////// submit user sliders values ////////////////////////////////////
        
        

        function submitNewPositionValue(){
            
        //  insertNewAnimateDataTimeFrameKey();
            
        //  Submit value to object.
            currentDataBone.keys[currentAnimationKeyIndex].pos[0] += Number( posSliderX.value );     // number
            currentDataBone.keys[currentAnimationKeyIndex].pos[1] += Number( posSliderY.value );     // number
            currentDataBone.keys[currentAnimationKeyIndex].pos[2] += Number( posSliderZ.value );     // number
            
        //  Play the frame.
            timescaleSlider.value = 0;
            animation.play( animation.currentTime );
            
        //  Return value to output.
            posOutputX.value = currentBone.position.x.toFixed(0);     // string
            posOutputY.value = currentBone.position.y.toFixed(0);     // string
            posOutputZ.value = currentBone.position.z.toFixed(0);     // string
        }



        function reverseSubmitPositionValue(){
        //  Return value to output.
            if (animation){
                posOutputX.value = currentBone.position.x.toFixed(0);     // string
                posOutputY.value = currentBone.position.y.toFixed(0);     // string
                posOutputZ.value = currentBone.position.z.toFixed(0);     // string
            }
        }
        
        
        
        function submitNewRotationValue(){
            
        //  insertNewAnimateDataTimeFrameKey();
            
        //  Get rotation from current bone.
            var x = currentBone.rotation._x;
            var y = currentBone.rotation._y;
            var z = currentBone.rotation._z;
            
            x += THREE.Math.degToRad( Number( rotSliderX.value ) );
            y += THREE.Math.degToRad( Number( rotSliderY.value ) );
            z += THREE.Math.degToRad( Number( rotSliderZ.value ) );
            
            var euler = new THREE.Euler(x, y, z, "XYZ");
            
            var quaternion = new THREE.Quaternion();
            
            quaternion.setFromEuler( euler );
            
            currentDataBone.keys[ currentAnimationKeyIndex ].rot.copy( quaternion );
        
        //  Play the frame.
            timescaleSlider.value = 0;
            animation.play( animation.currentTime );
            
        //  Return value to output.
            var xrad = currentBone.rotation._x;                      // number rad
            var yrad = currentBone.rotation._y;                      // number rad
            var zrad = currentBone.rotation._z;                      // number rad
            rotOutputX.value = THREE.Math.radToDeg(xrad).toFixed(0); // string degrees
            rotOutputY.value = THREE.Math.radToDeg(yrad).toFixed(0); // string degrees
            rotOutputZ.value = THREE.Math.radToDeg(zrad).toFixed(0); // string degrees
        }
        
        
        
        function reverseSubmitRotationValue(){
        //  Return value to output.
            if (animation){
                var xrad = currentBone.rotation._x;                      // number rad
                var yrad = currentBone.rotation._y;                      // number rad
                var zrad = currentBone.rotation._z;                      // number rad
                rotOutputX.value = THREE.Math.radToDeg(xrad).toFixed(0); // string degrees
                rotOutputY.value = THREE.Math.radToDeg(yrad).toFixed(0); // string degrees
                rotOutputZ.value = THREE.Math.radToDeg(zrad).toFixed(0); // string degrees
            }
        }
        
        
        
        function submitStaticRotationValue(){
        
        //  insertNewAnimateDataTimeFrameKey();
            var x = THREE.Math.degToRad( Number( rotSliderX.value ) );
            var y = THREE.Math.degToRad( Number( rotSliderY.value ) );
            var z = THREE.Math.degToRad( Number( rotSliderZ.value ) );
            
            var euler = new THREE.Euler(x, y, z, "XYZ");
            var quaternion = new THREE.Quaternion();
            quaternion.setFromEuler( euler );
            currentDataBone.keys[ currentAnimationKeyIndex ].rot.copy( quaternion );
        
        //  Play the frame.
            timescaleSlider.value = 0;
            animation.play( animation.currentTime );
            
        //  Return value to output.
            var xrad = currentBone.rotation._x;                      // number rad
            var yrad = currentBone.rotation._y;                      // number rad
            var zrad = currentBone.rotation._z;                      // number rad
            
        //  Always return first rotation y because of quaternion.
            rotOutputY.value = THREE.Math.radToDeg(yrad).toFixed(0); // string degrees
            rotOutputX.value = THREE.Math.radToDeg(xrad).toFixed(0); // string degrees
            rotOutputZ.value = THREE.Math.radToDeg(zrad).toFixed(0); // string degrees
        }
        
        
        
        function reverseSubmitStaticRotationValue(){
        //  Return value to output.
            if (animation){
                var xrad = currentBone.rotation._x;                      // number rad
                var yrad = currentBone.rotation._y;                      // number rad
                var zrad = currentBone.rotation._z;                      // number rad
                
            //  Always return first rotation y because of quaternion.
                rotOutputY.value = THREE.Math.radToDeg(yrad).toFixed(0); // string degrees
                rotOutputX.value = THREE.Math.radToDeg(xrad).toFixed(0); // string degrees
                rotOutputZ.value = THREE.Math.radToDeg(zrad).toFixed(0); // string degrees
                
            //  Always return first rotation y because of quaternion.
                rotSliderY.value = Number(rotOutputY.value);             // number degrees
                rotSliderX.value = Number(rotOutputX.value);             // number degrees
                rotSliderZ.value = Number(rotOutputZ.value);             // number degrees
            }
        }
        
        
        
        function submitNewScaleValue(){
        
        //  insertNewAnimateDataTimeFrameKey();
            
        //  Submit value to object.
            var sx = Number( sclSliderX.value ); // number
            var sy = Number( sclSliderY.value ); // number
            var sz = Number( sclSliderZ.value ); // number
            sx = Number(sx.toFixed(3));          // number
            sy = Number(sy.toFixed(3));          // number
            sz = Number(sz.toFixed(3));          // number
            
        //  currentDataBone.keys[currentAnimationKeyIndex].scl[0]
            currentDataBone.keys[currentAnimationKeyIndex].scl[0] *= sx;    // number
            currentDataBone.keys[currentAnimationKeyIndex].scl[1] *= sy;    // number
            currentDataBone.keys[currentAnimationKeyIndex].scl[2] *= sz;    // number
            
        //  Play the frame.
            timescaleSlider.value = 0;
            animation.play( animation.currentTime );
            
        //  Return value to output.
            sx = currentBone.scale.x * 100;      // number
            sy = currentBone.scale.y * 100;      // number
            sz = currentBone.scale.z * 100;      // number
            sclOutputX.value = sx.toFixed(1);    // string
            sclOutputY.value = sy.toFixed(1);    // string
            sclOutputZ.value = sz.toFixed(1);    // string
            sclUniformOutput.value = sclOutputY.value;
        }



        function reverseSubmitScaleValue(){
        //  Return value to output.
            if (animation){
                sx = currentBone.scale.x * 100;      // number
                sy = currentBone.scale.y * 100;      // number
                sz = currentBone.scale.z * 100;      // number
                sclOutputX.value = sx.toFixed(1);    // string
                sclOutputY.value = sy.toFixed(1);    // string
                sclOutputZ.value = sz.toFixed(1);    // string
                sclUniformOutput.value = sclOutputY.value;
            }
        }
        
        
        
        function submitUniformScaleValue(){
        
        //  insertNewAnimateDataTimeFrameKey();
            
        //  Submit value to object.
            var s = Number( sclUniformSlider.value );
            //s = s * currentDataBone.keys[currentAnimationKeyIndex].scl[1];
            s = Number(s.toFixed(3));
            
            currentDataBone.keys[currentAnimationKeyIndex].scl[0] *= s; // number
            currentDataBone.keys[currentAnimationKeyIndex].scl[1] *= s; // number
            currentDataBone.keys[currentAnimationKeyIndex].scl[2] *= s; // number
            
        //  Play the frame.
            timescaleSlider.value = 0;
            animation.play( animation.currentTime );
            
        //  Return value to output.
            s = currentBone.scale.y * 100;
            sclUniformOutput.value = s.toFixed(1); // string
            sclOutputX.value = s.toFixed(1);       // string
            sclOutputY.value = s.toFixed(1);       // string
            sclOutputZ.value = s.toFixed(1);       // string
        }
        
        
        
        
///////////////////////////////////// end of animation editing /////////////////////////////////////
        
        
        function submitNewDurationValue(){
            var theValue = Number(animtimerSlider.value);
            var lowend = 1;
            var highend = 10;
            var d = Number(durSlider.value);        // number
            d = Number(animtimerSlider.max) + d;    // number
            
            if (d > lowend && d < highend) 
            {
            //  Submit value to object.
                animtimerSlider.max = d.toFixed(1); // string
            //  Return value to output.
                d = Number(animtimerSlider.max);    // number
                durOutput.value = d;                // number
            }
            else if (d < lowend)
            {
                animtimerSlider.max = lowend;       // number
                durOutput.value = lowend;           // number
            }
            else if (d > highend)
            {
                animtimerSlider.max = highend;      // number
                durOutput.value = highend;          // number
            }
            animtimerSlider.value = 0;              // number
            animtimerSlider.value = theValue;       // number
            animtimerOutput.value = theValue;
        }
        
        
        
        function submitAnimationName(){
            animation.data.name = document.getElementById("animation-name").value;
        }
        
        
        
        function initAnimatorAdjustValues(){
        //  INITIALAZE DURATION OUTPUT VALUE.
            var duration = Number(animtimerSlider.max);
            durOutput.value = duration;
        }

        
    </script>
     
     
     
     
    <script>
        
        
        
        if ( ! Detector.webgl ) Detector.addGetWebGLMessage();
        
        var frameCount = 0;
        var mouse = new THREE.Vector2();
        var avatar;
        var armature, armatureHelper;
        var animation;
        var poseHelper;
        var normals;
        var morphs = [];
        var skins = [];
        
        
        
    //  Define animation object.
        var animationsHandler = THREE.AnimationHandler.animations;   //  array
        
        
        
    //  Before, Current, After (bca) Frame Key Indexes Array.
        function bcaFrameKeyIndexesArray(t){
        //  Check if frame (t) already exist in animationData.
            var keyExists = false;
            var keyBefore, keyIndex, keyAfter;
            var keysArray = (animation) ? animation.data.hierarchy[0].keys : [];
        //  var t = Number(animtimerSlider.value);
            if (keysArray.length > 0){
                for (var j in keysArray){
                    if (keysArray[j].time < Number(t)){
                        keyBefore = Number(j);
                    }
                    else if (keysArray[j].time == Number(t)){
                        keyIndex = Number(j);
                        keyExists = true;
                    }
                    else if (keysArray[j].time > Number(t)){
                        keyAfter = Number(j);
                        break;
                    }
                    else 
                    {
                        var a = "DEBUG_ERROR_CAUTCH:"
                        var b = "currentFrameKeyExists():"
                        var c = "if (keysArray.length > 0)..."
                        console.log( a, b, c );
                    }
                }
            }
            animationDataKeyExist = keyExists;
            bcaAnimationDataIndexKeys = [keyBefore, keyIndex, keyAfter];
            currentAnimationKeyIndex = keyIndex;
            //  console.log("bca keys:", bcaAnimationDataIndexKeys);
            return bcaAnimationDataIndexKeys;
        }
        
        
        
    ///////////////////// start of playAnimation() //////////////////////
    
    //  When you press a save button you can sent this animationData object to server database.
    
    //  Play Button handles the timeSpeed of animation.
    
    //  Animation is always in play mode. Never stopping.
        
        function playAnimation(theAvatar){
        
            if (playButton.innerHTML == "Play"){
                ensureLooping();
                ensureKeysIndexing();
                timescaleSlider.value = currentSpeed;
                timescaleOutput.value = currentSpeed;
                animation.play(animation.currentTime);
                animtimerSlider.value = animation.currentTime;
                playButton.innerHTML = "Pause";
                document.getElementById("status-msgr").innerHTML = "Playing...";
                document.getElementById("status-msgr").style.display = "block";
                console.log("Animation is playing.");
            }
            
            else if (playButton.innerHTML == "Pause"){
                timescaleSlider.value = 0;
                timescaleOutput.value = currentSpeed;
                animtimerSlider.value = animation.currentTime;
                playButton.innerHTML = "Play";
                console.log("animation.data:", animation.data);
                document.getElementById("status-msgr").innerHTML = "Paused";
                document.getElementById("status-msgr").style.display = "block";
                console.log("Animation paused.");
            }
        }
        
        
        
        function ensureLooping(){
            var lastkeyExists = false;
            var z = animation.data.hierarchy[0].keys.length - 1;
            var t = animation.data.length;
            if (animation.data.hierarchy[0].keys[z].time == t) {
                lastkeyExists = true;
            }
            for (var i in animation.data.hierarchy){
                var posloop = animation.data.hierarchy[i].keys[0].pos;
                var rotloop = animation.data.hierarchy[i].keys[0].rot;
                var sclloop = animation.data.hierarchy[i].keys[0].scl;
                var loopKeyData = {"index":z, "pos":posloop, "rot":rotloop, "scl":sclloop, "time":t};
            //  console.log("loopKeyData:", loopKeyData);
                if (lastkeyExists) {
                    var removedItems = 1;
                    animation.data.hierarchy[i].keys.splice(z, removedItems, loopKeyData);
                }
                else {
                   var removedItems = 0;
                   loopKeyData.index = animation.data.hierarchy[0].keys.length;   // index correction.
                   animation.data.hierarchy[i].keys.push(loopKeyData);
                }
            }
            console.log("Ensure Looping completed.");
        }
        
        
        
        function ensureKeysIndexing(){
            for (var i in animation.data.hierarchy){
                for (var j in animation.data.hierarchy[i].keys){
                    animation.data.hierarchy[i].keys[j].index = Number(j);
                }
            }
            console.log("Ensure Keys Indexing completed.");
        }


    ////////////////////// end of playAnimation() ///////////////////////
        
        
        var animator3JsInitialized = false;

        function animatorEditorRuntime(){

            if ( !animator3JsInitialized ){
                
                initAnimatorScene();
                animateAnimatorScene();
                
                animator3JsInitialized = true;
                console.log("Animator Editor scene initialized.");
            }
        }
        
        
        function initAnimatorScene(){
        //  Canvas.
            animatorContainer = document.getElementById("animator-render-container");

        //  Scene.
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2( 0x000000, 0.0001 );

        //  Camera.
            near = 1; 
            far = 100000;
            camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, near, far );
            camera.position.set( -1.5, 18, 33 );
            camera.rotation.set( -0.043, -0.035, -0.002 );
            camera.name = "CAMERA" ;

        //  Scene lights.
            light0 = newDirectionalLight(0xffffff, 1000, 1000, 1000, 0.5);
            light1 = newDirectionalLight(0xffffff, 1000, 1000, -1000, 0.5);
            light2 = newDirectionalLight(0xffffff, -1000, 1000, -1000, 0.5);
            light3 = newDirectionalLight(0xffffff, -1000, 1000, 1000, 0.5);
            light4 = newDirectionalLight(0xffffff, 0, -1000, 0, 0.5);
            scene.add(light0, light1, light2, light3, light4);

        //  Controls.
            controls = new THREE.EditorControls(camera);

        //  Projector.
        	projector = new THREE.Projector();

        //  Ground Helper.
            groundHelper = newGroundHelper();
            scene.add(groundHelper);

		//  Skydome.
            var loader = new THREE.TextureLoader();
    		skydome = new THREE.Mesh(
    			new THREE.SphereGeometry( far * 0.1, 15, 15 ),
    			new THREE.MeshBasicMaterial({
    				map: loader.load( "skydomes/skydome.jpg" ),
    				color: 0xffffff,
    				side: THREE.DoubleSide
    			})
    		);
    		skydome.rotation.y = Math.PI;
    		skydome.scale.set(-1, 2, 1);
    		scene.add( skydome );
    		
        //  Axis Helper.
            axisCustomHelper = newCustomAxisHelper(scene);
            scene.add(axisCustomHelper);

        //  Floor.
        //  var material = new THREE.MeshLambertMaterial( { color:0x8888ff, side:THREE.DoubleSide } );
        //  floorPlain = new THREE.Mesh( new THREE.PlaneGeometry( 50, 50, 1, 1 ), material );
        //  floorPlain.position.set( 0, 0, 0 );
        //  floorPlain.rotation.set( -Math.PI/2, 0, 0 );
        //  scene.add( floorPlain );

        //  Keyboard controls.
            keyboard = new KeyboardState();

        //  Clock.
            clock = new THREE.Clock();

        //  Renderer.
            renderer = new THREE.WebGLRenderer( { antialias:true, preserveDrawingBuffer:true } );
            renderer.shadowMapEnabled = true;
    		renderer.setPixelRatio( window.devicePixelRatio );
    		renderer.setSize( window.innerWidth, window.innerHeight ); 
			renderer.autoClear = true; 
    		animatorContainer.appendChild( renderer.domElement );

        //  Event Listeners.
            window.addEventListener( 'resize', onWindowResize, false );
        	document.addEventListener( 'mousedown', onDocumentMouseDown, false );
        	document.addEventListener( 'mouseup', onDocumentMouseUp, false );
            document.addEventListener( 'mousemove', onDocumentMouseMove, false );
            
        //  Manny The Skeleton Default Rigged Mesh.
            loadSkinnedAnimatedMesh("skinned/MannyTheSkeletonDefaultRigged_v04.js", 1);
            
        //  Animator Inits.
            initAnimatorAdjustValues();
        }
        
        
        function defaultAnimatorRendererContainer(){
            groundHelper.visible = true;
            axisCustomHelper.visible = true;
        //  floorPlain.visible = true;
            animatorContainer = document.getElementById("animator-render-container");
        //  document.getElementById("preview-animator").style.display = "none"; 
            
            camera.aspect = animatorContainer.offsetWidth / animatorContainer.offsetHeight;
            camera.updateProjectionMatrix();
            renderer.setSize( animatorContainer.offsetWidth - 2, animatorContainer.offsetHeight - 2 ); 
            animatorContainer.appendChild( renderer.domElement );
            controls.focus(avatar, true);
        }
        
        
        function changeAnimatorRendererContainer( displayId, containerId ){
            
            if (animator3JsInitialized) {
            
                if ( animatorContainer == document.getElementById("animator-render-container") ) {
                    groundHelper.visible = false;
                    axisCustomHelper.visible = false;
                //  floorPlain.visible = false;
                    armatureHelper.visible = false;
                    animatorContainer = document.getElementById(containerId);
                    document.getElementById(displayId).style.display = "block"; 
                } else {
                    groundHelper.visible = true;
                    axisCustomHelper.visible = true;
                //  floorPlain.visible = true;
                //  armatureHelper.visible = true;
                    animatorContainer = document.getElementById("animator-render-container");
                    document.getElementById(displayId).style.display = "none"; 
                }
                
                camera.aspect = animatorContainer.offsetWidth / animatorContainer.offsetHeight;
                camera.updateProjectionMatrix();
                renderer.setSize( animatorContainer.offsetWidth - 2, animatorContainer.offsetHeight - 2 ); 
                animatorContainer.appendChild( renderer.domElement );
                controls.focus(avatar, true);
                
            }
            
        }
        
        
        function getRendererScreenPrintImage() {
            var imageData = renderer.domElement.toDataURL("image/png");
            console.log(imageData);
            return imageData;
        }
        
        
        function loadSkinnedAnimatedMesh(url, scale){
        //  Remove old avatar from scene.
            if (avatar) scene.remove(avatar);
        //  Remove old armature helper.
            if (armatureHelper) scene.remove(armatureHelper);
            
        //  Load Skinned Armatured Mesh.
            var loader = new THREE.JSONLoader();
            loader.load( url, function(geometry, materials){
                geometry.computeVertexNormals();
    	        geometry.computeBoundingBox();
   	        //
    	        for ( var i = 0, il = materials.length; i < il; i ++ ) 
                {
                    var originalMaterial = materials[ i ];
                    originalMaterial.skinning = true;
                }
   	        //
                var material = new THREE.MeshFaceMaterial(materials);
                avatar = new THREE.SkinnedMesh(geometry, material, false);
                avatar.name = "AVATAR";
                avatar.position.set( 0, 0, 0 );
                avatar.scale.set( scale, scale, scale );
                avatar.rotation.set( 0, 0, 0 );
                avatar.userData.animationData = {};
                scene.add(avatar);
                skins.push(avatar);
                console.log("Avatar loaded:", avatar);
            //
                armatureHelper = newSkeletonHelper(avatar);
                scene.add(armatureHelper);
                armatureHelper.visible = false;
                console.log("Armature Helper created:", armatureHelper);
            
            //  Initialize Bones Drop list.
                initBonesDroplist(avatar);
                console.log("Bones droplist initialized.");
                
            //  Define the animationData object to create the init animation.
                var animationData = {"name":null, "fps":null, "length":null, "hierarchy":[]};
                animationData.name = nameAnimField.value;
                animationData.fps = Number(fpsSlider.value);
                animationData.length = Number(animtimerSlider.max);
                
            
            //  Prepear animationData for first init animation keys.

            //  Create the init key (time:0) for every bone of avatar in animationData.hierarchy.
                for (var i in avatar.skeleton.bones) {
                    animationData.hierarchy.push({"keys":[]});
                    var initAnimationKey = {"pos":[0,0,0], "rot":[0,0,0,1], "scl":[1,1,1], "time":0};
                    initAnimationKey.pos = avatar.skeleton.bones[i].position.toArray();
                    initAnimationKey.rot = avatar.skeleton.bones[i].quaternion.toArray();
                    initAnimationKey.scl = avatar.skeleton.bones[i].scale.toArray();
                    animationData.hierarchy[i].keys.push(initAnimationKey);
                }
                console.log( "Animation Data created:", animationData );
                
            //  Create the animation.
                THREE.AnimationHandler.animations = [];
                animation = new THREE.Animation( avatar, animationData );
                animation.isPlaying = false;
                animation.currentTime = 0;
                timescaleSlider.value = 0;
                playButton.innerHTML = "Play";
                console.log("Animation created:", animation);
            //
                ensureLooping();
            
            //  Create a userData array to store rest pose.
                avatar.userData.restPose = [];
                
            //  Store init key as rest pose in userData.
                for (var i in animation.hierarchy) {
                    var restPoseKey = {"pos":[0,0,0], "rot":[0,0,0,1], "scl":[1,1,1]};
                    restPoseKey.pos = animation.hierarchy[i].position.toArray();
                    avatar.userData.restPose.push( restPoseKey );
                }
                console.log( "Rest pose saved:", avatar.userData.restPose );
                
            //  Now that we have create the animation
            //  we can get the currentBone and initialize
            //  the bones values in bone adjust sliders.
            
                getCurrentBone(); 
                initBonesAdjustValues();
                console.log("Avatar loading completed and ready to animate.");
            });
        }

        
        
        
    //  LOAD JSON SKINNED MESH.
        
        function loadJsonSkinnedAnimatedMesh(event){
        //  Remove old skinnedmesh from scene.
            if (avatar) scene.remove(avatar);
        //  Remove old armature helper.
            if (armatureHelper) scene.remove(armatureHelper);

        //  JSON TEXT CONTENTS READER.
            var reader = new FileReader();
            
        //  FileList object.
            var file = event.target.files[0];
            console.log("file:", file);
            var filename = file.name;
            console.log("filename:", filename);
    		var extension = filename.split( '.' ).pop().toLowerCase();
    		console.log("extension:", extension);
    		var name = filename.split( '.' )[0];
    		console.log("name:", name);
    		
//      1. First we read json file as text.

        //  Read json file as a text string.
            reader.readAsText(file);
            
        //  When reading competed...
            reader.onloadend = function(event){
                //console.log(event.target.result);
                contents = event.target.result;
            //  Skinned Json data for skinned collection input.
                skinnedJsonData = event.target.result;
                //console.log("contents:", contents);
                console.log("json contents readed as text string.");
//      2. Then we parse json string as json data with JSON parser.
            //  Parse json contents string as json data.
                var data = JSON.parse( contents );
                console.log("json contents parsed as data:", data);
            //  Get Json contents metadata.
                var metadata = data.metadata;
                console.log("json metadata:", metadata);
//      3. Last we parse again json data with a new JSONLoader to get the geometry.
                var loader = new THREE.JSONLoader();
                var result = loader.parse( data );
                console.log("json data parsed with THREE.JSONLoader as JSON object {geometry, materials}.");
                console.log("result:", result);
                var geometry = result.geometry;
                console.log("geometry:", geometry);
                
//      4. We create the materials from json results.
                geometry.computeVertexNormals();
    	        geometry.computeBoundingBox();
 		    //
                var material;
    			if ( result.materials !== undefined ) {
                    for ( var i = 0; i < result.materials.length; i++ ) {
                        var originalMaterial = result.materials[ i ];
                        originalMaterial.skinning = true;
                    }
                    if ( result.materials.length > 1 )
    					material = new THREE.MeshFaceMaterial( result.materials );
    				else 
    					material = result.materials[ 0 ];
    			} 
                else {
    				material = new THREE.MeshPhongMaterial();
    			}
    			console.log("material:", material);
            //
                geometry.sourceType = "ascii";
    		    geometry.sourceFile = file.name;
    		    
//      5. We create the json skinned mesh object.
    			if ( geometry.bones && geometry.bones.length > 0 ) {
    				// var material = new THREE.MeshFaceMaterial(result.materials);
                    avatar = new THREE.SkinnedMesh(geometry, material, false);
                    avatar.name = "AVATAR";
                    avatar.position.set( 0, 0, 0 );
                    avatar.scale.set( 1, 1, 1 );
                    avatar.rotation.set( 0, 0, 0 );
                    avatar.userData.animationData = {};
                    // scene.add(avatar);
                    skins.push(avatar);
                    console.log("Avatar loaded:", avatar);
    			} 
                else {
                    var msg = "Sorry. This is not a skinned mesh. Try to upload with Easy Meshes Upload Form.";
                    console.log(msg);
                    alert(msg);
                    return;
    			}
    			
//      6. We add new mesh in SKIN scene.
    			scene.add(avatar);
    			console.log("avatar added in Animator scene:", scene.children);
            //  Loading completed.
                console.log("Loading skinned json file", filename, "completed.");
            //  Focus Editor controls.
                controls.focus(avatar, true);
                
//      7. We add all the rest things in scene.
                armatureHelper = newSkeletonHelper(avatar);
                scene.add(armatureHelper);
                armatureHelper.visible = false;
                console.log("Armature Helper created:", armatureHelper);
            
            //  Initialize Bones Drop list.
                initBonesDroplist(avatar);
                console.log("Bones droplist initialized.");
                
            //  Define the animationData object to create the init animation.
                var animationData = {"name":null, "fps":null, "length":null, "hierarchy":[]};
                animationData.name = nameAnimField.value;
                animationData.fps = Number(fpsSlider.value);
                animationData.length = Number(animtimerSlider.max);
                
            //  Prepear animationData for first init animation keys.

            //  Create the init key (time:0) for every bone of avatar in animationData.hierarchy.
                for (var i in avatar.skeleton.bones) {
                    animationData.hierarchy.push({"keys":[]});
                    var initAnimationKey = {"pos":[0,0,0], "rot":[0,0,0,1], "scl":[1,1,1], "time":0};
                    initAnimationKey.pos = avatar.skeleton.bones[i].position.toArray();
                    initAnimationKey.rot = avatar.skeleton.bones[i].quaternion.toArray();
                    initAnimationKey.scl = avatar.skeleton.bones[i].scale.toArray();
                    animationData.hierarchy[i].keys.push(initAnimationKey);
                }
                console.log( "Animation Data created:", animationData );
                
            //  Create the animation.
                THREE.AnimationHandler.animations = [];
                animation = new THREE.Animation( avatar, animationData );
                animation.isPlaying = false;
                animation.currentTime = 0;
                timescaleSlider.value = 0;
                playButton.innerHTML = "Play";
                console.log("Animation created:", animation);
            //
                ensureLooping();
            
            //  Create a userData array to store rest pose.
                avatar.userData.restPose = [];
                
            //  Store init key as rest pose in userData.
                for (var i in animation.hierarchy) {
                    var restPoseKey = {"pos":[0,0,0], "rot":[0,0,0,1], "scl":[1,1,1]};
                    restPoseKey.pos = animation.hierarchy[i].position.toArray();
                    avatar.userData.restPose.push( restPoseKey );
                }
                console.log( "Rest pose saved:", avatar.userData.restPose );
                
            /*  Now that we have create the animation
                we can get the currentBone and initialize
                the bones values in bone adjust sliders.
            */
                getCurrentBone(); 
                initBonesAdjustValues();
                console.log("Avatar loading completed and ready to animate.");
                
			}
        }
        
        
        
        function initBonesDroplist(theAvatar){
        //  Remove all options from droplist.
            bonesDroplist.innerHTML = null;
            
        //  Create new options list from avatar bones.
            for (var i in theAvatar.skeleton.bones){
                var newOption = document.createElement("option");
                newOption.value = theAvatar.skeleton.bones[i].name;
                newOption.text = theAvatar.skeleton.bones[i].name;
                bonesDroplist.options.add(newOption);
            }
        }
        
        
        
        function newSkeletonHelper(theMesh){
        //  Create the skeleton helper debug visualization
			var helper = new THREE.SkeletonHelper(theMesh);
			helper.material.linewidth = 5;
			helper.name = "ARMATURE_HELPER";
			helper.visible = true;
			return helper;
        }

        
        
        function showhideHelper(theHelper){
            theHelper.visible = !theHelper.visible;
        }
        
        
        
        //////////////////////////// start of resets ////////////////////////////



        function deepCopy(obj) {
            if (Object.prototype.toString.call(obj) === "[object Array]") {
                var out = [], i = 0, len = obj.length;
                for ( ; i < len; i++ ) {
                    out[i] = arguments.callee(obj[i]);
                }
                return out;
            }
            if (typeof obj === "object") {
                var out = {}, i;
                for ( i in obj ) {
                    out[i] = arguments.callee(obj[i]);
                }
                return out;
            }
            return obj;
        }

        
        
        function avatarRestPose(theAvatar){
        //  Check if current animation data key exist.
            bcaFrameKeyIndexesArray( animtimerSlider.value );
        
            if (animationDataKeyExist) {
            //  Copy pose from user data.
                for (var i in theAvatar.userData.restPose){
                    animation.data.hierarchy[i].keys[currentAnimationKeyIndex].pos = deepCopy( theAvatar.userData.restPose[i].pos );
                    animation.data.hierarchy[i].keys[currentAnimationKeyIndex].rot.fromArray( theAvatar.userData.restPose[i].rot );
                    animation.data.hierarchy[i].keys[currentAnimationKeyIndex].scl = deepCopy( theAvatar.userData.restPose[i].scl );
                }
            //  Play the frame.
                timescaleSlider.value = 0;
                animation.play( animation.currentTime );
            //
                theAvatar.visible = true;
                armatureHelper.visible = false;
                console.log("Animation data key reseted to rest pose.");
            }
            else if (!animationDataKeyExist){
                console.log("Current animation data key does not exists.", "You can not reset to rest pose.");
            }
            newCurrentBoneSelected();
        }
        
        
        
        function bonesResetPosition(theAvatar){
        //  Check if current animation data key exist.
            bcaFrameKeyIndexesArray( animtimerSlider.value );
            
            if (animationDataKeyExist) {
            //  Reset bones position values from user data.
                for (var i in theAvatar.userData.restPose){
                    animation.data.hierarchy[i].keys[currentAnimationKeyIndex].pos = deepCopy( theAvatar.userData.restPose[i].pos );
                }
            //  Play the frame.
                timescaleSlider.value = 0;
                animation.play( animation.currentTime );
            //
                theAvatar.visible = true;
                armatureHelper.visible = false;
                console.log("Animation data key positions reseted.");
            }
            else if (!animationDataKeyExist){
                console.log("Current animation data key does not exists.", "You can not reset bones position.");
            }
            newCurrentBoneSelected();
        }
        
        
        
        function bonesResetQuaternion(theAvatar){
        //  Check if current animation data key exist.
            bcaFrameKeyIndexesArray( animtimerSlider.value );
            
            if (animationDataKeyExist) {
            //  Reset bones position values from user data.
                for (var i in theAvatar.userData.restPose){
                    animation.data.hierarchy[i].keys[currentAnimationKeyIndex].rot.fromArray( theAvatar.userData.restPose[i].rot );
                }
            //  Play the frame.
                timescaleSlider.value = 0;
                animation.play( animation.currentTime );
            //
                theAvatar.visible = true;
                armatureHelper.visible = false;
                console.log("Animation data key rotations reseted.");
            }
            else if (!animationDataKeyExist){
                console.log("Current animation data key does not exists.", "You can not reset bones rotation.");
            }
            newCurrentBoneSelected();
        }
        
        
        
        
        function bonesResetScale(theAvatar){
        //  Check if current animation data key exist.
            bcaFrameKeyIndexesArray( animtimerSlider.value );
            
            if (animationDataKeyExist) {
            //  Reset bones position values from user data.
                for (var i in theAvatar.userData.restPose){
                    animation.data.hierarchy[i].keys[currentAnimationKeyIndex].scl = deepCopy( theAvatar.userData.restPose[i].scl );
                }
            //  Play the frame.
                timescaleSlider.value = 0;
                animation.play( animation.currentTime );
            //
                theAvatar.visible = true;
                armatureHelper.visible = false;
                console.log("Animation data key scales reseted.");
            }
            else if (!animationDataKeyExist){
                console.log("Current animation data key does not exists.", "You can not reset bones scale.");
            }
            newCurrentBoneSelected();
        }
        
        
    ///////////////////////////// end of resets /////////////////////////////
        
        
    //  TODO: TO FIX deletePoseHierarchyKey() function

        function deleteCurrentAnimationDataKey(){
        //  Check if current animation data key exist.
            bcaFrameKeyIndexesArray( animtimerSlider.value );
            
            if ( animationDataKeyExist ){
                for (var i in animation.data.hierarchy){
                    var removedItems = 1;
                    animation.data.hierarchy[i].keys.splice( currentAnimationKeyIndex, removedItems );
                }
                console.log("Current animation data key deleted.");
            //
                ensureLooping();
                ensureKeysIndexing();
                
            //  Update current animation index key.
                bcaFrameKeyIndexesArray( animtimerSlider.value );
                
            //  Play the frame.
                timescaleSlider.value = 0;
                animation.play( animation.currentTime );
            }
            
            else if (!animationDataKeyExist){
                console.log("Current animation data key does not exists.", "Delete animation pose key aborted.");
            }
            
            newCurrentBoneSelected();
        }
        
        
        
        
        
        
    /////////////////////// animation keys sort by time ////////////////////////
        
        
        
        function changeFrameKeyTimeDebuger(k, t){
            
            for (var i in animation.data.hierarchy){
                animation.data.hierarchy[i].keys[k].time = t;
            }
        }
        
        
        
        function sortAnimationDataKeysByTime(){
            for (var i in animation.data.hierarchy){
            //  Sort animation data keys by time.
                animation.data.hierarchy[i].keys.sort( function(a,b){return parseFloat(a.time) - parseFloat(b.time);} );
            //  Ensure animation data keys indexing.
                for (var j in animation.data.hierarchy[i].keys){
                    animation.data.hierarchy[i].keys[j].index = Number(j);
                }
            }
            console.log("Sorting Animation Data Keys by time with internal Ensure Keys Indexing completed.");
        }
        
        
        
    /////////////////////// start of random IK Poser ////////////////////////
        
        
        
        function randomAnimationDataKeyGenerator(){
        
        //  Check if current animation data key exist.
            bcaFrameKeyIndexesArray( animtimerSlider.value );
            
            if (animationDataKeyExist) {
            //  Generate random bones quaternion values.
                for (var i in animation.data.hierarchy){
                    var euler = new THREE.Euler( randomRad(-180, 180), randomRad(-180, 180), randomRad(-180, 180), "XYZ" );
                    var quaternion = new THREE.Quaternion();
                    quaternion.setFromEuler( euler );
                    animation.data.hierarchy[i].keys[currentAnimationKeyIndex].rot.copy( quaternion );
                }
            }
            else if (!animationDataKeyExist){
                console.log("Current animation data key does not exists.", "You can not generate random pose key.");
            }
            
            newCurrentBoneSelected();
        }
        
        

        function randomRad(min, max) { return THREE.Math.degToRad(THREE.Math.randInt(min, max)) }
        
        
        
        currentCrazyPosesScript = randomPoseGeneratorForMannyTheSkeletonDefaultRigged;

        function randomPoseGeneratorForMannyTheSkeletonDefaultRigged(){
            
        //  Generate the random ik pose for every bone of MannyTheSkeletonDefaultRigged_v04.

            var ik_Base             = new THREE.Euler( randomRad( -30,  50), randomRad( -45,  45), randomRad(   0,   0), "XYZ" );
            var ik_Back             = new THREE.Euler( randomRad(   0,   0), randomRad(   0,   0), randomRad(   0,   0), "XYZ" );
            
            
            var ik_ScapulaRight     = new THREE.Euler( randomRad(  -8,   8), randomRad(  -2,   8), randomRad( -15,   8), "XYZ" );
            var ik_UpperArmRight    = new THREE.Euler( randomRad(-170,  80), randomRad(   0, 100), randomRad(-105,  95), "XYZ" );
            var ik_ForeArmRight     = new THREE.Euler( randomRad( -75,  95), randomRad( -10, 160), randomRad(  -1,   1), "XYZ" );
            var ik_HandRight        = new THREE.Euler( randomRad(  -1,   1), randomRad( -30,  20), randomRad( -40,  70), "XYZ" );
            
            
            var ik_FingersRight     = new THREE.Euler( randomRad(   0,   0), randomRad(   0,   0), randomRad(   0,  80), "XYZ" );
            var ik_Fingers1Right    = new THREE.Euler( randomRad(   0,   0), randomRad(   0,   0), randomRad(   0, 105), "XYZ" );
            var ik_Fingers2Right    = new THREE.Euler( randomRad(   0,   0), randomRad(   0,   0), randomRad(   0, 110), "XYZ" );
            var ik_ThumbRight       = new THREE.Euler( randomRad(   0,   0), randomRad(   0,   0), randomRad(   0,   0), "XYZ" );
            var ik_Thumb1Right      = new THREE.Euler( randomRad( -40,  65), randomRad( -60,  50), randomRad( -50,  50), "XYZ" );
            var ik_Thumb2Right      = new THREE.Euler( randomRad(   0,  90), randomRad(   0,   0), randomRad(   0,   0), "XYZ" );
            
            
            var ik_ScapulaLeft      = new THREE.Euler( randomRad(  -8,   8), randomRad(  -8,   2), randomRad(  -8,  15), "XYZ" );
            var ik_UpperArmLeft     = new THREE.Euler( randomRad(  -8,   8), randomRad(-100,   0), randomRad( -95, 105), "XYZ" );
            var ik_ForeArmLeft      = new THREE.Euler( randomRad( -75,  95), randomRad(-160,  10), randomRad(  -1,   1), "XYZ" );
            var ik_HandLeft         = new THREE.Euler( randomRad(  -1,   1), randomRad( -20,  30), randomRad( -70,  40), "XYZ" );
            
            
            var ik_FingersLeft      = new THREE.Euler( randomRad(   0,   0), randomRad(   0,   0), randomRad( -80,   0), "XYZ" );
            var ik_Fingers1Left     = new THREE.Euler( randomRad(   0,   0), randomRad(   0,   0), randomRad(-105,   0), "XYZ" );
            var ik_Fingers2Left     = new THREE.Euler( randomRad(   0,   0), randomRad(   0,   0), randomRad(-110,   0), "XYZ" );
            var ik_ThumbLeft        = new THREE.Euler( randomRad(   0,   0), randomRad(   0,   0), randomRad(   0,   0), "XYZ" );
            var ik_Thumb1Left       = new THREE.Euler( randomRad( -40,  65), randomRad( -50,  60), randomRad( -50,  50), "XYZ" );
            var ik_Thumb2Left       = new THREE.Euler( randomRad(   0,  90), randomRad(   0,   0), randomRad(   0,   0), "XYZ" );
            
            
            var ik_Chest            = new THREE.Euler( randomRad(  -1,   1), randomRad(  -1,   1), randomRad(  -1,   1), "XYZ" );
            var ik_Hip              = new THREE.Euler( randomRad(-120,  30), randomRad( -50,  50), randomRad( -12,  12), "XYZ" );
            
            
            var ik_HipLeft          = new THREE.Euler( randomRad(  -1,   1), randomRad(  -1,   1), randomRad(  -1,   1), "XYZ" );
            var ik_ThighLeft        = new THREE.Euler( randomRad( -90,   0), randomRad( -90,  25), randomRad( -10,  45), "XYZ" );
            var ik_ShinLeft         = new THREE.Euler( randomRad(  -0, 130), randomRad( -30,  30), randomRad(  -1,   1), "XYZ" );
            var ik_FootLeft         = new THREE.Euler( randomRad( -30,  30), randomRad(  -1,   1), randomRad(  -1,   1), "XYZ" );
            var ik_ToesLeft         = new THREE.Euler( randomRad(  -1,  45), randomRad(  -1,   1), randomRad(  -1,   1), "XYZ" );
            
            
            var ik_HipRight         = new THREE.Euler( randomRad(  -1,   1), randomRad(  -1,   1), randomRad(  -1,   1), "XYZ" );
            var ik_ThighRight       = new THREE.Euler( randomRad( -90,   0), randomRad( -25,  90), randomRad( -45,  10), "XYZ" );
            var ik_ShinRight        = new THREE.Euler( randomRad(  -0, 130), randomRad( -30,  30), randomRad(  -1,   1), "XYZ" );
            var ik_FootRight        = new THREE.Euler( randomRad( -30,  30), randomRad(  -1,   1), randomRad(  -1,   1), "XYZ" );
            var ik_ToesRight        = new THREE.Euler( randomRad(  -1,  45), randomRad(  -1,   1), randomRad(  -1,   1), "XYZ" );
            
            
            var ik_Neck             = new THREE.Euler( randomRad( -15,  30), randomRad( -45,  45), randomRad( -60,  60), "XYZ" );
            var ik_Head             = new THREE.Euler( randomRad( -45,  15), randomRad( -15,  15), randomRad( -15,  15), "XYZ" );
            var ik_Jaw              = new THREE.Euler( randomRad(   0,  50), randomRad(  -3,   3), randomRad(  -4,   4), "XYZ" );
        //
            var bonesIK = [ ik_Base, ik_Back, 
                ik_ScapulaRight, ik_UpperArmRight, ik_ForeArmRight, ik_HandRight, ik_FingersRight, ik_Fingers1Right, ik_Fingers2Right, ik_ThumbRight, ik_Thumb1Right, ik_Thumb2Right,
                ik_ScapulaLeft, ik_UpperArmLeft, ik_ForeArmLeft, ik_HandLeft, ik_FingersLeft, ik_Fingers1Left, ik_Fingers2Left, ik_ThumbLeft, ik_Thumb1Left, ik_Thumb2Left,
                ik_Chest, ik_Hip, ik_HipLeft, ik_ThighLeft, ik_ShinLeft, ik_FootLeft, ik_ToesLeft, ik_HipRight, ik_ThighRight, ik_ShinRight, ik_FootRight, ik_ToesRight,
                ik_Neck, ik_Head, ik_Jaw
            ]
            
        //  Check if current animation data key exist.
            bcaFrameKeyIndexesArray( animtimerSlider.value );
            
            function setAnimationDataKeyRotationFromEuler(euler, idx){
                var quaternion = new THREE.Quaternion();
                quaternion.setFromEuler( euler );
                animation.data.hierarchy[idx].keys[currentAnimationKeyIndex].rot.copy( quaternion );
            }
            
            if (animationDataKeyExist) {
            //  Base - Body.
                if (currentBoneIndex == 0) {
                    for (var i in bonesIK){
                        var quaternion = new THREE.Quaternion();
                        quaternion.setFromEuler( bonesIK[i] );
                        animation.data.hierarchy[i].keys[currentAnimationKeyIndex].rot.copy( quaternion );
                    }
                }
                
            //  Back - Upperbody.
                else if (currentBoneIndex == 1){
                    setAnimationDataKeyRotationFromEuler( bonesIK[1], 1 );
                    setAnimationDataKeyRotationFromEuler( bonesIK[22], 22 );
                    for (var i = 2; i < 12; i++){
                        setAnimationDataKeyRotationFromEuler( bonesIK[i], i );
                    }
                    for (var i = 12; i < 22; i++){
                        setAnimationDataKeyRotationFromEuler( bonesIK[i], i );
                    }
                    for (var i = 34; i < 37; i++){
                        setAnimationDataKeyRotationFromEuler( bonesIK[i], i );
                    }
                    
                }
                
            //  Right upperbody limb.
                else if (currentBoneIndex == 2){
                    setAnimationDataKeyRotationFromEuler( bonesIK[2], 2 );
                    setAnimationDataKeyRotationFromEuler( bonesIK[3], 3 );
                }
                else if (currentBoneIndex == 3){
                    for (var i = 3; i < 12; i++){
                        setAnimationDataKeyRotationFromEuler( bonesIK[i], i );
                    }
                }
                else if (currentBoneIndex == 4){
                    for (var i = 4; i < 6; i++){
                        setAnimationDataKeyRotationFromEuler( bonesIK[i], i );
                    }
                }
                else if (currentBoneIndex == 5){
                    for (var i = 5; i < 12; i++){
                        setAnimationDataKeyRotationFromEuler( bonesIK[i], i );
                    }
                }
                else if (currentBoneIndex == 6){
                    setAnimationDataKeyRotationFromEuler( bonesIK[6], 6 );
                    setAnimationDataKeyRotationFromEuler( bonesIK[7], 7 );
                    setAnimationDataKeyRotationFromEuler( bonesIK[8], 8 );
                }
                else if (currentBoneIndex == 7){
                    setAnimationDataKeyRotationFromEuler( bonesIK[7], 7 );
                }
                else if (currentBoneIndex == 8){
                    setAnimationDataKeyRotationFromEuler( bonesIK[8], 8 );
                }
                else if (currentBoneIndex == 9){
                    setAnimationDataKeyRotationFromEuler( bonesIK[10], 10 );
                    setAnimationDataKeyRotationFromEuler( bonesIK[11], 11 );
                }
                else if (currentBoneIndex == 10){
                    setAnimationDataKeyRotationFromEuler( bonesIK[10], 10 );
                }
                else if (currentBoneIndex == 11){
                    setAnimationDataKeyRotationFromEuler( bonesIK[11], 11 );
                }
                
            //  Left upperbody limb.
                else if (currentBoneIndex == 12){
                    setAnimationDataKeyRotationFromEuler( bonesIK[12], 12 );
                    setAnimationDataKeyRotationFromEuler( bonesIK[13], 13 );
                }
                else if (currentBoneIndex == 13){
                    for (var i = 13; i < 22; i++){
                        setAnimationDataKeyRotationFromEuler( bonesIK[i], i );
                    }
                }
                else if (currentBoneIndex == 14){
                    for (var i = 14; i < 16; i++){
                        setAnimationDataKeyRotationFromEuler( bonesIK[i], i );
                    }
                }
                else if (currentBoneIndex == 15){
                    for (var i = 15; i < 22; i++){
                        setAnimationDataKeyRotationFromEuler( bonesIK[i], i );
                    }
                }
                else if (currentBoneIndex == 16){
                    setAnimationDataKeyRotationFromEuler( bonesIK[16], 16 );
                    setAnimationDataKeyRotationFromEuler( bonesIK[17], 17 );
                    setAnimationDataKeyRotationFromEuler( bonesIK[18], 18 );
                }
                else if (currentBoneIndex == 17){
                    setAnimationDataKeyRotationFromEuler( bonesIK[17], 17 );
                }
                else if (currentBoneIndex == 18){
                    setAnimationDataKeyRotationFromEuler( bonesIK[18], 18 );
                }
                else if (currentBoneIndex == 19){
                    setAnimationDataKeyRotationFromEuler( bonesIK[20], 20 );
                    setAnimationDataKeyRotationFromEuler( bonesIK[21], 21 );
                }
                else if (currentBoneIndex == 20){
                    setAnimationDataKeyRotationFromEuler( bonesIK[20], 20 );
                }
                else if (currentBoneIndex == 21){
                    setAnimationDataKeyRotationFromEuler( bonesIK[21], 21 );
                }
                
            //  Chest.
                else if (currentBoneIndex == 22){
                    for (var i = 1; i < 37; i++){
                        setAnimationDataKeyRotationFromEuler( bonesIK[i], i );
                    }
                }
                
            //  Hip - Lowerbody body.
                else if (currentBoneIndex == 23){
                    setAnimationDataKeyRotationFromEuler( bonesIK[23], 23 );
                    for (var i = 25; i < 29; i++){
                        setAnimationDataKeyRotationFromEuler( bonesIK[i], i );
                    }
                    for (var i = 30; i < 34; i++){
                        setAnimationDataKeyRotationFromEuler( bonesIK[i], i );
                    }
                }
                
            //  Left lowerbody limb.
                else if (currentBoneIndex == 24){
                        setAnimationDataKeyRotationFromEuler( bonesIK[25], 25 );
                }
                else if (currentBoneIndex == 25){
                    for (var i = 25; i < 29; i++){
                        setAnimationDataKeyRotationFromEuler( bonesIK[i], i );
                    }
                }
                else if (currentBoneIndex == 26){
                    for (var i = 26; i < 29; i++){
                        setAnimationDataKeyRotationFromEuler( bonesIK[i], i );
                    }
                }
                else if (currentBoneIndex == 27){
                    for (var i = 27; i < 29; i++){
                        setAnimationDataKeyRotationFromEuler( bonesIK[i], i );
                    }
                }
                else if (currentBoneIndex == 28){
                    setAnimationDataKeyRotationFromEuler( bonesIK[28], 28 );
                }
                
            //  Right lowerbody limb.
                else if (currentBoneIndex == 29){
                        setAnimationDataKeyRotationFromEuler( bonesIK[30], 30 );
                }
                else if (currentBoneIndex == 30){
                    for (var i = 30; i < 34; i++){
                        setAnimationDataKeyRotationFromEuler( bonesIK[i], i );
                    }
                }
                else if (currentBoneIndex == 31){
                    for (var i = 31; i < 34; i++){
                        setAnimationDataKeyRotationFromEuler( bonesIK[i], i );
                    }
                }
                else if (currentBoneIndex == 32){
                    for (var i = 32; i < 34; i++){
                        setAnimationDataKeyRotationFromEuler( bonesIK[i], i );
                    }
                }
                else if (currentBoneIndex == 33){
                    setAnimationDataKeyRotationFromEuler( bonesIK[33], 33 );
                }
                
            //  Neck, Head, Jaw.
                else if (currentBoneIndex == 34){
                    for (var i = 34; i < 37; i++){
                        setAnimationDataKeyRotationFromEuler( bonesIK[i], i );
                    }
                }
                else if (currentBoneIndex == 35){
                    for (var i = 35; i < 37; i++){
                        setAnimationDataKeyRotationFromEuler( bonesIK[i], i );
                    }
                }
                else if (currentBoneIndex == 36){
                        setAnimationDataKeyRotationFromEuler( bonesIK[36], 36 );
                }
                
            //  Libs.
                else {
                    for (var i =  2; i <  6; i++){ setAnimationDataKeyRotationFromEuler( bonesIK[i], i ); }
                    for (var i = 12; i < 16; i++){ setAnimationDataKeyRotationFromEuler( bonesIK[i], i ); }
                    for (var i = 25; i < 29; i++){ setAnimationDataKeyRotationFromEuler( bonesIK[i], i ); }
                    for (var i = 30; i < 34; i++){ setAnimationDataKeyRotationFromEuler( bonesIK[i], i ); }
                    for (var i = 34; i < 37; i++){ setAnimationDataKeyRotationFromEuler( bonesIK[i], i ); }
                }

            }
            
            else if (!animationDataKeyExist){
                console.log("Current animation data key does not exists.", "You can not generate random pose key.");
                alert("Current animation data key does not exists. You can not generate random pose key. Add a new pose key and try again.");
            }
            
        //  bcaFrameKeyIndexesArray( animtimerSlider.value );
            newCurrentBoneSelected();
        }
        


    //////////////////////// end of random IK Poser /////////////////////////
        
        
        
    /////////////////////////// start of animate() //////////////////////////
        
        
        
        function animateAnimatorScene(){
            requestAnimationFrame( animateAnimatorScene );
            renderAnimatorScene();
            frameCount++ ;
            updateAnimatorScene();
            propertiesCapturer();
        }
        

        
        function renderAnimatorScene(){
            renderer.render( scene, camera );
        }
        
        
        
    ////////////////////////// end of animate() ////////////////////////////
        
        
        
    ////////////////////////// event listeners /////////////////////////////


        function onWindowResize() {
            if (animatorContainer == document.getElementById("animator-render-container")){
                
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize( window.innerWidth - 2, window.innerHeight - 2 );
            }
            
            else if (animatorContainer == document.getElementById("pose3d-preview")){
            
                camera.aspect = document.getElementById("pose3d-preview").offsetWidth / document.getElementById("pose3d-preview").offsetHeight;
                camera.updateProjectionMatrix();
                renderer.setSize( document.getElementById("pose3d-preview").offsetWidth - 2, document.getElementById("pose3d-preview").offsetHeight - 2 );
            
            } else {
                
                camera.aspect = 1;
                camera.updateProjectionMatrix();
                renderer.setSize( 256, 256 );
            }
            
            // NOT NEED FOR EDITOR CONTROLS.
            // controls.handleResize(); 
    	}
        
        
        
        function onDocumentMouseMove( event ) {
            mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
           	mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
           	
           	// add code here //
        }

        function onDocumentMouseDown( event ) {
            mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
           	mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
           	
            // add code here //
            
            bcaFrameKeyIndexesArray( animtimerSlider.value );
            newCurrentBoneSelected();
            
            if(playManual.checked){
                timescaleSlider.value = currentSpeed;
                timescaleOutput.value = currentSpeed;
            }
        }
    
    
    
        function onDocumentMouseUp( event ) {
            mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
           	mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
           	
            // add code here //
            
            if(playManual.checked){
                timescaleSlider.value = 0;
                timescaleOutput.value = currentSpeed;
            }
        }



    //////////////////////// end of event listeners ////////////////////////
        
        
    ////////////////////////// start of update() ///////////////////////////
        
        
        
        function updateAnimatorScene() {
            
            var delta = clock.getDelta();
            var	time = clock.getElapsedTime();
            
        //  EDITOR CONTROLS NOT NEED CONTROLS UPDATE.
        
            keyboard.update( delta );
        
        //
        
            if (currentSliderStatus){
            //  Animator Timer slider.
                if (currentSlider == animtimerSlider) {
                    currentOutput.value = currentSlider.value;
                    var t = Number(animtimerSlider.value);
                    
                    if (animation) {
                        timescaleSlider.value = 0;
                        timescaleOutput.value = currentSpeed;
                        playButton.innerHTML = "Play";
                        animation.play(t);
                    }
                    else if (!animation) {
                    //  Find the nearest lower frame-time in animationData.
                        var keysArray = animationData.hierarchy[0].keys;
                        if (keysArray.length > 0){
                            for (var i in keysArray){
                                if ( keysArray[i].time <= t) var keyIdx = Number(i);
                            }
                        //  console.log(keyIdx, "i:", i);
                        //  Adjust bones dimensions to nearest time-frame.
                            for (var j in animationData.hierarchy){
                                var avatarBone = avatar.skeleton.bones[j];
                                var animateKey = animationData.hierarchy[j].keys[keyIdx];
                                avatarBone.position.fromArray(animateKey.pos);
                                avatarBone.quaternion.fromArray(animateKey.rot);
                                avatarBone.scale.fromArray(animateKey.scl);
                            }
                        }
                    }
                    reverseSubmitPositionValue();
                    reverseSubmitStaticRotationValue();
                    reverseSubmitScaleValue();
                }
                
            //  Animation Adjust sliders.
                if (currentSlider == posSliderX || currentSlider == posSliderY || currentSlider == posSliderZ ||
                    currentSlider == rotSliderX || currentSlider == rotSliderY || currentSlider == rotSliderZ ||
                    currentSlider == sclSliderX || currentSlider == sclSliderY || currentSlider == sclSliderZ ){
                    
                        submitNewPositionValue();
                        submitStaticRotationValue();
                        submitNewScaleValue();
                }
                
            //  Animation Adjust Uniform Scale slider.
                if (currentSlider == sclUniformSlider) {
                    submitUniformScaleValue();
                }
                
            //  Animation duration slider.
                if (currentSlider == durSlider) {
                    submitNewDurationValue();
                }
                
            //  Image rotation slider.
                if (currentSlider == imgRotSlider){
                    submitImageRotationValue();
                }
                
            //  Image position slider.
                if (currentSlider == imgPosSlider){
                    //  add function here  //
                }
                
            } else {
                reverseSubmitPositionValue();
                reverseSubmitStaticRotationValue();
                reverseSubmitScaleValue();
            }
        //
        
            if (animation) {
            
            //  Watch currentBoneIndex, currentBone and currentDataBone.
                // currentBoneIndex = bonesDroplist.selectedIndex;
                // currentBone = animation.hierarchy[currentBoneIndex];
                // currentDataBone = animation.data.hierarchy[currentBoneIndex]
                
            //  Watch Animation Timer slider.
                // currentFrameTime = Number(animtimerSlider.value);
                
            //  Get the Before, Current, After (bca) animationData Hierarchy Keys Indexes array.
                // bcaAnimationDataIndexKeys = bcaFrameKeyIndexesArray(animtimerSlider.value);
                // if (bcaAnimationDataIndexKeys[1]) console.log(bcaAnimationDataIndexKeys);
            //
            
            //  Pause.
                if ( Number(timescaleSlider.value) == 0 ) {
                    playButton.innerHTML = "Play";
                    groundHelper.visible = true;
                    axisCustomHelper.visible = true;
                }
                
            //  Play.
                if ( Number(timescaleSlider.value)  > 0 ) {
                    playButton.innerHTML = "Pause";
                    groundHelper.visible = false;
                    axisCustomHelper.visible = false;
                }
                
            //  Play only at mouse down.
                if ( !loopCheckbox.checked ){
                    if (animation.currentTime > animation.data.length){
                        timescaleSlider.value = 0;
                        timescaleOutput.value = currentSpeed;
                        animtimerSlider.value = 0;
                        animtimerOutput.value = 0;
                        animation.currentTime = 0;
                        playButton.innerHTML = "Play";
                        animation.play(0);
                    }
                }

                if (animation.isPlaying){
                    animation.loop = loopCheckbox.checked;
                    animation.fps = Number(fpsSlider.value);
                    animation.timeScale = Number(timescaleSlider.value);
                    animtimerSlider.value = animation.currentTime;
                    animtimerOutput.value = animtimerSlider.value;
                }

            }
            
        //
            
            if (timescaleSlider.value > 0) currentSpeed = Number(timescaleSlider.value);
            
        //
            
            bcaFrameKeyIndexesArray( animtimerSlider.value );
            
            if (animationDataKeyExist) animtimerOutput.style.color = "#f0f";
            else animtimerOutput.style.color = "#fff";
            
            if (armatureHelper) armatureHelper.update();
            
            THREE.AnimationHandler.update( delta );
        }
        
        
        
    ////////////////////////// end of update() //////////////////////////
        
        
        
        //  SCENE COMMON FUNCTIONS.
    
        function newCustomAxisHelper(theScene){
            var group = new THREE.Group();
            theScene.add(group);
            
        //  Lines.
            var geometryAxisXpos = new THREE.Geometry();
            var geometryAxisXneg = new THREE.Geometry();
            var geometryAxisYpos = new THREE.Geometry();
            var geometryAxisYneg = new THREE.Geometry();
            var geometryAxisZpos = new THREE.Geometry();
            var geometryAxisZneg = new THREE.Geometry();
    
            var materialAxisXpos = new THREE.LineBasicMaterial( {color: 0xff0000} );
            var materialAxisXneg = new THREE.LineBasicMaterial( {color: 0x880000} );
            var materialAxisYpos = new THREE.LineBasicMaterial( {color: 0x00ff00} );
            var materialAxisYneg = new THREE.LineBasicMaterial( {color: 0x008800} );
            var materialAxisZpos = new THREE.LineBasicMaterial( {color: 0x0000ff} );
            var materialAxisZneg = new THREE.LineBasicMaterial( {color: 0x000088} );
    
            geometryAxisXpos.vertices.push( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 1200, 0, 0 ) );
            geometryAxisXneg.vertices.push( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3(-1200, 0, 0 ) );
            geometryAxisYpos.vertices.push( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 1200, 0 ) );
            geometryAxisYneg.vertices.push( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0,-1200, 0 ) );
            geometryAxisZpos.vertices.push( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, 1200 ) );
            geometryAxisZneg.vertices.push( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0,-1200 ) );
    
            var lineAxisXpos = new THREE.Line( geometryAxisXpos, materialAxisXpos );
            var lineAxisXneg = new THREE.Line( geometryAxisXneg, materialAxisXneg );
            var lineAxisYpos = new THREE.Line( geometryAxisYpos, materialAxisYpos );
            var lineAxisYneg = new THREE.Line( geometryAxisYneg, materialAxisYneg );
            var lineAxisZpos = new THREE.Line( geometryAxisZpos, materialAxisZpos );
            var lineAxisZneg = new THREE.Line( geometryAxisZneg, materialAxisZneg );
    
            group.add( lineAxisXpos );
            group.add( lineAxisXneg );
            group.add( lineAxisYpos );
            group.add( lineAxisYneg );
            group.add( lineAxisZpos );
            group.add( lineAxisZneg );
            return group;
        }
        
        
        
        function newDirectionalLight(hexcolor, x, y, z, intensity){
            var light = new THREE.DirectionalLight( hexcolor );
            light.position.set( x, y, z );
            light.intensity = intensity;
            return light;
            
        }
        
        
        
        function newGroundHelper(){
            var grid = new THREE.GridHelper( 100, 1, 0x444444, 0x444444 );
            grid.name = "GRID"
            grid.position.y = 0;
            scene.add( grid );
            return grid;
        }
        
        
    //  EVENT LISTENERS.
        
        var animatorContainer = $("#animator-container")[0];
        var sliderTimer = $("#slider-timer")[0];
        var animationPlayButton = $("#animation-play")[0];
        var animationAddButton = $("#animation-add")[0];
        var deleteFramekeyButton = $("#delete-framekey")[0];
        var leftSideContent = $("#left-side-content")[0];
        var rightSideContent = $("#right-side-content")[0];
        var cameraPropertiesPanel = $("#camera-measure-panel")[0];
        var camPropCloseButton = $("#close-button")[0];
        
        animatorContainer.onmouseover = function() { controls.enabled = false; };
        animatorContainer.onmouseout = function() { controls.enabled = true; };
        sliderTimer.onmousedown = function() { staticSliderPressed("timer", true); };
        sliderTimer.onmouseup = function() { staticSliderPressed("timer", false); };
        animationPlayButton.onclick = function() { playAnimation(avatar); };
        animationAddButton.onclick = function() { insertNewAnimateDataTimeFrameKey(); };
        deleteFramekeyButton.onclick = function() { deleteCurrentAnimationDataKey(); };
        leftSideContent.onmouseover = function(){ controls.enabled = false; };
        leftSideContent.onmouseout = function(){ controls.enabled = true; };
        rightSideContent.onmouseover = function(){ controls.enabled = false; };
        rightSideContent.onmouseout = function(){ controls.enabled = true; };
        camPropCloseButton.onclick = function (){ cameraPropertiesPanel.style.display="none"; };
        
        function propertiesCapturer(){
            $("#framer")[0].innerHTML = frameCount;
            $("#cam-pos-x")[0].innerHTML = camera.position.x.toFixed(3);
            $("#cam-pos-y")[0].innerHTML = camera.position.y.toFixed(3);
            $("#cam-pos-z")[0].innerHTML = camera.position.z.toFixed(3);
            $("#cam-rot-x")[0].innerHTML = camera.rotation._x.toFixed(3);
            $("#cam-rot-y")[0].innerHTML = camera.rotation._y.toFixed(3);
            $("#cam-rot-z")[0].innerHTML = camera.rotation._z.toFixed(3);
            $("#cam-quat-w")[0].innerHTML = camera.quaternion._w.toFixed(3);
            $("#cam-quat-x")[0].innerHTML = camera.quaternion._x.toFixed(3);
            $("#cam-quat-y")[0].innerHTML = camera.quaternion._y.toFixed(3);
            $("#cam-quat-z")[0].innerHTML = camera.quaternion._z.toFixed(3);
            $("#cam-far")[0].innerHTML = camera.far;
            $("#cam-fov")[0].innerHTML = camera.fov;
            $("#mouse-x")[0].innerHTML = mouse.x.toFixed(3);
            $("#mouse-y")[0].innerHTML = mouse.y.toFixed(3);
        }
        
        
    //  Timeliner.
    
    //  window.Timeliner = Timeliner;
    //  Initialize timeliner.
    //  timeliner = new Timeliner({});     debugMode && console.log("timeliner:", timeliner);
    //  timeliner.addLayer("position");
    //  timeliner.addLayer("rotation");
    //  timeliner.addLayer("scale");
    
        var target = {
            position: 0,
            rotation: 0,
            scale: 1
        };
    
    //  Initialize timeliner.
        timeliner = new Timeliner( target ); 
//        timeliner.load({
//            "version":"1.3.0",
//            "modified":"Tue Dec 16 2014 10:27:28 GMT+0800 (SGT)",
//            "title":"Untitled",
//            "layers":[
//                {
//                    "name":"a",
//                    "values":[],
//                    "_value":0,
//                    "_color":"#9ab426"
//                }
//            ],
//            "name":"simple"
//        
//        });
        debugMode && console.log("timeliner:", timeliner);
        
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
/*
    //  Text.
        var materialFace = new THREE.MeshBasicMaterial( { color: 0xffffff } );
    	var materialSide = new THREE.MeshBasicMaterial( { color: 0x888888 } );
    	var materialArray = [ materialFace, materialSide ];
        var textMaterial = new THREE.MeshFaceMaterial(materialArray);

        h0Style = {size: 40, height: 2, curveSegments: 10, font: "helvetiker", weight: "normal", style: "normal", bevelThickness: 1, bevelSize: 2, bevelEnabled: false, material: 0, extrudeMaterial: 1}
    	h1Style = { size: 20, height: 1, curveSegments: 10, font: "helvetiker", weight: "normal", style: "normal", bevelThickness: 1, bevelSize: 2, bevelEnabled: false, material: 0, extrudeMaterial: 1 }
    	h2Style = { size: 10, height: 1, curveSegments: 10, font: "helvetiker", weight: "normal", style: "normal", bevelThickness: 1, bevelSize: 2, bevelEnabled: false, material: 0, extrudeMaterial: 1 }
    	h3Style = { size: 5, height: 0.5, curveSegments: 10, font: "helvetiker", weight: "normal", style: "normal", bevelThickness: 1, bevelSize: 2, bevelEnabled: false, material: 0, extrudeMaterial: 1 }

    // "+x"
        var thetext = "+x";
    	var textGeometry = new THREE.TextGeometry( thetext, h1Style );
    	var textMesh = new THREE.Mesh(textGeometry, textMaterial );
    	textGeometry.computeBoundingBox();
    	var textWidth = textGeometry.boundingBox.max.x - textGeometry.boundingBox.min.x;
    	textMesh.scale.set( 2, 2, 5); 
    	textMesh.geometry.center();
    	textMesh.position.set( 900, 20, 0 );
    	textMesh.rotation.x = 0;
    	textMesh.rotation.y = -Math.PI * 0.5;
    	textMesh.rotation.z = 0;
    	group.add(textMesh); 

    // "-x"
        var thetext = "-x";
    	var textGeometry = new THREE.TextGeometry( thetext, h1Style );
    	var textMesh = new THREE.Mesh(textGeometry, textMaterial );
    	textGeometry.computeBoundingBox();
    	var textWidth = textGeometry.boundingBox.max.x - textGeometry.boundingBox.min.x;
    	textMesh.scale.set( 2, 2, 5); 
    	textMesh.geometry.center();
    	textMesh.position.set( -900, 20, 0 );
    	textMesh.rotation.x = 0;
    	textMesh.rotation.y = Math.PI * 0.5;
    	textMesh.rotation.z = 0;
    	group.add(textMesh); 

    // "+z"
        var thetext = "+z";
    	var textGeometry = new THREE.TextGeometry( thetext, h1Style );
    	var textMesh = new THREE.Mesh(textGeometry, textMaterial );
    	textGeometry.computeBoundingBox();
    	var textWidth = textGeometry.boundingBox.max.x - textGeometry.boundingBox.min.x;
    	textMesh.scale.set( 2, 2, 5); 
    	textMesh.geometry.center();
    	textMesh.position.set( 0, 20, 900 );
    	textMesh.rotation.x = 0;
    	textMesh.rotation.y = -Math.PI;
    	textMesh.rotation.z = 0;
    	group.add(textMesh); 

    // "-z"
        var thetext = "-z";
    	var textGeometry = new THREE.TextGeometry( thetext, h1Style );
    	var textMesh = new THREE.Mesh(textGeometry, textMaterial );
    	textGeometry.computeBoundingBox();
    	var textWidth = textGeometry.boundingBox.max.x - textGeometry.boundingBox.min.x;
    	textMesh.scale.set( 2, 2, 5); 
    	textMesh.geometry.center();
    	textMesh.position.set( 0, 20, -900 );
    	textMesh.rotation.x = 0;
    	textMesh.rotation.y = 0;
    	textMesh.rotation.z = 0;
    	group.add(textMesh); 

    // "+y"
        var thetext = "+y";
    	var textGeometry = new THREE.TextGeometry( thetext, h1Style );
    	var textMesh = new THREE.Mesh(textGeometry, textMaterial );
    	textGeometry.computeBoundingBox();
    	var textWidth = textGeometry.boundingBox.max.x - textGeometry.boundingBox.min.x;
    	textMesh.scale.set( 2, 2, 5); 
    	textMesh.geometry.center();
    	textMesh.position.set( 0, 900, 0 );
    	textMesh.rotation.x = Math.PI * 0.5;
    	textMesh.rotation.y = 0;
    	textMesh.rotation.z = 0;
    	group.add(textMesh); 

    // "-y"
        var thetext = "-y";
    	var textGeometry = new THREE.TextGeometry( thetext, h1Style );
    	var textMesh = new THREE.Mesh(textGeometry, textMaterial );
    	textGeometry.computeBoundingBox();
    	var textWidth = textGeometry.boundingBox.max.x - textGeometry.boundingBox.min.x;
    	textMesh.scale.set( 2, 2, 5); 
    	textMesh.geometry.center();
    	textMesh.position.set( 0, -900, 0 );
    	textMesh.rotation.x = -Math.PI * 0.5;
    	textMesh.rotation.y = 0;
    	textMesh.rotation.z = 0;
    	group.add(textMesh); 
*/
    </script>
     

     
        
</body>

</html>
