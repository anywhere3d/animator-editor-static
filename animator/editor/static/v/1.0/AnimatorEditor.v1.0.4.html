<!DOCTYPE html>
<html>

<head>
    
    <title>Animator Editor v.1.0.4</title>
    
    <style id="animator-editor-css">
        html, body { width: 100%; height: 100%; }
        body       { background-color: #ffffff; margin:0; padding:0px; overflow:hidden; font-family:arial, san-serif; }
        canvas     { position:absolute; top:0px; left:0px; widht:100%; height:100%; }
        #close-button { position:absolute; left:4px; top:4px; }
        #help-button  { position:absolute; right:4px; top:4px; }
        #help-icon, 
        #close-icon { top:0px; left:0px; right:0px; height:24px; }
        #animation-editor { position:absolute; top:0px; left:0px; right:0px; bottom:0px; display:block; }
        #animator-render-container {
            position:absolute; top:0px; left:0px; right:0px; bottom:0px; margin:0px; 
            background-color: #000000; overflow:hidden; cursor:arrow; display:block;
        }
        #pauser {
            position:absolute; max-top:40%; min-top:30%; bottom:50%; left:5%; right:5%; padding:0px; margin:auto; 
            color:#ffffff; border: 0.0em solid #ffffff; border-radius:0.1em; 
            font-size:5em; text-align:center; text-vertical-align:middle;
            display:none; opacity:0.7; 
        }
        #animator-container {
            position:absolute; bottom:5px; left:80px; right:80px; height:40px; display:block;
            border:1px solid #ffffff;  border-radius:4px; color:#fff; text-align:left; 
        }
        #label-timer        { position:absolute; left:10px; bottom:5px; font-size:1.5em; }
        #output-timer       { position:absolute; left:70px; bottom:5px; font-size:1.5em; }
        #status-msgr        { position:absolute; left:10px; top:-25px; color:#fff; font-size:0.7em; display:none; }
        #animation-buttons  { position:absolute; top:4px; }
        #animation-play     { position:absolute; left:140px; }
        #animation-add      { position:absolute; left:200px; }
        #delete-framekey    { position:absolute; top:4px; right:4px; }
        #manual-play        { position:absolute; left:290px; bottom:14px; }
        #timer-container    { position:absolute; left:320px; right:120px; top:8px;border:0px solid #ffffff; }
        #time-container,
        #keys-container     { position:absolute; left:320px; right:120px; top:-60px; height:50px; border:0px solid #ffff00; }
        .keymark            { border:2px solid #ff0; border-radius:4px; /* -webkit-transform:translateX( -16px ); */ }
        #bones-adjustment {
            position:absolute; bottom:5px; left:5px; right:5px; height:30px;
            border:1px solid #ffffff;
            color:#fff; text-align:left; font-size:1.5em;
        }
        #droplist-label { position:absolute; right:180px; top:20px; }
        #droplist-bones { position:absolute; top:20px; right:30px; }
        #animator-container-controls { 
            position:absolute; right:10px; top:50px; width:350px; height:680px;
            padding-top:10px; padding-bottom:10px; padding-left:40px; padding-right:40px; 
            background-color:rgba(0,0,0, 0.5); color:#fff; text-align:left; font-size:0.7em;
            border:4px solid #ffffff; border-radius:12px;
            display:block;
        }
        .slider-row    { padding-top:10px;}
        #dims-label    { position:absolute; left:0px; right:0px; top:0px; font-size:1.5em; text-align:center; }
        #position-div  { top:50px; }
        #rotation-div  { top:165px; }
        #scale-uniform-div { top:280px; }
        #scale-div     { top:345px; }
        #animation-div { top:460px; height:180px;}
        #slider-scale-uniform  { position:absolute; left:100px; top:10px; width:53%; }
    /*
        #label-scale-uniform   { position:absolute; left:10px; top:10px; }
        #output-scale-uniform  { position:absolute; top:10px; right:10px; }
    */
        .dimsadjust { 
            position:absolute; left:30px; right:30px;
            padding-top:0px; padding-bottom:10px; 
            padding-left:10px; padding-right:10px; 
            border:1px solid #ffffff; border-radius:8px;
        }
        .dimoutput          { position:absolute; right:10px; font-size:1.5em; overflow:hidden; }
        .dimslider          { position:absolute; left:90px; width:55%; }
        .sclslider          { position:absolute; left:80px; width:58%; }
        .durslider          { position:absolute; left:95px; width:60%; }
        .timerslider        { width:100%; }
        #reset-position     { position:absolute; bottom:-20px; right:0px; }
        #reset-rotation     { position:absolute; bottom:-20px; right:0px; }
        #reset-scale        { position:absolute; bottom:-20px; right:0px; }
        #reset-pose         { position:absolute; bottom:-20px; right:0px; }
        #bones-helper       { position:absolute; bottom:-20px; left:0px; }
        #avatar-helper      { position:absolute; bottom:-20px; left:120px; }
    /*
        #crazy-pose         { position:absolute; bottom:-20px; right:0px; }
    */
        #finetune-down      { position:absolute; bottom:-20px; left:0px; }
        #finetune-text      { position:absolute; bottom:-20px; left:20px; }
        #finetune-up        { position:absolute; bottom:-20px; left:120px; }
        #load-skinned       { position:absolute; top:130px; left:30px; }
        #looper             { position:absolute; bottom:10px; right:10px; }
        #export-buttons     { position:absolute; bottom:-40px; left:5px; display:block; }
        #export-buttons a.button:link    {color:#fff;}
        #export-buttons a.button:visited {color:#888;}
        #export-buttons a.button:hover   {color:#fff;}
        #export-buttons a.button:active  {color:#fff;}
    /*
        #export-data        { position:absolute; }
        #export-pose        { position:absolute; }
        #export-batch       { position:absolute; }
    */
        #animation-importer { position:absolute; top:10px; left:10px; color:#fff;display:block; }
        #poser-importer     { position:absolute; bottom:50px; left:10px; color:#fff; display:block; }
        #test-importer      { position:absolute; top:90px; left:10px; color:#fff; display:none; }
        #pose-animator,
        #data-animator {
            position:fixed; left:35%; top:100px; width:300px; height:600px;
            padding-top:10px; padding-bottom:10px; padding-left:40px; padding-right:40px; 
            background-color:rgba(0,0,0, 0.85); color:#fff; text-align:left; font-size:1.2em;
            border:4px solid #ffffff; border-radius:12px;
            display:none;
        }
        #preview-pose-container,
        #preview-data-container {
            position:absolute; top:60px; left:61px; right:61px; height:256px;
            border:1px solid #0f0; context-align:center;
        }
        #animator-pose-label,
        #animator-data-label { position:absolute; left:30px; top:30px; right:30px; text-align:center }
        #animator-pose-form,
        #animator-data-form  { position:absolute; left:30px; top:340px; right:30px; height:250px; font-size:14px; border:0px solid #fff; }
        #pose-title-div,
        #data-title-div      { position:absolute; top:0px; width:100%; overflow:hidden; }
        #pose-skeleton-div,
        #data-skeleton-div   { position:absolute; top:50px; width:100%; overflow:hidden; }
        #pose-title,
        #data-title,
        #pose-skeleton,
        #data-skeleton { width:100%; }
        #pose-submit,
        #data-submit  { position:absolute; left:100px; bottom:0px; width:120px; }
        #preview-snap { position:absolute; left:125px; bottom:50px; width:120px; display:none; }
    </style>
    
    <style id="side-panels-css">
        * { box-sizing:border-box; -moz-box-sizing:border-box; margin:0px; /*padding:0px;*/ }
        html { color:#000; font-size:13px; background-color:#eee; margin:0px; overflow:hidden; }
        #left-side { left:0px; top:0px; bottom:0px; -webkit-transform:translateX( -380px ); }
    	#right-side { right:0px; top:0px; bottom:0px; -webkit-transform: translateX( 380px ); }
        #left-side, 
        #right-side { 
            color:#eee; font-size:11px; position:absolute;
            background-color:rgba(0,0,0,0.4); width:452px; line-height:1.4em;
            -webkit-transition: -webkit-transform 500ms ease-out;
        }
    	#left-side:hover, 
        #left-side.pinned,
        #right-side:hover, 
        #right-side.pinned { -webkit-transform: translateX(0); }
    	#left-side-content { 
            position:absolute; right:52px; top:0px; left:0px; bottom:0px; 
            padding:20px 20px 20px 20px; overflow:hidden; 
        }
        #right-side-content {
            position:absolute; left:52px; top:40px; right:10px; bottom:80px; 
            padding: 20px 20px 20px 20px; overflow:auto; 
        }
    	#left-side-pinbtn{ 
            position:absolute; top:20px; right:20px; width:32px; height:32px; 
            border:1px solid white; opacity:0.5; border-radius:4px; 
            background-image:url(/anywhere3d/icons/button-chat-remix.png);
            background-repeat:no-repeat; background-position:50% 50%; 
            background-size:contain; cursor:pointer;
            -webkit-transition:opacity 250ms ease-out; 
        }
        #right-side-pinbtn{ 
            position: absolute; top: 20px; left: 20px; width: 32px; height: 32px; 
            border: 1px solid white; opacity:0.5; border-radius: 4px; 
            background-image: url(/anywhere3d/icons/options-panel.png); 
            background-repeat:no-repeat; background-position: 50% 50%; 
            background-size:contain; cursor:pointer;
            -webkit-transition: opacity 250ms ease-out;
        }
        #left-side-pinbtn:hover, 
        #left-side-pinbtn.pinned,
        #right-side-pinbtn:hover, 
        #right-side-pinbtn.pinned { opacity:1; }
    	#hover { opacity:1; }
    	#right-side-content a:link    {color:#fff;}
        #right-side-content a:visited {color:#40f;}
        #right-side-content a:hover   {color:#0f0;}
        #right-side-content a:active  {color:#f00;}
    	/* a { color:white; text-shadow:0 1px 0 rgba(0,0,0,0.5) } */
    	#left-side h1, 
        #right-side h1 { margin-bottom:10px; font-size:14px;}
    	#left-side h2, 
        #right-side h2 { font-size:11px; margin-bottom:5px;}
    	#left-side p, 
        #right-side p  { font-size:13px; }
        .btn-light, 
        .btn-escape, 
        .btn-helper    { width:32px; height:32px; opacity:1; background:rgba(255,255,255,0); }
        .block         { margin-bottom:10px; float:left; width:280px; }
        .button:hover, 
        .button:active { background-position:0px -2px; }

    </style>
  
    <style id="camera-properties-css">
    
        #what-to-do {
            width:auto; height:auto; position:absolute; left:20px; top:80px; right:40px; 
            padding-top:10px; padding-bottom:10px; padding-left:10px; padding-right:10px; 
            background-color:rgba(0,0,0,0.5); color:#fff; text-align:left; font-size:1.2em;
            border:4px solid #ffffff; border-radius:12px; display:block;
        }
        #camera-measure-panel {
            width:auto; height:auto; position:absolute; left:80px; top:60px; 
            padding-top:10px; padding-bottom:10px; padding-left:10px; padding-right:10px; 
            background-color:rgba(0,0,0,0.5); color:#fff; text-align:left; font-size:1em;
            border:4px solid #ffffff; border-radius:12px; display:block;
        }
        .btn-close {
            width:20px; height:20px; position:absolute; right:4px; top:4px; 
            border-width:0px; border-style:solid; border-color:#f00; border-radius:4px;
            background-image: url(icons/sign-error-close.png); 
            background-repeat:no-repeat; background-position: 50% 50%; 
            background-size:contain; cursor:pointer;
        }
        
    </style>

	<link rel="stylesheet" href="css/buttons.css" media="all">
	<link rel="stylesheet" href="css/spinner.css" media="all">
	<link rel="stylesheet" href="css/normalize.css" media="all">
    
    <script src="js/jquery.min.js"></script>

    <!-- threejs libraries -->
    <script src="js/three.js"></script>
    <script src="js/EditorControls.js"></script>
    <script src="js/Detector.js"></script>
    <script src="js/Projector.js"></script>
    <script src="js/KeyboardState.js"></script>
    <script src="js/Animation.js"></script>
    <script src="js/AnimationHandler.js"></script>
    <script src="js/KeyFrameAnimation.js"></script>

    <script>
    
    //  Animator Timer timeliner.
        
    </script>
    
</head>
    
    
<body onload="animatorEditorRuntime();">

    <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-87777501-1', 'auto');
        ga('send', 'pageview');
        ga('set', 'userId', '{{googleAnalytics_userId}}'); // Set the user ID using signed-in user_id.
    </script>
    
    
    <div id="animation-editor" tabindex="-1">
    
        <div id="animator-render-container" tabindex="-1"></div>

        <div id="camera-measure-panel" style="display:none;">
            <div id="close-button" class="btn-close" onclick="hidePanel('camera-measure-panel');"></div><br>
            <li><strong>frame:&nbsp;</strong><span id="framer">value</span></li>
            <br>
            <li><strong>Camera Properties</strong>
                <ul>
                    <li>position&nbsp;x:<span id="cam-pos-x">value</span></li>
                    <li>position&nbsp;y:<span id="cam-pos-y">value</span></li>
                    <li>position&nbsp;z:<span id="cam-pos-z">value</span></li>
                    <br>
                    <li>rotation&nbsp;x:<span id="cam-rot-x">value</span></li>
                    <li>rotation&nbsp;y:<span id="cam-rot-y">value</span></li>
                    <li>rotation&nbsp;z:<span id="cam-rot-z">value</span></li>
                    <br>
                    <li>quaternion&nbsp;w:<span id="cam-quat-w">value</span></li>
                    <li>quaternion&nbsp;x:<span id="cam-quat-x">value</span></li>
                    <li>quaternion&nbsp;y:<span id="cam-quat-y">value</span></li>
                    <li>quaternion&nbsp;z:<span id="cam-quat-z">value</span></li>
                    <br>
                    <li>far:&nbsp;<span id="cam-far">value</span></li>
                    <li>fov:&nbsp;<span id="cam-fov">value</span></li>
                </ul>
            </li>
            <br>
            <li><strong>Mouse Properties</strong>
                <ul>
                    <li>screen&nbsp;x:<span id="mouse-x">value</span></li>
                    <li>screen&nbsp;y:<span id="mouse-y">value</span></li>
                </ul>
            </li>
        </div>

        <div id="animator-container" tabindex="-1">
            <label for="slider-timer" id="label-timer"><strong>time:</strong></label>
            <div id="timer-container">
                <input type="range" min="0" max="3" value="0" class="timerslider" id="slider-timer" step="0.01"> <!-- onmousedown="staticSliderPressed('timer', true);" onmouseup="staticSliderPressed('timer', false);" -->
            </div>
            <div id="time-container" tabindex="-1"></div>
            <div id="keys-container" tabindex="-1"></div>
            <strong><output for="slider-timer" class="timeroutput" id="output-timer">0</output></strong>
            <div id="animation-buttons">
                <a href="#" id="animation-play" class="button">Play</a> <!-- onclick="playAnimation(avatar);" -->
                <a href="#" id="animation-add" class="button">Add Key</a> <!-- onclick="insertNewAnimateDataTimeFrameKey();" -->
            </div>
            <a href="#" id="delete-framekey" class="button">Delete</a> <!-- onclick="deleteCurrentAnimationDataKey();" -->
            <input type="checkbox" id="manual-play" name="manual" checked>
            <div id="status-msgr">Status messager</div>
        </div>

        <div id="left-side">
            <div id="left-side-pinbtn"></div>
            <div id="left-side-content">
            
                <div id="what-to-do" tabindex="-1">
                    <div class="btn-close" onclick="hidePanel('what-to-do');"></div>
                    <h3>What to do</h3><br>
                    <ol>
                        <li>
                            Drag <span style="color:orange;">time slider</span> on buttom of page to set keyframe time possition
                            and press <span style="color:orange;"><b>"Add Key"</b></span><br>button to insert a new keyframe.
                        </li>
                        <li>
                            Open <span style="color:orange;">animator control panel</span> on right of page and select a bone
                            in <span style="color:aqua;"><b>"Selected Bone"</b></span> droplist.<br>
                            Adjust position, rotation or scale using the control sliders.
                            Repeat for as many bones you like.
                        </li>
                        <li>
                            When you are ready, press <span style="color:aqua;"><b>"Play"</b></span> button on bottom left of page.<br><br>
                            <span style="color:gold;"><b>MannyTheSkeleton</b></span> salute you. Enjoy.<br><br>
                        </li>
                    </ol>
                </div>
                
                <div id="animation-importer">
                    <label for="load-data"><strong>Import Animation:&nbsp;</strong></label><br>
                    <input type="file" id="load-data" class="upload" name="loaddata" onchange="importAnimationDataFromJSON();">
                </div>

                <div id="poser-importer">
                    <label for="load-pose"><strong>Import Pose:&nbsp;</strong></label><br>
                    <input type="file" id="load-pose" class="upload" name="loadpose" onchange="importAnimationPoseKeyFromJSON();">
                </div>

                <div id="test-importer">
                    <label for="load-test"><strong>Test Import JSON:&nbsp;</strong></label><br>
                    <input type="file" id="load-test" class="upload" name="loadtest" onchange="importObjectFromJSONfile();">
                </div>
            </div>
        </div>
        
    <!-- Beginning of right side control panel -->
        
        <div id="right-side">
            <div id="right-side-pinbtn"></div>
            <div id="right-side-content"> <!-- onmouseover="controls.enabled=false;" onmouseout="controls.enabled=true;" -->

                <div id="dims-label"><strong>Bone <span id="dims-label-selected-name"></span> Animator</strong></div>
                
                <label for="droplist-bones" id="droplist-label"><strong>Selected Bone:</strong></label>
                
                <select id="droplist-bones" name="BONES" size="1" style="" onchange="newCurrentBoneSelected();">
                    <option value="Armature" selected>Armature</option>
                    <option value="Head">Head</option>
                    <option value="Neck">Neck</option>
                    <option value="Torso">Torso</option>
                    <option value="Hip">Hip</option>
                    <option value="Arms">Arms</option>
                    <option value="Legs">Legs</option>
                </select>

                <div class="dimsadjust" id="position-div">
                    <div class="slider-row">
                        <label for="slider-pos-x">Position <strong>X-axis:</strong></label>
                        <input type="range" min="-9999" max="9999" value="0" class="dimslider" id="slider-pos-x" step="1" onmousedown="dynamicSliderPressed('pos-x', true, 0);" onmouseup="dynamicSliderPressed('pos-x', false, 0);">
                        <strong><output for="slider-pos-x" class="dimoutput" id="output-pos-x">-9999</output></strong>
                    </div>
                    <div class="slider-row">
                        <label for="slider-pos-y">Position <strong>Y-axis:</strong></label>
                        <input type="range" min="-9999" max="9999" value="0" class="dimslider" id="slider-pos-y" step="1" onmousedown="dynamicSliderPressed('pos-y', true, 0);" onmouseup="dynamicSliderPressed('pos-y', false, 0);">
                        <strong><output for="slider-pos-y" class="dimoutput" id="output-pos-y">-9999</output></strong>
                    </div>
                    <div class="slider-row">
                        <label for="slider-pos-z">Position <strong>Z-axis:</strong></label>
                        <input type="range" min="-9999" max="9999" value="0" class="dimslider" id="slider-pos-z" step="1" onmousedown="dynamicSliderPressed('pos-z', true, 0);" onmouseup="dynamicSliderPressed('pos-z', false, 0);">
                        <strong><output for="slider-pos-z" class="dimoutput" id="output-pos-z">-9999</output></strong>
                    </div>
                        <strong> <a href="#"><span id="reset-position" onclick="bonesResetPosition(avatar);">Reset bones position</span></a></strong>
                    
                </div>
                

                <div class="dimsadjust" id="rotation-div">
                    <div class="slider-row">
                        <label for="slider-rot-x">Rotation <strong>X-axis:</strong></label>
                        <input type="range" min="-180" max="180" value="0" class="dimslider" id="slider-rot-x" step="1" onmousedown="staticSliderPressed('rot-x', true);" onmouseup="staticSliderPressed('rot-x', false);">
                        <strong><output for="slider-rot-x" class="dimoutput" id="output-rot-x">-180</output></strong>
                    </div>
                    <div class="slider-row">
                        <label for="slider-rot-y">Rotation <strong>Y-axis:</strong></label>
                        <input type="range" min="-180" max="180" value="0" class="dimslider" id="slider-rot-y" step="1" onmousedown="staticSliderPressed('rot-y', true);" onmouseup="staticSliderPressed('rot-y', false);">
                        <strong><output for="slider-rot-y" class="dimoutput" id="output-rot-y">-180</output></strong>
                    </div>
                    <div class="slider-row">
                        <label for="slider-rot-z">Rotation <strong>Z-axis:</strong></label>
                        <input type="range" min="-180" max="180" value="0" class="dimslider" id="slider-rot-z" step="1" onmousedown="staticSliderPressed('rot-z', true);" onmouseup="staticSliderPressed('rot-z', false);">
                        <strong><output for="slider-rot-z" class="dimoutput" id="output-rot-z">-180</output></strong>
                    </div>
                    <span id="finetune-text">Rotation Fine Tune</span>
                    <strong id="finetune">
                        <a href="#"><span id="finetune-down" onclick="void(0);">&#9668;</span></a>
                        <a href="#"><span id="finetune-up" onclick="void(0);">&#9658;</span></a>                        
                    </strong>
                    <strong><a href="#"><span id="reset-rotation" onclick="bonesResetQuaternion(avatar);">Reset bones rotation</span></a></strong>
                </div>

                <div class="dimsadjust" id="scale-uniform-div">
                    <div class="slider-row">
                        <label for="slider-scale-uniform" id="label-scale-uniform">Scale <strong>XYZ-axes:</strong></label>
                        <input type="range" min="1" max="400" value="1" class="sclslider" id="slider-scale-uniform" step="1" onmousedown="dynamicSliderPressed('scale-uniform', true, 1);" onmouseup="dynamicSliderPressed('scale-uniform', false, 1);">
                        <strong><output for="slider-scale-uniform" class="dimoutput" id="output-scale-uniform">100</output></strong>
                    </div>
                    <strong><a href="#"><span id="reset-scale" onclick="bonesResetScale(avatar);">Reset bones scale</span></a></strong>
                </div>

                <div class="dimsadjust" id="scale-div">
                    <div class="slider-row">
                        <label for="slider-scl-x">Scale <strong>X-axis:</strong></label>
                        <input type="range" min="1" max="400" value="1" class="sclslider" id="slider-scl-x" step="1" onmousedown="dynamicSliderPressed('scl-x', true, 1);" onmouseup="dynamicSliderPressed('scl-x', false, 1);">
                        <strong><output for="slider-scl-x" class="dimoutput" id="output-scl-x">100</output></strong>
                    </div>
                    <div class="slider-row">
                        <label for="slider-scl-y">Scale <strong>Y-axis:</strong></label>
                        <input type="range" min="1" max="400" value="1" class="sclslider" id="slider-scl-y" step="1" onmousedown="dynamicSliderPressed('scl-y', true, 1);" onmouseup="dynamicSliderPressed('scl-y', false, 1);">
                        <strong><output for="slider-scl-y" class="dimoutput" id="output-scl-y">100</output></strong>
                    </div>
                    <div class="slider-row">
                        <label for="slider-scl-z">Scale <strong>Z-axis:</strong></label>
                        <input type="range" min="1" max="400" value="1" class="sclslider" id="slider-scl-z" step="1" onmousedown="dynamicSliderPressed('scl-z', true, 1);" onmouseup="dynamicSliderPressed('scl-z', false, 1);">
                        <strong><output for="slider-scl-z" class="dimoutput" id="output-scl-z">100</output></strong>
                    </div>
                    <strong>
                        <a href="#"><span id="avatar-helper" onclick="showhideHelper(avatar);">Show/Hide Avatar</span></a>
                        <a href="#"><span id="bones-helper" onclick="showhideHelper(armatureHelper);">Show/Hide Bones</span></a>
                        <a href="#"><span id="reset-pose" onclick="avatarRestPose(avatar);">Avatar Rest Pose</span></a>
                    </strong>
                </div>

                <div class="dimsadjust" id="animation-div">
                    <div class="slider-row">
                        <label for="slider-dur"><strong>Duration (sec):</strong></label>
                        <input type="range" min="-100" max="100" value="0" class="durslider" id="slider-dur" step="1" onmousedown="dynamicSliderPressed('dur', true, 0);" onmouseup="dynamicSliderPressed('dur', false, 0);">
                        <strong><output for="slider-dur" class="dimoutput" id="output-dur">2</output></strong>
                    </div>
                    <div class="slider-row">
                        <label for="slider-timescale"><strong>Time Speed(x):</strong></label>
                        <input type="range" min="0" max="2" value="1" class="durslider" id="slider-timescale" step="0.1" oninput="outputUpdate('output-timescale', value);">
                        <strong><output for="slider-timescale" class="dimoutput" id="output-timescale">1</output></strong>
                    </div>
                    <div class="slider-row">
                        <label for="slider-fps"><strong>Animation fps:</strong></label>
                        <input type="range" min="0" max="60" value="30" class="durslider" id="slider-fps" step="1" oninput="outputUpdate('output-fps', value);">
                        <strong><output for="slider-fps" class="dimoutput" id="output-fps">30</output></strong>
                    </div>
                    <div class="slider-row">
                        <label for="animation-name"><strong>Animation Name:&nbsp;&nbsp;</strong></label>
                        <input type="text" class="dimoutput" id="animation-name" name="animation" maxLength="128" placeholder="animation name (required)" value="new animation" required="true" onchange="submitAnimationName();">
                    </div>
                    <div class="slider-row">
                        <label for="load-skinned"><strong>Load&nbsp;Skinned&nbsp;Mesh:&nbsp;</strong></label>
                        <input type="file" id="load-skinned" class="button" name="loadskinned" onchange="loadJsonSkinnedAnimatedMesh(event);">
                        <div id="looper">
                            <label for="animation-loop"><strong>Loop&nbsp;</strong></label>
                            <input type="checkbox" id="animation-loop" name="loop" checked="true">
                        </div>
                    </div>
                    <div id="export-buttons">
                        <a href="#" id="export-data" class="button" onclick="saveJSONtoFile( exportAnimationDataAsJSON() );">Export JSON</a>
                        <a href="#" id="export-pose" class="button" onclick="saveJSONtoFile( exportAnimationPoseAsJSON() );">Export Pose</a>
                        <a href="#" id="export-batch" class="button" onclick="void(0);">Batch...</a>
                        <a href="#" id="crazy-pose" class="button" onmousedown="staticSliderPressed('timer', true);" onmouseup="staticSliderPressed('timer', false);" onclick="currentCrazyPosesScript();">Random Pose</a>
                    </div>                    
                </div>

            </div>
        </div>  
        
    <!-- End of right side control panel -->

    </div>


    <script>
        window.debugMode = true;
        
        rightSidePinBtn = $("#right-side-pinbtn")[0];
        leftSidePinBtn = $("#left-side-pinbtn")[0];
        
        rightSidePinBtn.pinned = false;
        rightSidePinBtn.onclick = function(){ 
            this.pinned = !this.pinned; 
            this.classList.toggle( "pinned", this.pinned );
        	this.parentElement.classList.toggle( "pinned", this.pinned );
        };
        leftSidePinBtn.pinned = false;
        leftSidePinBtn.onclick = function(){ 
            this.pinned = !this.pinned; 
            this.classList.toggle( "pinned", this.pinned );
        	this.parentElement.classList.toggle( "pinned", this.pinned );
        };
        
        var HtmlCollection = document.all;
        for (var i=0; i < HtmlCollection.length; i++) {
            HtmlCollection[i].tabindex = -1;
        }
        
        function hidePanel( id ){
            $("#" + id)[0].style.display = "none";
        }
        
        function showPanel( id ){
            $("#" + id)[0].style.display = "";
        }
    </script>

    <script>
        
    //  Simple add event.
        
        function addEventSimple(obj,evt,fn) {
        	if (obj.addEventListener)
        		obj.addEventListener(evt,fn,false);
        	else if (obj.attachEvent)
        		obj.attachEvent('on'+evt,fn);
        }
        
        function removeEventSimple(obj,evt,fn) {
        	if (obj.removeEventListener)
        		obj.removeEventListener(evt,fn,false);
        	else if (obj.detachEvent)
        		obj.detachEvent('on'+evt,fn);
        }
        
        
    //  Key drag&drop object.
        keyDragDrop = {
        	keyHTML: "<a href='#' class='keyLink'></a>",
        	keySpeed: 1, // pixels per keypress event
        	initialMouseX: undefined,
        	initialMouseY: undefined,
        	startX: undefined,
        	startY: undefined,
        	dXKeys: undefined,
        	dYKeys: undefined,
        	draggedObject: undefined,
        	
        	initElement: function (element) {
        		if (typeof element == "string")
        			element = document.getElementById(element);
        		element.onmousedown = keyDragDrop.startDragMouse;
        		element.innerHTML += keyDragDrop.keyHTML;
        		var links = element.getElementsByTagName("a");
        		var lastLink = links[links.length-1];
        		lastLink.relatedElement = element;
        		lastLink.onclick = keyDragDrop.startDragKeys;
        	},
        	startDragMouse: function (e) {
        		keyDragDrop.startDrag(this);
        		var evt = e || window.event;
        		keyDragDrop.initialMouseX = evt.clientX;
        		keyDragDrop.initialMouseY = evt.clientY;
        		addEventSimple(document,"mousemove",keyDragDrop.dragMouse);
        		addEventSimple(document,"mouseup",keyDragDrop.releaseElement);
        		return false;
        	},
        	startDragKeys: function () {
        		keyDragDrop.startDrag(this.relatedElement);
        		keyDragDrop.dXKeys = keyDragDrop.dYKeys = 0;
        		addEventSimple(document,"keydown",keyDragDrop.dragKeys);
        		addEventSimple(document,"keypress",keyDragDrop.switchKeyEvents);
        		this.blur();
        		return false;
        	},
        	startDrag: function (obj) {
        		if (keyDragDrop.draggedObject)
        			keyDragDrop.releaseElement();
        		keyDragDrop.startX = obj.offsetLeft;
        		keyDragDrop.startY = obj.offsetTop;
        		keyDragDrop.draggedObject = obj;
        		obj.className = "dragged";
        	},
        	dragMouse: function (e) {
        		var evt = e || window.event;
        		var dX = evt.clientX - keyDragDrop.initialMouseX;
        		var dY = evt.clientY - keyDragDrop.initialMouseY;
        		keyDragDrop.setPosition(dX,dY);
        		return false;
        	},
        	dragKeys: function(e) {
        		var evt = e || window.event;
        		var key = evt.keyCode;
        		switch (key) {
        			case 37:	// left
        			case 63234:
        				keyDragDrop.dXKeys -= keyDragDrop.keySpeed;
        				break;
        			case 38:	// up
        			case 63232:
        				keyDragDrop.dYKeys -= keyDragDrop.keySpeed;
        				break;
        			case 39:	// right
        			case 63235:
        				keyDragDrop.dXKeys += keyDragDrop.keySpeed;
        				break;
        			case 40:	// down
        			case 63233:
        				keyDragDrop.dYKeys += keyDragDrop.keySpeed;
        				break;
        			case 13: 	// enter
        			case 27: 	// escape
        				keyDragDrop.releaseElement();
        				return false;
        			default:
        				return true;
        		}
        		keyDragDrop.setPosition(keyDragDrop.dXKeys,keyDragDrop.dYKeys);
        		if (evt.preventDefault)
        			evt.preventDefault();
        		return false;
        	},
        	setPosition: function (dx,dy) {
        	    if ( keyDragDrop.startX + dx > 0 && keyDragDrop.startX + dx < document.getElementById("keys-container").offsetWidth - keyDragDrop.draggedObject.offsetWidth){
        	        var x = (keyDragDrop.startX + dx) / (document.getElementById("keys-container").offsetWidth - keyDragDrop.draggedObject.offsetWidth);
        	        
        	        if (x < 0) {
                        x = 0;
                    }
        	        else if (x > document.getElementById("keys-container").offsetWidth - keyDragDrop.draggedObject.offsetWidth) {
                        x = 1;
                    }
                    
                 // Round x to second fractal digit;
                    x = 100 * Math.round(x * 10000)/10000;
                 
                    keyDragDrop.draggedObject.style.left = x + "%";
           		}
        		//  keyDragDrop.draggedObject.style.top = keyDragDrop.startY + dy + 'px';
        	},
        	switchKeyEvents: function () {
    		// for Opera and Safari 1.3
        		removeEventSimple(document,'keydown',keyDragDrop.dragKeys);
        		removeEventSimple(document,'keypress',keyDragDrop.switchKeyEvents);
        		addEventSimple(document,'keypress',keyDragDrop.dragKeys);
        	},
        	releaseElement: function() {
        		removeEventSimple(document,'mousemove',keyDragDrop.dragMouse);
        		removeEventSimple(document,'mouseup',keyDragDrop.releaseElement);
        		removeEventSimple(document,'keypress',keyDragDrop.dragKeys);
        		removeEventSimple(document,'keypress',keyDragDrop.switchKeyEvents);
        		removeEventSimple(document,'keydown',keyDragDrop.dragKeys);
        		keyDragDrop.draggedObject.className = keyDragDrop.draggedObject.className.replace(/dragged/, "keymark");
        		keyDragDrop.draggedObject = undefined;
        	}
        }

    </script>
    

    <script>

        function importObjectFromJSONfile(){
            debugMode && console.log("Importing data object from JSON file.");
            
        //  JSON TEXT CONTENTS READER.
            var reader = new FileReader();
            
        //  FileList object.
            var file = event.target.files[0];
            var filename = file.name;
            var extension = filename.split( '.' ).pop().toLowerCase();
            var name = filename.split( '.' )[0];
            
            debugMode && console.log("file:", file);
            debugMode && console.log("filename:", filename);
    		debugMode && console.log("extension:", extension);
    		debugMode && console.log("name:", name);

        //  Read json file as a text string.
            reader.readAsText(file);
            
        //  When reading competed...
            var contents, dataObject;
            reader.onloadend = function( event ){
                contents = event.target.result;
                debugMode && console.log("JSON contents readed as text string.", contents);
                dataObject = JSON.parse( contents );
                debugMode && console.log("JSON contents parsed as data:", dataObject);
            //  ...............................................................  //
            //                                                                   //
            //          Add code what to do with json data here.                 //
            //                                                                   //
            //  ...............................................................  //
                debugMode && console.log("Importing json object from JSON file completed.");
            };
        }

        function importAnimationDataFromJSON(){
            debugMode && console.log("Importing animation data object from JSON file.");
            var inputfile = document.getElementById("load-data");
            
       //  JSON TEXT CONTENTS READER.
            var reader = new FileReader();
            
        //  FileList object.
            var file = event.target.files[0];
            var filename = file.name;
            var extension = filename.split( '.' ).pop().toLowerCase();
            var name = filename.split( '.' )[0];
            
        //  Read json file as a text string.
            reader.readAsText(file);
            
        //  When reading competed...
            var contents, dataObject;
            reader.onloadend = function( event ){
                contents = event.target.result;
                dataObject = JSON.parse( contents );
				debugMode && console.log("animation dataObject:", dataObject);
				
            //  Replace the animation.
                THREE.AnimationHandler.animations = [];
                animation = new THREE.Animation( avatar, dataObject );
                animation.currentTime = 0;
                durOutput.value = animation.data.length;
                animtimerSlider.max = animation.data.length;
                timescaleSlider.value = 0;
                nameAnimField.value = animation.data.name;
                // animation.isPlaying = true;
                animation.play(0);
                playButton.innerHTML = "Play";
            //
                debugMode && console.log("Animation created:", animation);
            };
        }

        function importAnimationPoseKeyFromJSON(){
            debugMode && console.log("Importing animation pose keys from JSON file.");
            var inputfile = document.getElementById("load-pose");
            
        //  JSON TEXT CONTENTS READER.
            var reader = new FileReader();
            
        //  FileList object.
            var file = event.target.files[0];
            var filename = file.name;
    		var extension = filename.split( '.' ).pop().toLowerCase();
    		var name = filename.split( '.' )[0];
    		
    		debugMode && console.log("file:", file);
    		debugMode && console.log("filename:", filename);
    		debugMode && console.log("extension:", extension);
    		debugMode && console.log("name:", name);
            
//      1. First we read json file as text.

        //  Read json file as a text string.
            reader.readAsText(file);
            
        //  When reading competed...
            reader.onloadend = function(event){
                //debugMode && console.log(event.target.result);
                var contents = event.target.result;
            //  Pose Json data for pose animation collection input.
                var PoseJsonData = event.target.result;
                //debugMode && console.log("contents:", contents);
                debugMode && console.log("json contents readed as text string.");
                
//      2. Then we parse json string as json data with JSON parser.
            //  Parse json contents string as json data.
                var poseArray = JSON.parse( contents );
                debugMode && console.log("json contents parsed as poseArray:", poseArray);

				bcaFrameKeyIndexesArray( animtimerSlider.value );
				if (animationDataKeyExist){
    			//  Replace key if exist.
                    for (var i in poseArray){
                        animation.data.hierarchy[i].keys[currentAnimationKeyIndex].pos = poseArray[i].pos;
                        animation.data.hierarchy[i].keys[currentAnimationKeyIndex].rot.fromArray(poseArray[i].rot);
                        animation.data.hierarchy[i].keys[currentAnimationKeyIndex].scl = poseArray[i].scl;
                    }
                    debugMode && console.log("Animation pose key", currentAnimationKeyIndex, "replaced at", animtimerSlider.value, "sec.", animation.data.hierarchy);
    			}
    			else if (!animationDataKeyExist) {
    			//  Insert key if not exists.
                    var b = bcaAnimationDataIndexKeys[0];
                    var c = bcaAnimationDataIndexKeys[1];
                    var a = bcaAnimationDataIndexKeys[2];
                    if ( b &&  a ) { idx = b; spl = a; }          // splice to next key index.
                    else if (!b &&  a) { idx = 0; spl = a; }      // splice to next key index.
                    else if ( b && !a) { idx = b; spl = b + 1; }  // push to end of keys array.
                    else if (!b && !a) { idx = 0; spl = 0; }      // keys array is empty. unshift to beginning of keys array.
                    
                    for (var i in animation.data.hierarchy){
                        var newKey = {"index":spl, "pos":[], "rot":new THREE.Quaternion(), "scl":[], "time":Number(animtimerSlider.value)};
                        newKey.pos = poseArray[i].pos;
                        newKey.rot.fromArray(poseArray[i].rot);
                        newKey.scl = poseArray[i].scl;
                    //  Add new key in animation data hierarchy keys array.
                        if (spl < animation.data.hierarchy[i].keys.length) 
                            animation.data.hierarchy[i].keys.splice(spl, 0, newKey);      // add new key before the after key.
                        else animation.data.hierarchy[i].keys.push(newKey);               // add new key at end of keys array.
                    //  Ensure keys indexing.
                        for (var j in animation.data.hierarchy[i].keys){
                            animation.data.hierarchy[i].keys[j].index = Number(j);
                        }
                    }
                    debugMode && console.log("New animation data key imported at", animtimerSlider.value, "sec.", animation.data.hierarchy);
                }
                ensureLooping();
                ensureKeysIndexing();
                bcaFrameKeyIndexesArray( animtimerSlider.value );
                debugMode && console.log("Animation pose key completed.");
                
                animation.isPlaying = true;
                timescaleSlider.value = 0;
                animation.play( animation.currentTime );
                playButton.innerHTML = "Play";
                
            //  Update bca indexes to get the new currentAnimationKeyIndex.
                bcaFrameKeyIndexesArray( animtimerSlider.value );
            //  Get currentAnimationKeyIndex and then define currentAnimationKeyObject.
                newCurrentBoneSelected();
            };
        }

        function exportAnimationDataAsJSON(){
            debugMode && console.log("Exporting animation data as JSON.");
            ensureLooping();
            ensureKeysIndexing();
            bcaFrameKeyIndexesArray( animtimerSlider.value );
            
            var jsonExport;
            if (animationDataKeyExist) {
                var dataExport = {"name":"", "fps":0, "length":0, "hierarchy":[]}
                dataExport.name = animation.data.name;
                dataExport.fps = animation.data.fps;
                dataExport.length = animation.data.length;
                
                for (var i in animation.data.hierarchy){
                    var keysExport = {keys:[]}
                    for (var j in animation.data.hierarchy[i].keys){
                        var key = {"pos":[], "rot":[], "scl":[], "time":0};
                        key.pos = animation.data.hierarchy[i].keys[j].pos;
                        key.rot = animation.data.hierarchy[i].keys[j].rot.toArray();
                        key.scl = animation.data.hierarchy[i].keys[j].scl;
                        key.time = animation.data.hierarchy[i].keys[j].time;
                        keysExport.keys.push(key);
                    }
                    dataExport.hierarchy.push(keysExport);
                }
                debugMode && console.log(dataExport);
            //
                jsonExport = JSON.stringify(dataExport);
                debugMode && console.log(jsonExport);
            //
                alert("Animation data exported succesfully.");
            }
            else {
                var a = "Current animation data key does not exists.";
                var b = "You can not export animation data.";
                debugMode && console.log(a, b, "\n" + jsonExport, "returned.");
                alert(a + "\n" + b);
            }
            return jsonExport;
        }

        function exportAnimationPoseAsJSON(){
            debugMode && console.log("Exporting animation key Pose as JSON.");
            var poseExport = [];
            for (var i in animation.hierarchy) {
            //  Create a new animation data key with current time bones values.
            //  var poseKey = {"index":0, "pos":[], "rot":[], "scl":[], "time":0};
                var poseKey = {"pos":[], "rot":[], "scl":[]};
            //  Get bones values at current time from animation.hierarchy.
                poseKey.pos = animation.hierarchy[i].position.toArray();
                poseKey.rot = (animation.hierarchy[i].quaternion).toArray();
                poseKey.scl = animation.hierarchy[i].scale.toArray();
                poseExport.push(poseKey);
            }
            poseExport = JSON.stringify(poseExport);
            debugMode && console.log(poseExport);
            alert("Animation pose exported succesfully.");
            return poseExport;
        }

        function exportAnimationExistedKeyPoseAsJSON(keyIdx){
            debugMode && console.log("Exporting animation existed key Pose as JSON.");
            // ensureLooping();
            ensureKeysIndexing();
            bcaFrameKeyIndexesArray( animtimerSlider.value );
            
            if (animationDataKeyExist) {
                var poseExport = [];
                for (var i in animation.data.hierarchy){
                //  poseExport.push(animation.data.hierarchy[i].keys[currentAnimationKeyIndex])
                    var poseKey = {"pos":[], "rot":[], "scl":[]};
                //  Get bones values at current time from animation.data.hierarchy.
                    poseKey.pos = animation.data.hierarchy[i].keys[keyIdx].pos;
                    poseKey.rot = animation.data.hierarchy[i].keys[keyIdx].rot.toArray();
                    poseKey.scl = animation.data.hierarchy[i].keys[keyIdx].scl;
                    poseExport.push(poseKey);
                }
                poseExport = JSON.stringify(poseExport);
                debugMode && console.log(poseExport);
                return poseExport;
            }
            else if (!animationDataKeyExist) {
                debugMode && console.log("Current animation data key does not exists.", "You can not export animation pose keys.");
                return undefined;
            }
        }

        function saveJSONtoFile(jsonData){
            if (jsonData){
                var blob = new Blob([jsonData], {type: "application/json"});
                var url  = URL.createObjectURL(blob);
                var a = document.createElement("a");
                
                a.download = "exported json.txt";
                a.href = url;
                a.onclick = destroyClickedElement;
                a.style.display = "none";
                document.body.appendChild(a);
                a.click();
            }
        }
        
        
        function destroyClickedElement(event) {
        	document.body.removeChild(event.target);
        }

    </script>
        
        
        
    <script>
        
    //  Current slider and bone.
        currentSliderStatus = false;            // boolean
        currentSpeed = 1;                       // number slider value
        currentSlider = undefined;              // slider element
        currentOutput = undefined;              // output element
        currentBoneIndex = undefined;           // number for animation.hierarchy[currentBoneIndex]
        currentBone = undefined;                // object animation.hierarchy[currentBoneIndex]
        currentDataBone = undefined;            // object animation.data.hierarchy[currentBoneIndex]
        currentAnimationKeyIndex = undefined;   // number for animation.data.hierarchy[currentBoneIndex].keys[currentAnimationKeyIndex]
        currentAnimationKeyObject = undefined;  // object animation.data.hierarchy[currentBoneIndex].keys[currentAnimationKeyIndex]
        currentFrameTime = undefined;           // number Number( document.getElementById("slider-timer").value )
        animationDataKeyExist = false;          // boolean
        bcaAnimationDataIndexKeys = [undefined, undefined, undefined];
        
    //  Define an empty script for random pose generator button.
        function currentCrazyPosesScript(){};   // script for random pose generator.
    //  How it is works: When we change avatar from Animator-Avatars menu, we parse also the assocciated random poses function in currentCrazyPosesScript function.
    //  When we click the Random Pose button we call the currentCrazyPosesScript() function that is the assocciated random poses function for the selected avatar.
    //  Do not forget that it is important to parse the assocciated random pose avatar function in menu Animator-Avatars-[the selected avatar] menu item.
        
        
        bonesDroplist = document.getElementById("droplist-bones");
        
    //  Position sliders.
        posSliderX = document.getElementById("slider-pos-x");
        posSliderY = document.getElementById("slider-pos-y");
        posSliderZ = document.getElementById("slider-pos-z");
        posOutputX = document.getElementById("output-pos-x");
        posOutputY = document.getElementById("output-pos-y");
        posOutputZ = document.getElementById("output-pos-z");
        
    //  Rotation sliders.
        rotSliderX = document.getElementById("slider-rot-x");
        rotSliderY = document.getElementById("slider-rot-y");
        rotSliderZ = document.getElementById("slider-rot-z");
        rotOutputX = document.getElementById("output-rot-x");
        rotOutputY = document.getElementById("output-rot-y");
        rotOutputZ = document.getElementById("output-rot-z");
        
    //  Uniform Scale slider.
        sclUniformSlider = document.getElementById("slider-scale-uniform");
        sclUniformOutput = document.getElementById("output-scale-uniform");
        
    //  Scale sliders.
        sclSliderX = document.getElementById("slider-scl-x");
        sclSliderY = document.getElementById("slider-scl-y");
        sclSliderZ = document.getElementById("slider-scl-z");
        sclOutputX = document.getElementById("output-scl-x");
        sclOutputY = document.getElementById("output-scl-y");
        sclOutputZ = document.getElementById("output-scl-z");
    //
        durSlider = document.getElementById("slider-dur");
        durOutput = document.getElementById("output-dur");
        timescaleSlider = document.getElementById("slider-timescale");
        timescaleOutput = document.getElementById("output-timescale");
        fpsSlider = document.getElementById("slider-fps");
        nameAnimField = document.getElementById("animation-name");
        loopCheckbox = document.getElementById("animation-loop");
    //
        animtimerSlider = document.getElementById("slider-timer");
        animtimerOutput = document.getElementById("output-timer");
        playButton = document.getElementById("animation-play");
        addButton = document.getElementById("animation-add");
        playManual = document.getElementById("manual-play");
    //
        imgRotSlider = document.getElementById("slider-rot-img-y");
        imgPosSlider = document.getElementById("slider-pos-img-y");
        imgRotOutput = document.getElementById("output-rot-img-y");
        imgPosOutput = document.getElementById("output-pos-img-y");

    //  Initialize manual play.
        playManual.checked = false;
        
    //  Initialize Position sliders.
        var pmin, pmax, pstep;
        pmin = -1; pmax = 1; pstep = 0.01; 
        initSlider(posSliderX, pmin, pmax, pstep);
        initSlider(posSliderY, pmin, pmax, pstep);
        initSlider(posSliderZ, pmin, pmax, pstep);
        
    //  Initialize Static Rotation sliders.
        var rmin, rmax, rstep;
        rmin = -180; rmax = 180; rstep = 1;
        initSlider(rotSliderX, rmin, rmax, rstep);
        initSlider(rotSliderY, rmin, rmax, rstep);
        initSlider(rotSliderZ, rmin, rmax, rstep);
        
    //  Initialize Scale sliders.
        var sclmin, sclmax, sclstep;
        sclmin = 0.99; sclmax = 1.01; sclstep = 0.001;
        initSlider(sclSliderX, sclmin, sclmax, sclstep);
        initSlider(sclSliderY, sclmin, sclmax, sclstep);
        initSlider(sclSliderZ, sclmin, sclmax, sclstep);
        initSlider(sclUniformSlider, sclmin, sclmax, sclstep);
        
    //  Initialize Animation sliders.
        var durmin, durmax, durstep;
        durmin = -0.2; durmax = 0.2; durstep = 0.01;
        initSlider(durSlider, durmin, durmax, durstep);
        
        
        function initSlider(domSlider, min, max, step){
            domSlider.min = min;
            domSlider.max = max;
            domSlider.step = step;
        }
        
        
        
        function outputUpdate(domId, theValue) { document.getElementById(domId).value = theValue; }
        
        
        
        function newCurrentBoneSelected(){ 
            getCurrentBone();           
            initBonesAdjustValues();
        }
        
        
        
        function getCurrentBone(){
        //  var bonesDroplist = document.getElementById("droplist-bones");
            currentBoneIndex = bonesDroplist.selectedIndex;                      // number  //  We can put this line in update().
            currentBone = animation.hierarchy[currentBoneIndex];                 // object  //  We can put this line in update().
            currentDataBone = animation.data.hierarchy[currentBoneIndex];        // object  //  We can put this line in update().
            $("#dims-label-selected-name")[0].innerHTML = currentBone.name;
        }
        
        
        
        function initBonesAdjustValues(){
        
        //  INITIALAZE POSITION OUTPUT VALUES.
            posOutputX.value = currentBone.position.x.toFixed(0);     // string
            posOutputY.value = currentBone.position.y.toFixed(0);     // string
            posOutputZ.value = currentBone.position.z.toFixed(0);     // string
            
        //  INITIALAZE ROTATION OUTPUT VALUES.
            var xrad = currentBone.rotation._x;                       // number rad
            var yrad = currentBone.rotation._y;                       // number rad
            var zrad = currentBone.rotation._z;                       // number rad
        //  Always return first rotation y because of quaternion.
            rotOutputY.value = THREE.Math.radToDeg(yrad).toFixed(0);  // string degrees
            rotOutputX.value = THREE.Math.radToDeg(xrad).toFixed(0);  // string degrees
            rotOutputZ.value = THREE.Math.radToDeg(zrad).toFixed(0);  // string degrees
        //  Always return first rotation y because of quaternion.
            rotSliderY.value = Number(rotOutputY.value);             // number degrees
            rotSliderX.value = Number(rotOutputX.value);             // number degrees
            rotSliderZ.value = Number(rotOutputZ.value);             // number degrees
            
        //  INITIALAZE SCALE OUTPUT VALUES.
            sx = currentBone.scale.x * 100;      // number
            sy = currentBone.scale.y * 100;      // number
            sz = currentBone.scale.z * 100;      // number
            sclOutputX.value = sx.toFixed(1);    // string
            sclOutputY.value = sy.toFixed(1);    // string
            sclOutputZ.value = sz.toFixed(1);    // string
            sclUniformOutput.value = sclOutputY.value;
        //
        //  document.getElementById("animator-container-controls").style.display = "block";
        }
        
        

        function staticSliderPressed(identifier, status){ 
            currentSlider = document.getElementById( "slider-" + identifier );
            currentOutput = document.getElementById( "output-" + identifier );
            currentSliderStatus = status;
            // getCurrentBone();
        }
        
        
        
        function dynamicSliderPressed(identifier, status, restore){ 
            currentSlider = document.getElementById( "slider-" + identifier );
            currentOutput = document.getElementById( "output-" + identifier );
            currentSliderStatus = status;
            currentSlider.value = restore;
            // getCurrentBone();
        }
        
        
        
        function fineTuneSliderUp(slider){
            var n = Number(slider.step);
            slider.stepUp(n);
        }
        
        
        
        function fineTuneSliderDown(){
            var n = Number(slider.step);
            slider.stepDown(n);
        }
        
        
        
        
//////////////////////////////////// start of animation editing ////////////////////////////////////

        
        
        
        var keymarksArray = [];
        
        

        function insertNewAnimateDataTimeFrameKey(){
            
        //  Pause the animation.
            timescaleSlider.value = 0;  
            
        //  Check first if animation key exists. If not, create it. Then set currentAnimationKeyIndex again.
            bcaFrameKeyIndexesArray( animtimerSlider.value );
            var b = bcaAnimationDataIndexKeys[0];
            var c = bcaAnimationDataIndexKeys[1];
            var a = bcaAnimationDataIndexKeys[2];
            
        //  Calculate the index position to insert the new animation data key.
            if (!animationDataKeyExist){
                var idx, spl;
                if ( b &&  a ) { idx = b; spl = a; }          // splice to next key index.
                else if (!b &&  a) { idx = 0; spl = a; }      // splice to next key index.
                else if ( b && !a) { idx = b; spl = b + 1; }  // push to end of keys array.
                else if (!b && !a) { idx = 0; spl = 0; }      // keys array is empty. unshift to beginning of keys array.
                
                for (var i in animation.data.hierarchy){
                
                            /////////////////////////////////////////////////////////////////////////////////////////
                            //  IMPORTANT: animation.data.hierarchy[].keys[].rot WORKS ONLY WITH THREE.Quaternion  //
                            /////////////////////////////////////////////////////////////////////////////////////////
                            
                //  Create a new animation data key with current time bones values at animation.data.hierarchy[i].keys[idx].
                    var newKey = {"index":spl, "pos":[], "rot":new THREE.Quaternion(), "scl":[], "time":Number(animtimerSlider.value)};
                    
                //  Get bones values at current time from animation.hierarchy.
                    newKey.pos = animation.hierarchy[i].position.toArray();
                    newKey.rot.copy(animation.hierarchy[i].quaternion);
                    newKey.scl = animation.hierarchy[i].scale.toArray();
                    
                //  Add new key in animation data hierarchy keys array.
                    if (spl < animation.data.hierarchy[i].keys.length) {
                        animation.data.hierarchy[i].keys.splice(spl, 0, newKey);      // add new key before the after key.
                    } else {
                        animation.data.hierarchy[i].keys.push(newKey);                // add new key at end of keys array.
                    }
                                ///////////////////////////////////////////////////////////////////////////////
                                //  IMPORTANT: Every animation data key object must have "index": property.  //
                                ///////////////////////////////////////////////////////////////////////////////
            
                //  Ensure keys indexing.
                    for (var j in animation.data.hierarchy[i].keys){
                        animation.data.hierarchy[i].keys[j].index = Number(j);
                    }
                }
                debugMode && console.log("New animation data key added at", animtimerSlider.value, "sec.", animation.data.hierarchy[0]);
                
                ensureKeysIndexing();
            }
            
        //  Update bca indexes to get the new currentAnimationKeyIndex.
            bcaFrameKeyIndexesArray( animtimerSlider.value );
            
        //  Get currentAnimationKeyIndex and then define currentAnimationKeyObject.
        //  currentDataBone = animation.data.hierarchy[currentBoneIndex];
            newCurrentBoneSelected();
            
            
        //  Sort animation data keys by time.
            for (var i in animation.data.hierarchy){
                animation.data.hierarchy[i].keys.sort(function(a,b){return parseFloat(a.time) - parseFloat(b.time);})
            }
            
        //  Delete existed keyframes handlers.
            document.getElementById("keys-container").innerHTML = "";
            
        //  Create new indexed keyframes handlers.
            for (var i in animation.data.hierarchy[0].keys){
                newTimeKeyMarker(i);
            }
            
        }

    //  Create Keyframes Handler.

        function newTimeKeyMarker(k){
        //  var v = Number(document.getElementById("slider-timer").value);
            var v = animation.data.hierarchy[0].keys[k].time;
            var m = Number(document.getElementById("slider-timer").max);
            
            var keymark = document.createElement("DIV");
        //  keymark.style.border = "1px solid #ff0";
            keymark.class = "keymark";
            keymark.style.position = "absolute";
            keymark.style.backgroundColor = "#ff0";
            keymark.style.cursor = "pointer";
            keymark.style.color = "#000";
            keymark.style.fontSize = "14px";
            keymark.style.fontWeight = "bold";
        //  keymark.style.minWidth = "1px";
            keymark.style.width = "auto";
            keymark.style.height = "16px";
            keymark.style.top = "10px";
        
            keymark.innerHTML = animation.data.hierarchy[0].keys[k].index.toString();
            var offset = ( 100 * v / m );  var half = ( keymark.offsetWidth / 2 );
            keymark.style.left = offset.toFixed(2) + "%";
            
            debugMode && console.log("keymark style left:", keymark.style.left, "half:", half);

            keymark.addEventListener("mousedown", onkeymarkMouseDown, false);
            keymark.addEventListener("mouseenter", onkeymarkMouseEnter, false);
            keymark.addEventListener("mouseleave", onkeymarkMouseLeave, false);
            
        //  Drag & Drop.
            keyDragDrop.initElement(keymark);
            
            document.getElementById("keys-container").appendChild(keymark);
            
        //  Keymark info.
            var keyinfo = document.createElement("DIV");
            keyinfo.style.position = "absolute";
        //  keyinfo.style.border = "1px solid #fff";
            keyinfo.style.color = "#fff";
            keyinfo.style.fontSize = "12px";
            keyinfo.style.fontWeight = "bold";
            keyinfo.style.top = "-25px";
            keyinfo.style.display = "block";
            keyinfo.innerHTML = animation.data.hierarchy[0].keys[k].time.toFixed(2);
            keyinfo.style.left = "-100%";
            
            keymark.appendChild(keyinfo);
            
            debugMode && console.log("New animation key marker created at", keyinfo.innerHTML, "sec.");
            return [keymark, keyinfo];
        }
        
        
        
        var currentkeymark;
        var currentkeytime;
        var currentkeyindex;
        
        function onkeymarkMouseDown(){ 
            this.style.backgroundColor = "#f00";
            //debugMode && console.log(this);
            currentkeymark = this;
            //debugMode && console.log("currentkeymark:", currentkeymark);
            currentkeytime = this.children[1];
            //debugMode && console.log("currentkeytime:", currentkeytime);
            
        //  Find corresponding Frame key before you add listeners.
            
            for (var i=0; i < document.getElementById("keys-container").children.length; i++){
                if (this == document.getElementById("keys-container").children[i]){
                    currentkeyindex = i;
                    break;
                }
            }
            
            debugMode && console.log("currentkeyindex:", currentkeyindex);
            
        //  Ensure keys index.
        //  ensureKeysIndexing();
            
            document.addEventListener("mousemove", onkeymarkMouseMove, false);
            document.addEventListener("mouseup", onkeymarkMouseUp, false);
            
            var t = (currentkeymark.offsetLeft / keyscontainer.offsetWidth) * ( slidertimer.max );
            
            if (t > Number(slidertimer.max)) {
                t = Number(slidertimer.max);
            }
            t = Number(t.toFixed(2));
            currentkeytime.innerHTML = t;
        }
        
        
        function onkeymarkMouseEnter(){ 
            this.style.backgroundColor = "#0f0"; 
        }
        
        
        function onkeymarkMouseLeave(){ 
            this.style.backgroundColor = "#ff0"; 
        }
        
        
        var slidertimer = document.getElementById("slider-timer");
        var keyscontainer = document.getElementById("keys-container");
        
        
        function onkeymarkMouseMove(){
            //currentkeytime.innerHTML = currentkeytime.parentElement.style.left;
            var t = (currentkeytime.parentElement.offsetLeft / keyscontainer.offsetWidth) * ( slidertimer.max );
            if (t > Number(slidertimer.max)) {
                t = Number(slidertimer.max);
            }
            t = Number(t.toFixed(2));
            currentkeytime.innerHTML = t;
        }
        
        
        function onkeymarkMouseUp(){
            
        //  Update animation.data.hierarchy[i].keys[currentkeyindex].time.
            var t = Number(currentkeytime.innerHTML);
            debugMode && console.log("currentkeytime", "=", t);
            
            for (var i in animation.data.hierarchy){
                animation.data.hierarchy[i].keys[currentkeyindex].time = t;
            //  Sort animation keys by time.
                animation.data.hierarchy[i].keys.sort( function(a,b){
                    return parseFloat(a.time) - parseFloat(b.time);
                })
            }
            
        //  Ensure keys index.
            ensureKeysIndexing();
            
        //  Remove event listeners.
            var keymarks = document.getElementById("keys-container").children;
            debugMode && console.log("keymarks:", keymarks);
            for (var i in keymarks){
                debugMode && console.log("keymarks[", i, "]:", keymarks[i]);
                var keymark = keymarks[i];
                debugMode && console.log("keymark:", keymark);
                if (keymark == keymarks.length) {
                    debugMode && console.log("keymark == keymarks.length:", keymark == keymarks.length);
                    break;
                }
                keymark.removeEventListener("mousedown", onkeymarkMouseDown);
                keymark.removeEventListener("mouseenter", onkeymarkMouseEnter);
                keymark.removeEventListener("mouseleave", onkeymarkMouseLeave);
            }
            debugMode && console.log("==end of loop==");
            
        //  Delete existed keyframes handlers.
            document.getElementById("keys-container").innerHTML = "";
            
        //  Create new indexed keyframes handlers.
            for (var i in animation.data.hierarchy[0].keys){
                newTimeKeyMarker(i);
            }
            
        //  Initialize current key variables.
            currentkeymark = undefined;
            currentkeytime = undefined;
            currentkeyindex = undefined;
            
        //  Remove event listeners.
            document.removeEventListener("mousemove", onkeymarkMouseMove);
            document.removeEventListener("mouseup", onkeymarkMouseUp);
        }
        
    
        
//////////////////////////////////// submit user sliders values ////////////////////////////////////
        
        

        function submitNewPositionValue(){
            
        //  insertNewAnimateDataTimeFrameKey();
            
        //  Submit value to object.
            currentDataBone.keys[currentAnimationKeyIndex].pos[0] += Number( posSliderX.value );     // number
            currentDataBone.keys[currentAnimationKeyIndex].pos[1] += Number( posSliderY.value );     // number
            currentDataBone.keys[currentAnimationKeyIndex].pos[2] += Number( posSliderZ.value );     // number
            
        //  Play the frame.
            timescaleSlider.value = 0;
            animation.play( animation.currentTime );
            
        //  Return value to output.
            posOutputX.value = currentBone.position.x.toFixed(0);     // string
            posOutputY.value = currentBone.position.y.toFixed(0);     // string
            posOutputZ.value = currentBone.position.z.toFixed(0);     // string
        }



        function reverseSubmitPositionValue(){
        //  Return value to output.
            if (animation){
                posOutputX.value = currentBone.position.x.toFixed(0);     // string
                posOutputY.value = currentBone.position.y.toFixed(0);     // string
                posOutputZ.value = currentBone.position.z.toFixed(0);     // string
            }
        }
        
        
        
        function submitNewRotationValue(){
            
        //  insertNewAnimateDataTimeFrameKey();
            
        //  Get rotation from current bone.
            var x = currentBone.rotation._x;
            var y = currentBone.rotation._y;
            var z = currentBone.rotation._z;
            
            x += THREE.Math.degToRad( Number( rotSliderX.value ) );
            y += THREE.Math.degToRad( Number( rotSliderY.value ) );
            z += THREE.Math.degToRad( Number( rotSliderZ.value ) );
            
            var euler = new THREE.Euler(x, y, z, "XYZ");
            
            var quaternion = new THREE.Quaternion();
            
            quaternion.setFromEuler( euler );
            
            currentDataBone.keys[ currentAnimationKeyIndex ].rot.copy( quaternion );
        
        //  Play the frame.
            timescaleSlider.value = 0;
            animation.play( animation.currentTime );
            
        //  Return value to output.
            var xrad = currentBone.rotation._x;                      // number rad
            var yrad = currentBone.rotation._y;                      // number rad
            var zrad = currentBone.rotation._z;                      // number rad
            rotOutputX.value = THREE.Math.radToDeg(xrad).toFixed(0); // string degrees
            rotOutputY.value = THREE.Math.radToDeg(yrad).toFixed(0); // string degrees
            rotOutputZ.value = THREE.Math.radToDeg(zrad).toFixed(0); // string degrees
        }
        
        
        
        function reverseSubmitRotationValue(){
        //  Return value to output.
            if (animation){
                var xrad = currentBone.rotation._x;                      // number rad
                var yrad = currentBone.rotation._y;                      // number rad
                var zrad = currentBone.rotation._z;                      // number rad
                rotOutputX.value = THREE.Math.radToDeg(xrad).toFixed(0); // string degrees
                rotOutputY.value = THREE.Math.radToDeg(yrad).toFixed(0); // string degrees
                rotOutputZ.value = THREE.Math.radToDeg(zrad).toFixed(0); // string degrees
            }
        }
        
        
        
        function submitStaticRotationValue(){
        
        //  insertNewAnimateDataTimeFrameKey();
            var x = THREE.Math.degToRad( Number( rotSliderX.value ) );
            var y = THREE.Math.degToRad( Number( rotSliderY.value ) );
            var z = THREE.Math.degToRad( Number( rotSliderZ.value ) );
            
            var euler = new THREE.Euler(x, y, z, "XYZ");
            var quaternion = new THREE.Quaternion();
            quaternion.setFromEuler( euler );
            currentDataBone.keys[ currentAnimationKeyIndex ].rot.copy( quaternion );
        
        //  Play the frame.
            timescaleSlider.value = 0;
            animation.play( animation.currentTime );
            
        //  Return value to output.
            var xrad = currentBone.rotation._x;                      // number rad
            var yrad = currentBone.rotation._y;                      // number rad
            var zrad = currentBone.rotation._z;                      // number rad
            
        //  Always return first rotation y because of quaternion.
            rotOutputY.value = THREE.Math.radToDeg(yrad).toFixed(0); // string degrees
            rotOutputX.value = THREE.Math.radToDeg(xrad).toFixed(0); // string degrees
            rotOutputZ.value = THREE.Math.radToDeg(zrad).toFixed(0); // string degrees
        }
        
        
        
        function reverseSubmitStaticRotationValue(){
        //  Return value to output.
            if (animation){
                var xrad = currentBone.rotation._x;                      // number rad
                var yrad = currentBone.rotation._y;                      // number rad
                var zrad = currentBone.rotation._z;                      // number rad
                
            //  Always return first rotation y because of quaternion.
                rotOutputY.value = THREE.Math.radToDeg(yrad).toFixed(0); // string degrees
                rotOutputX.value = THREE.Math.radToDeg(xrad).toFixed(0); // string degrees
                rotOutputZ.value = THREE.Math.radToDeg(zrad).toFixed(0); // string degrees
                
            //  Always return first rotation y because of quaternion.
                rotSliderY.value = Number(rotOutputY.value);             // number degrees
                rotSliderX.value = Number(rotOutputX.value);             // number degrees
                rotSliderZ.value = Number(rotOutputZ.value);             // number degrees
            }
        }
        
        
        
        function submitNewScaleValue(){
        
        //  insertNewAnimateDataTimeFrameKey();
            
        //  Submit value to object.
            var sx = Number( sclSliderX.value ); // number
            var sy = Number( sclSliderY.value ); // number
            var sz = Number( sclSliderZ.value ); // number
            sx = Number(sx.toFixed(3));          // number
            sy = Number(sy.toFixed(3));          // number
            sz = Number(sz.toFixed(3));          // number
            
        //  currentDataBone.keys[currentAnimationKeyIndex].scl[0]
            currentDataBone.keys[currentAnimationKeyIndex].scl[0] *= sx;    // number
            currentDataBone.keys[currentAnimationKeyIndex].scl[1] *= sy;    // number
            currentDataBone.keys[currentAnimationKeyIndex].scl[2] *= sz;    // number
            
        //  Play the frame.
            timescaleSlider.value = 0;
            animation.play( animation.currentTime );
            
        //  Return value to output.
            sx = currentBone.scale.x * 100;      // number
            sy = currentBone.scale.y * 100;      // number
            sz = currentBone.scale.z * 100;      // number
            sclOutputX.value = sx.toFixed(1);    // string
            sclOutputY.value = sy.toFixed(1);    // string
            sclOutputZ.value = sz.toFixed(1);    // string
            sclUniformOutput.value = sclOutputY.value;
        }



        function reverseSubmitScaleValue(){
        //  Return value to output.
            if (animation){
                sx = currentBone.scale.x * 100;      // number
                sy = currentBone.scale.y * 100;      // number
                sz = currentBone.scale.z * 100;      // number
                sclOutputX.value = sx.toFixed(1);    // string
                sclOutputY.value = sy.toFixed(1);    // string
                sclOutputZ.value = sz.toFixed(1);    // string
                sclUniformOutput.value = sclOutputY.value;
            }
        }
        
        
        
        function submitUniformScaleValue(){
        
        //  insertNewAnimateDataTimeFrameKey();
            
        //  Submit value to object.
            var s = Number( sclUniformSlider.value );
            //s = s * currentDataBone.keys[currentAnimationKeyIndex].scl[1];
            s = Number(s.toFixed(3));
            
            currentDataBone.keys[currentAnimationKeyIndex].scl[0] *= s; // number
            currentDataBone.keys[currentAnimationKeyIndex].scl[1] *= s; // number
            currentDataBone.keys[currentAnimationKeyIndex].scl[2] *= s; // number
            
        //  Play the frame.
            timescaleSlider.value = 0;
            animation.play( animation.currentTime );
            
        //  Return value to output.
            s = currentBone.scale.y * 100;
            sclUniformOutput.value = s.toFixed(1); // string
            sclOutputX.value = s.toFixed(1);       // string
            sclOutputY.value = s.toFixed(1);       // string
            sclOutputZ.value = s.toFixed(1);       // string
        }
        
        
        
        
///////////////////////////////////// end of animation editing /////////////////////////////////////
        
        
        function submitNewDurationValue(){
            var theValue = Number(animtimerSlider.value);
            var lowend = 1;
            var highend = 10;
            var d = Number(durSlider.value);        // number
            d = Number(animtimerSlider.max) + d;    // number
            
            if (d > lowend && d < highend) 
            {
            //  Submit value to object.
                animtimerSlider.max = d.toFixed(1); // string
            //  Return value to output.
                d = Number(animtimerSlider.max);    // number
                durOutput.value = d;                // number
            }
            else if (d < lowend)
            {
                animtimerSlider.max = lowend;       // number
                durOutput.value = lowend;           // number
            }
            else if (d > highend)
            {
                animtimerSlider.max = highend;      // number
                durOutput.value = highend;          // number
            }
            animtimerSlider.value = 0;              // number
            animtimerSlider.value = theValue;       // number
            animtimerOutput.value = theValue;
        }
        
        
        
        function submitAnimationName(){
            animation.data.name = document.getElementById("animation-name").value;
        }
        
        
        
        function initAnimatorAdjustValues() {
        
        //  INITIALAZE DURATION OUTPUT VALUE.
            
            var duration = Number(animtimerSlider.max);
            durOutput.value = duration;
        }
        
        
        
        function initTimeLiner() {
        
        //  Timeliner.
            var timeContainer = document.getElementById("time-container");
            timeContainer.innerHTML = "";
                
        //  Settings.
            var duration = Number(animtimerSlider.max);  //  var duration = 3; // (sec).
            var defaultTimeScale = Math.floor(timeContainer.offsetWidth / duration); // (pixels).
        
        //  Dimensions.
            var markerTrackHeight = 20;
            var width = animtimerSlider.offsetWidth; // duration * defaultTimeScale;
            var height = 50;
            var timeScale = defaultTimeScale; // number of pixels to 1 second.
        
        //  Utilities.
            function proxy_ctx(ctx) {
        	//  Creates a proxy 2d context wrapper which 
        	//  allows the fluent / chaining API.
            	var wrapper = {};
            
            	function proxy_function(c) {
            		return function() {
        			//  Warning: this doesn't return value of function call
            			ctx[c].apply(ctx, arguments);
            			return wrapper;
            		};
            	}
            
            	function proxy_property(c) {
            		return function(v) {
            			ctx[c] = v;
            			return wrapper;
            		};
            	}
            
            	wrapper.run = function(args) {
            		args(wrapper);
            		return wrapper;
            	};
                
            	for (var c in ctx) {
        		//  if (!ctx.hasOwnProperty(c)) continue;
        		//  debugMode && console.log(c, typeof(ctx[c]), ctx.hasOwnProperty(c));
        		//  string, number, boolean, function, object
            
            		var type = typeof(ctx[c]);
            		switch(type) {
            			case "object":
            				break;
            			case "function":
            				wrapper[c] = proxy_function(c);
            				break;
            			default:
            				wrapper[c] = proxy_property(c);
            				break;
            		}
            	}
            
            	return wrapper;
            }
        
        //  View Panel.
            var frame_start = 0; // this is the current scroll position.
            
        //  This class contains the view for the right main section of timeliner
            var tickMark1;
            var tickMark2;
            var tickMark3;
                
        //  Subdivison LOD
        //  timeScale refers to number of pixels per unit
        //  Eg. 1 inch - 60s, 1 inch - 60fps, 1 inch - 6 mins.    
            function time_scaled() {

            	var subDivision = 60;
            
            	tickMark1 = Math.round( (timeScale / subDivision) * 100 ) / 100;
            	tickMark2 = 2 * tickMark1;
            	tickMark3 = 10 * tickMark1;
            
            }
            
            time_scaled();
    
        //  Timeline Panel.
            var dpr = window.devicePixelRatio;
            var canvas = document.createElement("canvas");
            canvas.width = width; // * dpr;
            canvas.height = height; // * dpr;
            timeContainer.appendChild(canvas);
            
            var ctx = canvas.getContext("2d");
        	var ctx_wrap = proxy_ctx(ctx);
            
            var currentTime; // measured in seconds.
    	//  Technically it could be in frames or have it in string format (0:00:00:1-60).
    	
        	var LEFT_GUTTER = 0;
        	var i, x, y, il, j;
            	
        //	function paint() {
        
            //  Background.
                ctx.fillStyle = "#ffffff";
                ctx.clearRect(0, 0, canvas.width, canvas.height);
        		ctx.save();
        		ctx.scale(dpr, dpr);
                
                ctx.lineWidth = 2; // options: | 0.5 | 1 | 2 |
                
                var units = Math.round(timeScale / tickMark1);
        		var offsetUnits = (frame_start * timeScale) % units;
        		var count = Math.ceil( width / units );
      
            //  timeScale = pixels to 1 second (40)
    		//  tickMark1 = marks per second (marks / s)
    		//  units = pixels to every mark (40)
                var t =  Math.floor(units * 100 / timeScale);
                debugMode && console.log("t:", t);
                
            //  1.Labels only.
        		for (i = 0; i < count + 1; i++) {
        			x = i * units + LEFT_GUTTER - offsetUnits;
                    
        			ctx.fillStyle = "#535353";
        			ctx.textAlign = "center";
                    
        			var ti = ( t * i / 100 ).toFixed(2).replace(/\./g, ":");
        			debugMode && console.log("t" + i + ":", ti);
                    
        			ctx.fillText(ti, x, 50);
        		}
        
        		units = Math.round( timeScale / tickMark2 );
        		count =  Math.round( (width - LEFT_GUTTER + offsetUnits) / units );
    
            //  2.Marker lines - main.
        		for (i = 0; i < count + 1; i++) {
        			ctx.strokeStyle = "#b8b8b8";
        			ctx.beginPath();
        			x = i * units + LEFT_GUTTER - offsetUnits;
        			ctx.moveTo(x, markerTrackHeight + 14);
        			ctx.lineTo(x, markerTrackHeight - 16);
        			ctx.stroke();
        		}
        
        		var mul = tickMark3 / tickMark2;
        		units = Math.round( timeScale / tickMark3 );
        		count =  Math.round( (width - LEFT_GUTTER + offsetUnits) / units );
    
            //  3.Small ticks.
                for (i = 0; i < count + 1; i++) {
                	if (i % mul === 0) continue;
                	ctx.strokeStyle = "#b8b8b8";
                	ctx.beginPath();
                	x = i * units + LEFT_GUTTER - offsetUnits;
                	ctx.moveTo(x, markerTrackHeight + 5);
                	ctx.lineTo(x, markerTrackHeight - 10);
                	ctx.stroke();
                }
            
        //  }
            
        //  paint();
        }

        
    </script>
     
     
     
     
    <script>
        
        
        
        if ( ! Detector.webgl ) Detector.addGetWebGLMessage();
        
        var frameCount = 0;
        var mouse = new THREE.Vector2();
        var avatar;
        var armature, armatureHelper;
        var animation;
        var poseHelper;
        var normals;
        var morphs = [];
        var skins = [];
        
        
        
    //  Define animation object.
        var animationsHandler = THREE.AnimationHandler.animations;   //  array
        
        
        
    //  Before, Current, After (bca) Frame Key Indexes Array.
        function bcaFrameKeyIndexesArray(t){
        //  Check if frame (t) already exist in animationData.
            var keyExists = false;
            var keyBefore, keyIndex, keyAfter;
            var keysArray = (animation) ? animation.data.hierarchy[0].keys : [];
        //  var t = Number(animtimerSlider.value);
            if (keysArray.length > 0){
                for (var j in keysArray){
                    if (keysArray[j].time < Number(t)){
                        keyBefore = Number(j);
                    }
                    else if (keysArray[j].time == Number(t)){
                        keyIndex = Number(j);
                        keyExists = true;
                    }
                    else if (keysArray[j].time > Number(t)){
                        keyAfter = Number(j);
                        break;
                    }
                    else 
                    {
                        var a = "DEBUG_ERROR_CAUTCH:"
                        var b = "currentFrameKeyExists():"
                        var c = "if (keysArray.length > 0)..."
                        debugMode && console.log( a, b, c );
                    }
                }
            }
            animationDataKeyExist = keyExists;
            bcaAnimationDataIndexKeys = [keyBefore, keyIndex, keyAfter];
            currentAnimationKeyIndex = keyIndex;
            //  debugMode && console.log("bca keys:", bcaAnimationDataIndexKeys);
            return bcaAnimationDataIndexKeys;
        }
        
        
        
    ///////////////////// start of playAnimation() //////////////////////
    
    //  When you press a save button you can sent this animationData object to server database.
    
    //  Play Button handles the timeSpeed of animation.
    
    //  Animation is always in play mode. Never stopping.
        
        function playAnimation(theAvatar){
        
            if (playButton.innerHTML == "Play"){
                ensureLooping();
                ensureKeysIndexing();
                timescaleSlider.value = currentSpeed;
                timescaleOutput.value = currentSpeed;
                animation.play(animation.currentTime);
                animtimerSlider.value = animation.currentTime;
                playButton.innerHTML = "Pause";
                document.getElementById("status-msgr").innerHTML = "Playing...";
                document.getElementById("status-msgr").style.display = "block";
                debugMode && console.log("Animation is playing.");
            }
            
            else if (playButton.innerHTML == "Pause"){
                timescaleSlider.value = 0;
                timescaleOutput.value = currentSpeed;
                animtimerSlider.value = animation.currentTime;
                playButton.innerHTML = "Play";
                debugMode && console.log("animation.data:", animation.data);
                document.getElementById("status-msgr").innerHTML = "Paused";
                document.getElementById("status-msgr").style.display = "block";
                debugMode && console.log("Animation paused.");
            }
        }
        
        
        
        function ensureLooping(){
            var lastkeyExists = false;
            var z = animation.data.hierarchy[0].keys.length - 1;
            var t = animation.data.length;
            if (animation.data.hierarchy[0].keys[z].time == t) {
                lastkeyExists = true;
            }
            for (var i in animation.data.hierarchy){
                var posloop = animation.data.hierarchy[i].keys[0].pos;
                var rotloop = animation.data.hierarchy[i].keys[0].rot;
                var sclloop = animation.data.hierarchy[i].keys[0].scl;
                var loopKeyData = {"index":z, "pos":posloop, "rot":rotloop, "scl":sclloop, "time":t};
            //  debugMode && console.log("loopKeyData:", loopKeyData);
                if (lastkeyExists) {
                    var removedItems = 1;
                    animation.data.hierarchy[i].keys.splice(z, removedItems, loopKeyData);
                }
                else {
                   var removedItems = 0;
                   loopKeyData.index = animation.data.hierarchy[0].keys.length;   // index correction.
                   animation.data.hierarchy[i].keys.push(loopKeyData);
                }
            }
            debugMode && console.log("Ensure Looping completed.");
        }
        
        
        
        function ensureKeysIndexing(){
            for (var i in animation.data.hierarchy){
                for (var j in animation.data.hierarchy[i].keys){
                    animation.data.hierarchy[i].keys[j].index = Number(j);
                }
            }
            debugMode && console.log("Ensure Keys Indexing completed.");
        }


    ////////////////////// end of playAnimation() ///////////////////////
        
        
        var animator3JsInitialized = false;

        function animatorEditorRuntime(){

            if ( !animator3JsInitialized ){
                
                initAnimatorScene();
                animateAnimatorScene();
                
                animator3JsInitialized = true;
                debugMode && console.log("Animator Editor scene initialized.");
            }
        }
        
        
        function initAnimatorScene(){
        //  Canvas.
            animatorContainer = document.getElementById("animator-render-container");

        //  Scene.
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2( 0x000000, 0.0001 );

        //  Camera.
            near = 1; 
            far = 100000;
            camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, near, far );
            camera.position.set( -1.5, 18, 55 );
            camera.rotation.set( -0.043, -0.035, -0.002 );
            camera.name = "CAMERA" ;

        //  Scene lights.
            light0 = newDirectionalLight(0xffffff, 1000, 1000, 1000, 0.5);
            light1 = newDirectionalLight(0xffffff, 1000, 1000, -1000, 0.5);
            light2 = newDirectionalLight(0xffffff, -1000, 1000, -1000, 0.5);
            light3 = newDirectionalLight(0xffffff, -1000, 1000, 1000, 0.5);
            light4 = newDirectionalLight(0xffffff, 0, -1000, 0, 0.5);
            scene.add(light0, light1, light2, light3, light4);

        //  Controls.
            controls = new THREE.EditorControls(camera);

        //  Projector.
        	projector = new THREE.Projector();

        //  Ground Helper.
            groundHelper = newGroundHelper();
            scene.add(groundHelper);

		//  Skydome.
            var loader = new THREE.TextureLoader();
    		skydome = new THREE.Mesh(
    			new THREE.SphereGeometry( far * 0.1, 15, 15 ),
    			new THREE.MeshBasicMaterial({
    				map: loader.load( "/anywhere3d/skydomes/skydome.jpg" ),
    				color: 0xffffff,
    				side: THREE.DoubleSide
    			})
    		);
    		skydome.rotation.y = Math.PI;
    		skydome.scale.set(-1, 2, 1);
    		scene.add( skydome );
    		
        //  Axis Helper.
            axisCustomHelper = newCustomAxisHelper(scene);
            scene.add(axisCustomHelper);

        //  Floor.
        //  var material = new THREE.MeshLambertMaterial( { color:0x8888ff, side:THREE.DoubleSide } );
        //  floorPlain = new THREE.Mesh( new THREE.PlaneGeometry( 50, 50, 1, 1 ), material );
        //  floorPlain.position.set( 0, 0, 0 );
        //  floorPlain.rotation.set( -Math.PI/2, 0, 0 );
        //  scene.add( floorPlain );

        //  Keyboard controls.
            keyboard = new KeyboardState();

        //  Clock.
            clock = new THREE.Clock();

        //  Renderer.
            renderer = new THREE.WebGLRenderer( { antialias:true, preserveDrawingBuffer:true } );
            renderer.shadowMapEnabled = true;
    		renderer.setPixelRatio( window.devicePixelRatio );
    		renderer.setSize( window.innerWidth, window.innerHeight ); 
			renderer.autoClear = true; 
    		animatorContainer.appendChild( renderer.domElement );

        //  Event Listeners.
            window.addEventListener( 'resize', onWindowResize, false );
        	document.addEventListener( 'mousedown', onDocumentMouseDown, false );
        	document.addEventListener( 'mouseup', onDocumentMouseUp, false );
            document.addEventListener( 'mousemove', onDocumentMouseMove, false );
            
        //  Manny The Skeleton Default Rigged Mesh.
            loadSkinnedAnimatedMesh("/anywhere3d/skinned/MannyTheSkeletonDefaultRigged_v04.js", 1);
            
        //  Animator Inits.
            initAnimatorAdjustValues();
            
        //  Timeliner Inits.
            initTimeLiner();
        }
        
        
        function defaultAnimatorRendererContainer(){
            groundHelper.visible = true;
            axisCustomHelper.visible = true;
        //  floorPlain.visible = true;
            animatorContainer = document.getElementById("animator-render-container");
        //  document.getElementById("preview-animator").style.display = "none"; 
            
            camera.aspect = animatorContainer.offsetWidth / animatorContainer.offsetHeight;
            camera.updateProjectionMatrix();
            renderer.setSize( animatorContainer.offsetWidth - 2, animatorContainer.offsetHeight - 2 ); 
            animatorContainer.appendChild( renderer.domElement );
            controls.focus(avatar, true);
        }
        
        
        function changeAnimatorRendererContainer( displayId, containerId ){
            
            if (animator3JsInitialized) {
            
                if ( animatorContainer == document.getElementById("animator-render-container") ) {
                    groundHelper.visible = false;
                    axisCustomHelper.visible = false;
                //  floorPlain.visible = false;
                    armatureHelper.visible = false;
                    animatorContainer = document.getElementById(containerId);
                    document.getElementById(displayId).style.display = "block"; 
                } else {
                    groundHelper.visible = true;
                    axisCustomHelper.visible = true;
                //  floorPlain.visible = true;
                //  armatureHelper.visible = true;
                    animatorContainer = document.getElementById("animator-render-container");
                    document.getElementById(displayId).style.display = "none"; 
                }
                
                camera.aspect = animatorContainer.offsetWidth / animatorContainer.offsetHeight;
                camera.updateProjectionMatrix();
                renderer.setSize( animatorContainer.offsetWidth - 2, animatorContainer.offsetHeight - 2 ); 
                animatorContainer.appendChild( renderer.domElement );
                controls.focus(avatar, true);
                
            }
            
        }
        
        
        function getRendererScreenPrintImage() {
            var imageData = renderer.domElement.toDataURL("image/png");
            debugMode && console.log(imageData);
            return imageData;
        }
        
        
        function loadSkinnedAnimatedMesh(url, scale){
        //  Remove old avatar from scene.
            if (avatar) scene.remove(avatar);
        //  Remove old armature helper.
            if (armatureHelper) scene.remove(armatureHelper);
            
        //  Load Skinned Armatured Mesh.
            var loader = new THREE.JSONLoader();
            loader.load( url, function(geometry, materials){
                geometry.computeVertexNormals();
    	        geometry.computeBoundingBox();
   	        //
    	        for ( var i = 0, il = materials.length; i < il; i ++ ) 
                {
                    var originalMaterial = materials[ i ];
                    originalMaterial.skinning = true;
                }
   	        //
                var material = new THREE.MeshFaceMaterial(materials);
                avatar = new THREE.SkinnedMesh(geometry, material, false);
                avatar.name = "AVATAR";
                avatar.position.set( 0, 0, 0 );
                avatar.scale.set( scale, scale, scale );
                avatar.rotation.set( 0, 0, 0 );
                avatar.userData.animationData = {};
                scene.add(avatar);
                skins.push(avatar);
                debugMode && console.log("Avatar loaded:", avatar);
            //
                armatureHelper = newSkeletonHelper(avatar);
                scene.add(armatureHelper);
                armatureHelper.visible = false;
                debugMode && console.log("Armature Helper created:", armatureHelper);
            
            //  Initialize Bones Drop list.
                initBonesDroplist(avatar);
                debugMode && console.log("Bones droplist initialized.");
                
            //  Define the animationData object to create the init animation.
                var animationData = {"name":null, "fps":null, "length":null, "hierarchy":[]};
                animationData.name = nameAnimField.value;
                animationData.fps = Number(fpsSlider.value);
                animationData.length = Number(animtimerSlider.max);
                
            
            //  Prepear animationData for first init animation keys.

            //  Create the init key (time:0) for every bone of avatar in animationData.hierarchy.
                for (var i in avatar.skeleton.bones) {
                    animationData.hierarchy.push({"keys":[]});
                    var initAnimationKey = {"pos":[0,0,0], "rot":[0,0,0,1], "scl":[1,1,1], "time":0};
                    initAnimationKey.pos = avatar.skeleton.bones[i].position.toArray();
                    initAnimationKey.rot = avatar.skeleton.bones[i].quaternion.toArray();
                    initAnimationKey.scl = avatar.skeleton.bones[i].scale.toArray();
                    animationData.hierarchy[i].keys.push(initAnimationKey);
                }
                debugMode && console.log( "Animation Data created:", animationData );
                
            //  Create the animation.
                THREE.AnimationHandler.animations = [];
                animation = new THREE.Animation( avatar, animationData );
                animation.isPlaying = false;
                animation.currentTime = 0;
                timescaleSlider.value = 0;
                playButton.innerHTML = "Play";
                debugMode && console.log("Animation created:", animation);
            //
                ensureLooping();
            
            //  Create a userData array to store rest pose.
                avatar.userData.restPose = [];
                
            //  Store init key as rest pose in userData.
                for (var i in animation.hierarchy) {
                    var restPoseKey = {"pos":[0,0,0], "rot":[0,0,0,1], "scl":[1,1,1]};
                    restPoseKey.pos = animation.hierarchy[i].position.toArray();
                    avatar.userData.restPose.push( restPoseKey );
                }
                debugMode && console.log( "Rest pose saved:", avatar.userData.restPose );
                
            //  Now that we have create the animation
            //  we can get the currentBone and initialize
            //  the bones values in bone adjust sliders.
            
                getCurrentBone(); 
                initBonesAdjustValues();
                debugMode && console.log("Avatar loading completed and ready to animate.");
            });
        }

        
        
        
    //  LOAD JSON SKINNED MESH.
        
        function loadJsonSkinnedAnimatedMesh(event){
        //  Remove old skinnedmesh from scene.
            if (avatar) scene.remove(avatar);
        //  Remove old armature helper.
            if (armatureHelper) scene.remove(armatureHelper);

        //  JSON TEXT CONTENTS READER.
            var reader = new FileReader();
            
        //  FileList object.
            var file = event.target.files[0];
            debugMode && console.log("file:", file);
            var filename = file.name;
            debugMode && console.log("filename:", filename);
    		var extension = filename.split( '.' ).pop().toLowerCase();
    		debugMode && console.log("extension:", extension);
    		var name = filename.split( '.' )[0];
    		debugMode && console.log("name:", name);
    		
//      1. First we read json file as text.

        //  Read json file as a text string.
            reader.readAsText(file);
            
        //  When reading competed...
            reader.onloadend = function(event){
                //debugMode && console.log(event.target.result);
                contents = event.target.result;
            //  Skinned Json data for skinned collection input.
                skinnedJsonData = event.target.result;
                //debugMode && console.log("contents:", contents);
                debugMode && console.log("json contents readed as text string.");
//      2. Then we parse json string as json data with JSON parser.
            //  Parse json contents string as json data.
                var data = JSON.parse( contents );
                debugMode && console.log("json contents parsed as data:", data);
            //  Get Json contents metadata.
                var metadata = data.metadata;
                debugMode && console.log("json metadata:", metadata);
//      3. Last we parse again json data with a new JSONLoader to get the geometry.
                var loader = new THREE.JSONLoader();
                var result = loader.parse( data );
                debugMode && console.log("json data parsed with THREE.JSONLoader as JSON object {geometry, materials}.");
                debugMode && console.log("result:", result);
                var geometry = result.geometry;
                debugMode && console.log("geometry:", geometry);
                
//      4. We create the materials from json results.
                geometry.computeVertexNormals();
    	        geometry.computeBoundingBox();
 		    //
                var material;
    			if ( result.materials !== undefined ) {
                    for ( var i = 0; i < result.materials.length; i++ ) {
                        var originalMaterial = result.materials[ i ];
                        originalMaterial.skinning = true;
                    }
                    if ( result.materials.length > 1 )
    					material = new THREE.MeshFaceMaterial( result.materials );
    				else 
    					material = result.materials[ 0 ];
    			} 
                else {
    				material = new THREE.MeshStandardMaterial({skinning: true}); // new THREE.MeshPhongMaterial({skinning: true});
    			}
    			debugMode && console.log("material:", material);
            //
                geometry.sourceType = "ascii";
    		    geometry.sourceFile = file.name;
    		    
//      5. We create the json skinned mesh object.
    			if ( geometry.bones && geometry.bones.length > 0 ) {
    				// var material = new THREE.MeshFaceMaterial(result.materials);
                    avatar = new THREE.SkinnedMesh(geometry, material, false);
                    avatar.name = "AVATAR";
                    avatar.position.set( 0, 0, 0 );
                    avatar.scale.set( 1, 1, 1 );
                    avatar.rotation.set( 0, 0, 0 );
                    avatar.userData.animationData = {};
                    // scene.add(avatar);
                    skins.push(avatar);
                    debugMode && console.log("Avatar loaded:", avatar);
    			} 
                else {
                    var msg = "Sorry. This is not a skinned mesh. Try to upload with Easy Meshes Upload Form.";
                    debugMode && console.log(msg);
                    alert(msg);
                    return;
    			}
    			
//      6. We add new mesh in SKIN scene.
    			scene.add(avatar);
    			debugMode && console.log("avatar added in Animator scene:", scene.children);
            //  Loading completed.
                debugMode && console.log("Loading skinned json file", filename, "completed.");
            //  Focus Editor controls.
                controls.focus(avatar, true);
                
//      7. We add all the rest things in scene.
                armatureHelper = newSkeletonHelper(avatar);
                scene.add(armatureHelper);
                armatureHelper.visible = false;
                debugMode && console.log("Armature Helper created:", armatureHelper);
            
            //  Initialize Bones Drop list.
                initBonesDroplist(avatar);
                debugMode && console.log("Bones droplist initialized.");
                
            //  Define the animationData object to create the init animation.
                var animationData = {"name":null, "fps":null, "length":null, "hierarchy":[]};
                animationData.name = nameAnimField.value;
                animationData.fps = Number(fpsSlider.value);
                animationData.length = Number(animtimerSlider.max);
                
            //  Prepear animationData for first init animation keys.

            //  Create the init key (time:0) for every bone of avatar in animationData.hierarchy.
                for (var i in avatar.skeleton.bones) {
                    animationData.hierarchy.push({"keys":[]});
                    var initAnimationKey = {"pos":[0,0,0], "rot":[0,0,0,1], "scl":[1,1,1], "time":0};
                    initAnimationKey.pos = avatar.skeleton.bones[i].position.toArray();
                    initAnimationKey.rot = avatar.skeleton.bones[i].quaternion.toArray();
                    initAnimationKey.scl = avatar.skeleton.bones[i].scale.toArray();
                    animationData.hierarchy[i].keys.push(initAnimationKey);
                }
                debugMode && console.log( "Animation Data created:", animationData );
                
            //  Create the animation.
                THREE.AnimationHandler.animations = [];
                animation = new THREE.Animation( avatar, animationData );
                animation.isPlaying = false;
                animation.currentTime = 0;
                timescaleSlider.value = 0;
                playButton.innerHTML = "Play";
                debugMode && console.log("Animation created:", animation);
            //
                ensureLooping();
            
            //  Create a userData array to store rest pose.
                avatar.userData.restPose = [];
                
            //  Store init key as rest pose in userData.
                for (var i in animation.hierarchy) {
                    var restPoseKey = {"pos":[0,0,0], "rot":[0,0,0,1], "scl":[1,1,1]};
                    restPoseKey.pos = animation.hierarchy[i].position.toArray();
                    avatar.userData.restPose.push( restPoseKey );
                }
                debugMode && console.log( "Rest pose saved:", avatar.userData.restPose );
                
            /*  Now that we have create the animation
                we can get the currentBone and initialize
                the bones values in bone adjust sliders.
            */
                getCurrentBone(); 
                initBonesAdjustValues();
                debugMode && console.log("Avatar loading completed and ready to animate.");
                
			}
        }
        
        
        
        function initBonesDroplist(theAvatar){
        //  Remove all options from droplist.
            bonesDroplist.innerHTML = null;
            
        //  Create new options list from avatar bones.
            for (var i in theAvatar.skeleton.bones){
                var newOption = document.createElement("option");
                newOption.value = theAvatar.skeleton.bones[i].name;
                newOption.text = theAvatar.skeleton.bones[i].name;
                bonesDroplist.options.add(newOption);
            }
        }
        
        
        
        function newSkeletonHelper(theMesh){
        //  Create the skeleton helper debug visualization
			var helper = new THREE.SkeletonHelper(theMesh);
			helper.material.linewidth = 5;
			helper.name = "ARMATURE_HELPER";
			helper.visible = true;
			return helper;
        }

        
        
        function showhideHelper(theHelper){
            theHelper.visible = !theHelper.visible;
        }
        
        
        
        //////////////////////////// start of resets ////////////////////////////



        function deepCopy(obj) {
            if (Object.prototype.toString.call(obj) === "[object Array]") {
                var out = [], i = 0, len = obj.length;
                for ( ; i < len; i++ ) {
                    out[i] = arguments.callee(obj[i]);
                }
                return out;
            }
            if (typeof obj === "object") {
                var out = {}, i;
                for ( i in obj ) {
                    out[i] = arguments.callee(obj[i]);
                }
                return out;
            }
            return obj;
        }

        
        
        function avatarRestPose(theAvatar){
        //  Check if current animation data key exist.
            bcaFrameKeyIndexesArray( animtimerSlider.value );
        
            if (animationDataKeyExist) {
            //  Copy pose from user data.
                for (var i in theAvatar.userData.restPose){
                    animation.data.hierarchy[i].keys[currentAnimationKeyIndex].pos = deepCopy( theAvatar.userData.restPose[i].pos );
                    animation.data.hierarchy[i].keys[currentAnimationKeyIndex].rot.fromArray( theAvatar.userData.restPose[i].rot );
                    animation.data.hierarchy[i].keys[currentAnimationKeyIndex].scl = deepCopy( theAvatar.userData.restPose[i].scl );
                }
            //  Play the frame.
                timescaleSlider.value = 0;
                animation.play( animation.currentTime );
            //
                theAvatar.visible = true;
                armatureHelper.visible = false;
                debugMode && console.log("Animation data key reseted to rest pose.");
            }
            else if (!animationDataKeyExist){
                debugMode && console.log("Current animation data key does not exists.", "You can not reset to rest pose.");
            }
            newCurrentBoneSelected();
        }
        
        
        
        function bonesResetPosition(theAvatar){
        //  Check if current animation data key exist.
            bcaFrameKeyIndexesArray( animtimerSlider.value );
            
            if (animationDataKeyExist) {
            //  Reset bones position values from user data.
                for (var i in theAvatar.userData.restPose){
                    animation.data.hierarchy[i].keys[currentAnimationKeyIndex].pos = deepCopy( theAvatar.userData.restPose[i].pos );
                }
            //  Play the frame.
                timescaleSlider.value = 0;
                animation.play( animation.currentTime );
            //
                theAvatar.visible = true;
                armatureHelper.visible = false;
                debugMode && console.log("Animation data key positions reseted.");
            }
            else if (!animationDataKeyExist){
                debugMode && console.log("Current animation data key does not exists.", "You can not reset bones position.");
            }
            newCurrentBoneSelected();
        }
        
        
        
        function bonesResetQuaternion(theAvatar){
        //  Check if current animation data key exist.
            bcaFrameKeyIndexesArray( animtimerSlider.value );
            
            if (animationDataKeyExist) {
            //  Reset bones position values from user data.
                for (var i in theAvatar.userData.restPose){
                    animation.data.hierarchy[i].keys[currentAnimationKeyIndex].rot.fromArray( theAvatar.userData.restPose[i].rot );
                }
            //  Play the frame.
                timescaleSlider.value = 0;
                animation.play( animation.currentTime );
            //
                theAvatar.visible = true;
                armatureHelper.visible = false;
                debugMode && console.log("Animation data key rotations reseted.");
            }
            else if (!animationDataKeyExist){
                debugMode && console.log("Current animation data key does not exists.", "You can not reset bones rotation.");
            }
            newCurrentBoneSelected();
        }
        
        
        
        
        function bonesResetScale(theAvatar){
        //  Check if current animation data key exist.
            bcaFrameKeyIndexesArray( animtimerSlider.value );
            
            if (animationDataKeyExist) {
            //  Reset bones position values from user data.
                for (var i in theAvatar.userData.restPose){
                    animation.data.hierarchy[i].keys[currentAnimationKeyIndex].scl = deepCopy( theAvatar.userData.restPose[i].scl );
                }
            //  Play the frame.
                timescaleSlider.value = 0;
                animation.play( animation.currentTime );
            //
                theAvatar.visible = true;
                armatureHelper.visible = false;
                debugMode && console.log("Animation data key scales reseted.");
            }
            else if (!animationDataKeyExist){
                debugMode && console.log("Current animation data key does not exists.", "You can not reset bones scale.");
            }
            newCurrentBoneSelected();
        }
        
        
    ///////////////////////////// end of resets /////////////////////////////
        
        
    //  TODO: TO FIX deletePoseHierarchyKey() function

        function deleteCurrentAnimationDataKey(){
        //  Check if current animation data key exist.
            bcaFrameKeyIndexesArray( animtimerSlider.value );
            
            if ( animationDataKeyExist ){
                for (var i in animation.data.hierarchy){
                    var removedItems = 1;
                    animation.data.hierarchy[i].keys.splice( currentAnimationKeyIndex, removedItems );
                }
                debugMode && console.log("Current animation data key deleted.");
            //
                ensureLooping();
                ensureKeysIndexing();
                
            //  Update current animation index key.
                bcaFrameKeyIndexesArray( animtimerSlider.value );
                
            //  Play the frame.
                timescaleSlider.value = 0;
                animation.play( animation.currentTime );
            }
            
            else if (!animationDataKeyExist){
                debugMode && console.log("Current animation data key does not exists.", "Delete animation pose key aborted.");
            }
            
            newCurrentBoneSelected();
        }
        
        
        
        
        
        
    /////////////////////// animation keys sort by time ////////////////////////
        
        
        
        function changeFrameKeyTimeDebuger(k, t){
            
            for (var i in animation.data.hierarchy){
                animation.data.hierarchy[i].keys[k].time = t;
            }
        }
        
        
        
        function sortAnimationDataKeysByTime(){
            for (var i in animation.data.hierarchy){
            //  Sort animation data keys by time.
                animation.data.hierarchy[i].keys.sort( function(a,b){return parseFloat(a.time) - parseFloat(b.time);} );
            //  Ensure animation data keys indexing.
                for (var j in animation.data.hierarchy[i].keys){
                    animation.data.hierarchy[i].keys[j].index = Number(j);
                }
            }
            debugMode && console.log("Sorting Animation Data Keys by time with internal Ensure Keys Indexing completed.");
        }
        
        
        
    /////////////////////// start of random IK Poser ////////////////////////
        
        
        
        function randomAnimationDataKeyGenerator(){
        
        //  Check if current animation data key exist.
            bcaFrameKeyIndexesArray( animtimerSlider.value );
            
            if (animationDataKeyExist) {
            //  Generate random bones quaternion values.
                for (var i in animation.data.hierarchy){
                    var euler = new THREE.Euler( randomRad(-180, 180), randomRad(-180, 180), randomRad(-180, 180), "XYZ" );
                    var quaternion = new THREE.Quaternion();
                    quaternion.setFromEuler( euler );
                    animation.data.hierarchy[i].keys[currentAnimationKeyIndex].rot.copy( quaternion );
                }
            }
            else if (!animationDataKeyExist){
                debugMode && console.log("Current animation data key does not exists.", "You can not generate random pose key.");
            }
            
            newCurrentBoneSelected();
        }
        
        

        function randomRad(min, max) { return THREE.Math.degToRad(THREE.Math.randInt(min, max)) }
        
        
        
        currentCrazyPosesScript = randomPoseGeneratorForMannyTheSkeletonDefaultRigged;

        function randomPoseGeneratorForMannyTheSkeletonDefaultRigged(){
            
        //  Generate the random ik pose for every bone of MannyTheSkeletonDefaultRigged_v04.

            var ik_Base             = new THREE.Euler( randomRad( -30,  50), randomRad( -45,  45), randomRad(   0,   0), "XYZ" );
            var ik_Back             = new THREE.Euler( randomRad(   0,   0), randomRad(   0,   0), randomRad(   0,   0), "XYZ" );
            
            
            var ik_ScapulaRight     = new THREE.Euler( randomRad(  -8,   8), randomRad(  -2,   8), randomRad( -15,   8), "XYZ" );
            var ik_UpperArmRight    = new THREE.Euler( randomRad(-170,  80), randomRad(   0, 100), randomRad(-105,  95), "XYZ" );
            var ik_ForeArmRight     = new THREE.Euler( randomRad( -75,  95), randomRad( -10, 160), randomRad(  -1,   1), "XYZ" );
            var ik_HandRight        = new THREE.Euler( randomRad(  -1,   1), randomRad( -30,  20), randomRad( -40,  70), "XYZ" );
            
            
            var ik_FingersRight     = new THREE.Euler( randomRad(   0,   0), randomRad(   0,   0), randomRad(   0,  80), "XYZ" );
            var ik_Fingers1Right    = new THREE.Euler( randomRad(   0,   0), randomRad(   0,   0), randomRad(   0, 105), "XYZ" );
            var ik_Fingers2Right    = new THREE.Euler( randomRad(   0,   0), randomRad(   0,   0), randomRad(   0, 110), "XYZ" );
            var ik_ThumbRight       = new THREE.Euler( randomRad(   0,   0), randomRad(   0,   0), randomRad(   0,   0), "XYZ" );
            var ik_Thumb1Right      = new THREE.Euler( randomRad( -40,  65), randomRad( -60,  50), randomRad( -50,  50), "XYZ" );
            var ik_Thumb2Right      = new THREE.Euler( randomRad(   0,  90), randomRad(   0,   0), randomRad(   0,   0), "XYZ" );
            
            
            var ik_ScapulaLeft      = new THREE.Euler( randomRad(  -8,   8), randomRad(  -8,   2), randomRad(  -8,  15), "XYZ" );
            var ik_UpperArmLeft     = new THREE.Euler( randomRad(  -8,   8), randomRad(-100,   0), randomRad( -95, 105), "XYZ" );
            var ik_ForeArmLeft      = new THREE.Euler( randomRad( -75,  95), randomRad(-160,  10), randomRad(  -1,   1), "XYZ" );
            var ik_HandLeft         = new THREE.Euler( randomRad(  -1,   1), randomRad( -20,  30), randomRad( -70,  40), "XYZ" );
            
            
            var ik_FingersLeft      = new THREE.Euler( randomRad(   0,   0), randomRad(   0,   0), randomRad( -80,   0), "XYZ" );
            var ik_Fingers1Left     = new THREE.Euler( randomRad(   0,   0), randomRad(   0,   0), randomRad(-105,   0), "XYZ" );
            var ik_Fingers2Left     = new THREE.Euler( randomRad(   0,   0), randomRad(   0,   0), randomRad(-110,   0), "XYZ" );
            var ik_ThumbLeft        = new THREE.Euler( randomRad(   0,   0), randomRad(   0,   0), randomRad(   0,   0), "XYZ" );
            var ik_Thumb1Left       = new THREE.Euler( randomRad( -40,  65), randomRad( -50,  60), randomRad( -50,  50), "XYZ" );
            var ik_Thumb2Left       = new THREE.Euler( randomRad(   0,  90), randomRad(   0,   0), randomRad(   0,   0), "XYZ" );
            
            
            var ik_Chest            = new THREE.Euler( randomRad(  -1,   1), randomRad(  -1,   1), randomRad(  -1,   1), "XYZ" );
            var ik_Hip              = new THREE.Euler( randomRad(-120,  30), randomRad( -50,  50), randomRad( -12,  12), "XYZ" );
            
            
            var ik_HipLeft          = new THREE.Euler( randomRad(  -1,   1), randomRad(  -1,   1), randomRad(  -1,   1), "XYZ" );
            var ik_ThighLeft        = new THREE.Euler( randomRad( -90,   0), randomRad( -90,  25), randomRad( -10,  45), "XYZ" );
            var ik_ShinLeft         = new THREE.Euler( randomRad(  -0, 130), randomRad( -30,  30), randomRad(  -1,   1), "XYZ" );
            var ik_FootLeft         = new THREE.Euler( randomRad( -30,  30), randomRad(  -1,   1), randomRad(  -1,   1), "XYZ" );
            var ik_ToesLeft         = new THREE.Euler( randomRad(  -1,  45), randomRad(  -1,   1), randomRad(  -1,   1), "XYZ" );
            
            
            var ik_HipRight         = new THREE.Euler( randomRad(  -1,   1), randomRad(  -1,   1), randomRad(  -1,   1), "XYZ" );
            var ik_ThighRight       = new THREE.Euler( randomRad( -90,   0), randomRad( -25,  90), randomRad( -45,  10), "XYZ" );
            var ik_ShinRight        = new THREE.Euler( randomRad(  -0, 130), randomRad( -30,  30), randomRad(  -1,   1), "XYZ" );
            var ik_FootRight        = new THREE.Euler( randomRad( -30,  30), randomRad(  -1,   1), randomRad(  -1,   1), "XYZ" );
            var ik_ToesRight        = new THREE.Euler( randomRad(  -1,  45), randomRad(  -1,   1), randomRad(  -1,   1), "XYZ" );
            
            
            var ik_Neck             = new THREE.Euler( randomRad( -15,  30), randomRad( -45,  45), randomRad( -60,  60), "XYZ" );
            var ik_Head             = new THREE.Euler( randomRad( -45,  15), randomRad( -15,  15), randomRad( -15,  15), "XYZ" );
            var ik_Jaw              = new THREE.Euler( randomRad(   0,  50), randomRad(  -3,   3), randomRad(  -4,   4), "XYZ" );
        //
            var bonesIK = [ ik_Base, ik_Back, 
                ik_ScapulaRight, ik_UpperArmRight, ik_ForeArmRight, ik_HandRight, ik_FingersRight, ik_Fingers1Right, ik_Fingers2Right, ik_ThumbRight, ik_Thumb1Right, ik_Thumb2Right,
                ik_ScapulaLeft, ik_UpperArmLeft, ik_ForeArmLeft, ik_HandLeft, ik_FingersLeft, ik_Fingers1Left, ik_Fingers2Left, ik_ThumbLeft, ik_Thumb1Left, ik_Thumb2Left,
                ik_Chest, ik_Hip, ik_HipLeft, ik_ThighLeft, ik_ShinLeft, ik_FootLeft, ik_ToesLeft, ik_HipRight, ik_ThighRight, ik_ShinRight, ik_FootRight, ik_ToesRight,
                ik_Neck, ik_Head, ik_Jaw
            ]
            
        //  Check if current animation data key exist.
            bcaFrameKeyIndexesArray( animtimerSlider.value );
            
            function setAnimationDataKeyRotationFromEuler(euler, idx){
                var quaternion = new THREE.Quaternion();
                quaternion.setFromEuler( euler );
                animation.data.hierarchy[idx].keys[currentAnimationKeyIndex].rot.copy( quaternion );
            }
            
            if (animationDataKeyExist) {
            //  Base - Body.
                if (currentBoneIndex == 0) {
                    for (var i in bonesIK){
                        var quaternion = new THREE.Quaternion();
                        quaternion.setFromEuler( bonesIK[i] );
                        animation.data.hierarchy[i].keys[currentAnimationKeyIndex].rot.copy( quaternion );
                    }
                }
                
            //  Back - Upperbody.
                else if (currentBoneIndex == 1){
                    setAnimationDataKeyRotationFromEuler( bonesIK[1], 1 );
                    setAnimationDataKeyRotationFromEuler( bonesIK[22], 22 );
                    for (var i = 2; i < 12; i++){
                        setAnimationDataKeyRotationFromEuler( bonesIK[i], i );
                    }
                    for (var i = 12; i < 22; i++){
                        setAnimationDataKeyRotationFromEuler( bonesIK[i], i );
                    }
                    for (var i = 34; i < 37; i++){
                        setAnimationDataKeyRotationFromEuler( bonesIK[i], i );
                    }
                    
                }
                
            //  Right upperbody limb.
                else if (currentBoneIndex == 2){
                    setAnimationDataKeyRotationFromEuler( bonesIK[2], 2 );
                    setAnimationDataKeyRotationFromEuler( bonesIK[3], 3 );
                }
                else if (currentBoneIndex == 3){
                    for (var i = 3; i < 12; i++){
                        setAnimationDataKeyRotationFromEuler( bonesIK[i], i );
                    }
                }
                else if (currentBoneIndex == 4){
                    for (var i = 4; i < 6; i++){
                        setAnimationDataKeyRotationFromEuler( bonesIK[i], i );
                    }
                }
                else if (currentBoneIndex == 5){
                    for (var i = 5; i < 12; i++){
                        setAnimationDataKeyRotationFromEuler( bonesIK[i], i );
                    }
                }
                else if (currentBoneIndex == 6){
                    setAnimationDataKeyRotationFromEuler( bonesIK[6], 6 );
                    setAnimationDataKeyRotationFromEuler( bonesIK[7], 7 );
                    setAnimationDataKeyRotationFromEuler( bonesIK[8], 8 );
                }
                else if (currentBoneIndex == 7){
                    setAnimationDataKeyRotationFromEuler( bonesIK[7], 7 );
                }
                else if (currentBoneIndex == 8){
                    setAnimationDataKeyRotationFromEuler( bonesIK[8], 8 );
                }
                else if (currentBoneIndex == 9){
                    setAnimationDataKeyRotationFromEuler( bonesIK[10], 10 );
                    setAnimationDataKeyRotationFromEuler( bonesIK[11], 11 );
                }
                else if (currentBoneIndex == 10){
                    setAnimationDataKeyRotationFromEuler( bonesIK[10], 10 );
                }
                else if (currentBoneIndex == 11){
                    setAnimationDataKeyRotationFromEuler( bonesIK[11], 11 );
                }
                
            //  Left upperbody limb.
                else if (currentBoneIndex == 12){
                    setAnimationDataKeyRotationFromEuler( bonesIK[12], 12 );
                    setAnimationDataKeyRotationFromEuler( bonesIK[13], 13 );
                }
                else if (currentBoneIndex == 13){
                    for (var i = 13; i < 22; i++){
                        setAnimationDataKeyRotationFromEuler( bonesIK[i], i );
                    }
                }
                else if (currentBoneIndex == 14){
                    for (var i = 14; i < 16; i++){
                        setAnimationDataKeyRotationFromEuler( bonesIK[i], i );
                    }
                }
                else if (currentBoneIndex == 15){
                    for (var i = 15; i < 22; i++){
                        setAnimationDataKeyRotationFromEuler( bonesIK[i], i );
                    }
                }
                else if (currentBoneIndex == 16){
                    setAnimationDataKeyRotationFromEuler( bonesIK[16], 16 );
                    setAnimationDataKeyRotationFromEuler( bonesIK[17], 17 );
                    setAnimationDataKeyRotationFromEuler( bonesIK[18], 18 );
                }
                else if (currentBoneIndex == 17){
                    setAnimationDataKeyRotationFromEuler( bonesIK[17], 17 );
                }
                else if (currentBoneIndex == 18){
                    setAnimationDataKeyRotationFromEuler( bonesIK[18], 18 );
                }
                else if (currentBoneIndex == 19){
                    setAnimationDataKeyRotationFromEuler( bonesIK[20], 20 );
                    setAnimationDataKeyRotationFromEuler( bonesIK[21], 21 );
                }
                else if (currentBoneIndex == 20){
                    setAnimationDataKeyRotationFromEuler( bonesIK[20], 20 );
                }
                else if (currentBoneIndex == 21){
                    setAnimationDataKeyRotationFromEuler( bonesIK[21], 21 );
                }
                
            //  Chest.
                else if (currentBoneIndex == 22){
                    for (var i = 1; i < 37; i++){
                        setAnimationDataKeyRotationFromEuler( bonesIK[i], i );
                    }
                }
                
            //  Hip - Lowerbody body.
                else if (currentBoneIndex == 23){
                    setAnimationDataKeyRotationFromEuler( bonesIK[23], 23 );
                    for (var i = 25; i < 29; i++){
                        setAnimationDataKeyRotationFromEuler( bonesIK[i], i );
                    }
                    for (var i = 30; i < 34; i++){
                        setAnimationDataKeyRotationFromEuler( bonesIK[i], i );
                    }
                }
                
            //  Left lowerbody limb.
                else if (currentBoneIndex == 24){
                        setAnimationDataKeyRotationFromEuler( bonesIK[25], 25 );
                }
                else if (currentBoneIndex == 25){
                    for (var i = 25; i < 29; i++){
                        setAnimationDataKeyRotationFromEuler( bonesIK[i], i );
                    }
                }
                else if (currentBoneIndex == 26){
                    for (var i = 26; i < 29; i++){
                        setAnimationDataKeyRotationFromEuler( bonesIK[i], i );
                    }
                }
                else if (currentBoneIndex == 27){
                    for (var i = 27; i < 29; i++){
                        setAnimationDataKeyRotationFromEuler( bonesIK[i], i );
                    }
                }
                else if (currentBoneIndex == 28){
                    setAnimationDataKeyRotationFromEuler( bonesIK[28], 28 );
                }
                
            //  Right lowerbody limb.
                else if (currentBoneIndex == 29){
                        setAnimationDataKeyRotationFromEuler( bonesIK[30], 30 );
                }
                else if (currentBoneIndex == 30){
                    for (var i = 30; i < 34; i++){
                        setAnimationDataKeyRotationFromEuler( bonesIK[i], i );
                    }
                }
                else if (currentBoneIndex == 31){
                    for (var i = 31; i < 34; i++){
                        setAnimationDataKeyRotationFromEuler( bonesIK[i], i );
                    }
                }
                else if (currentBoneIndex == 32){
                    for (var i = 32; i < 34; i++){
                        setAnimationDataKeyRotationFromEuler( bonesIK[i], i );
                    }
                }
                else if (currentBoneIndex == 33){
                    setAnimationDataKeyRotationFromEuler( bonesIK[33], 33 );
                }
                
            //  Neck, Head, Jaw.
                else if (currentBoneIndex == 34){
                    for (var i = 34; i < 37; i++){
                        setAnimationDataKeyRotationFromEuler( bonesIK[i], i );
                    }
                }
                else if (currentBoneIndex == 35){
                    for (var i = 35; i < 37; i++){
                        setAnimationDataKeyRotationFromEuler( bonesIK[i], i );
                    }
                }
                else if (currentBoneIndex == 36){
                        setAnimationDataKeyRotationFromEuler( bonesIK[36], 36 );
                }
                
            //  Libs.
                else {
                    for (var i =  2; i <  6; i++){ setAnimationDataKeyRotationFromEuler( bonesIK[i], i ); }
                    for (var i = 12; i < 16; i++){ setAnimationDataKeyRotationFromEuler( bonesIK[i], i ); }
                    for (var i = 25; i < 29; i++){ setAnimationDataKeyRotationFromEuler( bonesIK[i], i ); }
                    for (var i = 30; i < 34; i++){ setAnimationDataKeyRotationFromEuler( bonesIK[i], i ); }
                    for (var i = 34; i < 37; i++){ setAnimationDataKeyRotationFromEuler( bonesIK[i], i ); }
                }

            }
            
            else if (!animationDataKeyExist){
                debugMode && console.log("Current animation data key does not exists.", "You can not generate random pose key.");
                alert("Current animation data key does not exists. You can not generate random pose key. Add a new pose key and try again.");
            }
            
        //  bcaFrameKeyIndexesArray( animtimerSlider.value );
            newCurrentBoneSelected();
        }
        


    //////////////////////// end of random IK Poser /////////////////////////
        
        
        
    /////////////////////////// start of animate() //////////////////////////
        
        
        
        function animateAnimatorScene(){
            requestAnimationFrame( animateAnimatorScene );
            renderAnimatorScene();
            frameCount++ ;
            updateAnimatorScene();
            propertiesCapturer();
        }
        

        
        function renderAnimatorScene(){
            renderer.render( scene, camera );
        }
        
        
        
    ////////////////////////// end of animate() ////////////////////////////
        
        
        
    ////////////////////////// event listeners /////////////////////////////


        function onWindowResize() {
            if (animatorContainer == document.getElementById("animator-render-container")){
                
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize( window.innerWidth - 2, window.innerHeight - 2 );
            }
            
            else if (animatorContainer == document.getElementById("pose3d-preview")){
            
                camera.aspect = document.getElementById("pose3d-preview").offsetWidth / document.getElementById("pose3d-preview").offsetHeight;
                camera.updateProjectionMatrix();
                renderer.setSize( document.getElementById("pose3d-preview").offsetWidth - 2, document.getElementById("pose3d-preview").offsetHeight - 2 );
            
            } else {
                
                camera.aspect = 1;
                camera.updateProjectionMatrix();
                renderer.setSize( 256, 256 );
            }
            
        //  NOT NEED FOR EDITOR CONTROLS.
        //  controls.handleResize(); 
            
        //  Resize timeliner.
            initTimeLiner();
    	}
        
        
        
        function onDocumentMouseMove( event ) {
            mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
           	mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
           	
           	// add code here //
        }

        function onDocumentMouseDown( event ) {
            mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
           	mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
           	
            // add code here //
            
            bcaFrameKeyIndexesArray( animtimerSlider.value );
            newCurrentBoneSelected();
            
            if(playManual.checked){
                timescaleSlider.value = currentSpeed;
                timescaleOutput.value = currentSpeed;
            }
        }
    
    
    
        function onDocumentMouseUp( event ) {
            mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
           	mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
           	
            // add code here //
            
            if(playManual.checked){
                timescaleSlider.value = 0;
                timescaleOutput.value = currentSpeed;
            }
        }



    //////////////////////// end of event listeners ////////////////////////
        
        
    ////////////////////////// start of update() ///////////////////////////
        
        
        
        function updateAnimatorScene() {
            
            var delta = clock.getDelta();
            var	time = clock.getElapsedTime();
            
        //  EDITOR CONTROLS NOT NEED CONTROLS UPDATE.
        
            keyboard.update( delta );
        
        //
        
            if (currentSliderStatus){
            //  Animator Timer slider.
                if (currentSlider == animtimerSlider) {
                    currentOutput.value = currentSlider.value;
                    var t = Number(animtimerSlider.value);
                    
                    if (animation) {
                        timescaleSlider.value = 0;
                        timescaleOutput.value = currentSpeed;
                        playButton.innerHTML = "Play";
                        animation.play(t);
                    }
                    else if (!animation) {
                    //  Find the nearest lower frame-time in animationData.
                        var keysArray = animationData.hierarchy[0].keys;
                        if (keysArray.length > 0){
                            for (var i in keysArray){
                                if ( keysArray[i].time <= t) var keyIdx = Number(i);
                            }
                        //  debugMode && console.log(keyIdx, "i:", i);
                        //  Adjust bones dimensions to nearest time-frame.
                            for (var j in animationData.hierarchy){
                                var avatarBone = avatar.skeleton.bones[j];
                                var animateKey = animationData.hierarchy[j].keys[keyIdx];
                                avatarBone.position.fromArray(animateKey.pos);
                                avatarBone.quaternion.fromArray(animateKey.rot);
                                avatarBone.scale.fromArray(animateKey.scl);
                            }
                        }
                    }
                    reverseSubmitPositionValue();
                    reverseSubmitStaticRotationValue();
                    reverseSubmitScaleValue();
                }
                
            //  Animation Adjust sliders.
                if (currentSlider == posSliderX || currentSlider == posSliderY || currentSlider == posSliderZ ||
                    currentSlider == rotSliderX || currentSlider == rotSliderY || currentSlider == rotSliderZ ||
                    currentSlider == sclSliderX || currentSlider == sclSliderY || currentSlider == sclSliderZ ){
                    
                        submitNewPositionValue();
                        submitStaticRotationValue();
                        submitNewScaleValue();
                }
                
            //  Animation Adjust Uniform Scale slider.
                if (currentSlider == sclUniformSlider) {
                    submitUniformScaleValue();
                }
                
            //  Animation duration slider.
                if (currentSlider == durSlider) {
                    submitNewDurationValue();
                }
                
            //  Image rotation slider.
                if (currentSlider == imgRotSlider){
                    submitImageRotationValue();
                }
                
            //  Image position slider.
                if (currentSlider == imgPosSlider){
                    //  add function here  //
                }
                
            } else {
                reverseSubmitPositionValue();
                reverseSubmitStaticRotationValue();
                reverseSubmitScaleValue();
            }
        //
        
            if (animation) {
            
            //  Watch currentBoneIndex, currentBone and currentDataBone.
                // currentBoneIndex = bonesDroplist.selectedIndex;
                // currentBone = animation.hierarchy[currentBoneIndex];
                // currentDataBone = animation.data.hierarchy[currentBoneIndex]
                
            //  Watch Animation Timer slider.
                // currentFrameTime = Number(animtimerSlider.value);
                
            //  Get the Before, Current, After (bca) animationData Hierarchy Keys Indexes array.
                // bcaAnimationDataIndexKeys = bcaFrameKeyIndexesArray(animtimerSlider.value);
                // if (bcaAnimationDataIndexKeys[1]) debugMode && console.log(bcaAnimationDataIndexKeys);
            //
            
            //  Pause.
                if ( Number(timescaleSlider.value) == 0 ) {
                    playButton.innerHTML = "Play";
                    groundHelper.visible = true;
                    axisCustomHelper.visible = true;
                }
                
            //  Play.
                if ( Number(timescaleSlider.value)  > 0 ) {
                    playButton.innerHTML = "Pause";
                    groundHelper.visible = false;
                    axisCustomHelper.visible = false;
                }
                
            //  Play only at mouse down.
                if ( !loopCheckbox.checked ){
                    if (animation.currentTime > animation.data.length){
                        timescaleSlider.value = 0;
                        timescaleOutput.value = currentSpeed;
                        animtimerSlider.value = 0;
                        animtimerOutput.value = 0;
                        animation.currentTime = 0;
                        playButton.innerHTML = "Play";
                        animation.play(0);
                    }
                }

                if (animation.isPlaying){
                    animation.loop = loopCheckbox.checked;
                    animation.fps = Number(fpsSlider.value);
                    animation.timeScale = Number(timescaleSlider.value);
                    animtimerSlider.value = animation.currentTime;
                    animtimerOutput.value = animtimerSlider.value;
                }

            }
            
        //
            
            if (timescaleSlider.value > 0) currentSpeed = Number(timescaleSlider.value);
            
        //
            
            bcaFrameKeyIndexesArray( animtimerSlider.value );
            
            if (animationDataKeyExist) animtimerOutput.style.color = "#f0f";
            else animtimerOutput.style.color = "#fff";
            
            if (armatureHelper) armatureHelper.update();
            
            THREE.AnimationHandler.update( delta );
        }
        
        
        
    ////////////////////////// end of update() //////////////////////////
        
        
        
        //  SCENE COMMON FUNCTIONS.
    
        function newCustomAxisHelper(theScene){
            var group = new THREE.Group();
            theScene.add(group);
            
        //  Lines.
            var geometryAxisXpos = new THREE.Geometry();
            var geometryAxisXneg = new THREE.Geometry();
            var geometryAxisYpos = new THREE.Geometry();
            var geometryAxisYneg = new THREE.Geometry();
            var geometryAxisZpos = new THREE.Geometry();
            var geometryAxisZneg = new THREE.Geometry();
    
            var materialAxisXpos = new THREE.LineBasicMaterial( {color: 0xff0000} );
            var materialAxisXneg = new THREE.LineBasicMaterial( {color: 0x880000} );
            var materialAxisYpos = new THREE.LineBasicMaterial( {color: 0x00ff00} );
            var materialAxisYneg = new THREE.LineBasicMaterial( {color: 0x008800} );
            var materialAxisZpos = new THREE.LineBasicMaterial( {color: 0x0000ff} );
            var materialAxisZneg = new THREE.LineBasicMaterial( {color: 0x000088} );
    
            geometryAxisXpos.vertices.push( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 1200, 0, 0 ) );
            geometryAxisXneg.vertices.push( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3(-1200, 0, 0 ) );
            geometryAxisYpos.vertices.push( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 1200, 0 ) );
            geometryAxisYneg.vertices.push( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0,-1200, 0 ) );
            geometryAxisZpos.vertices.push( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, 1200 ) );
            geometryAxisZneg.vertices.push( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0,-1200 ) );
    
            var lineAxisXpos = new THREE.Line( geometryAxisXpos, materialAxisXpos );
            var lineAxisXneg = new THREE.Line( geometryAxisXneg, materialAxisXneg );
            var lineAxisYpos = new THREE.Line( geometryAxisYpos, materialAxisYpos );
            var lineAxisYneg = new THREE.Line( geometryAxisYneg, materialAxisYneg );
            var lineAxisZpos = new THREE.Line( geometryAxisZpos, materialAxisZpos );
            var lineAxisZneg = new THREE.Line( geometryAxisZneg, materialAxisZneg );
    
            group.add( lineAxisXpos );
            group.add( lineAxisXneg );
            group.add( lineAxisYpos );
            group.add( lineAxisYneg );
            group.add( lineAxisZpos );
            group.add( lineAxisZneg );
            return group;
        }
        
        
        
        function newDirectionalLight(hexcolor, x, y, z, intensity){
            var light = new THREE.DirectionalLight( hexcolor );
            light.position.set( x, y, z );
            light.intensity = intensity;
            return light;
            
        }
        
        
        
        function newGroundHelper(){
            var grid = new THREE.GridHelper( 100, 1, 0x444444, 0x444444 );
            grid.name = "GRID"
            grid.position.y = 0;
            scene.add( grid );
            return grid;
        }
        
        
    //  EVENT LISTENERS.
        
        var animatorContainer = $("#animator-container")[0];
        var sliderTimer = $("#slider-timer")[0];
        var animationPlayButton = $("#animation-play")[0];
        var animationAddButton = $("#animation-add")[0];
        var deleteFramekeyButton = $("#delete-framekey")[0];
        var leftSideContent = $("#left-side-content")[0];
        var rightSideContent = $("#right-side-content")[0];
        var cameraPropertiesPanel = $("#camera-measure-panel")[0];
        var camPropCloseButton = $("#close-button")[0];
        
        animatorContainer.onmouseover = function() { controls.enabled = false; };
        animatorContainer.onmouseout = function() { controls.enabled = true; };
        sliderTimer.onmousedown = function() { staticSliderPressed("timer", true); };
        sliderTimer.onmouseup = function() { staticSliderPressed("timer", false); };
        animationPlayButton.onclick = function() { playAnimation(avatar); };
        animationAddButton.onclick = function() { insertNewAnimateDataTimeFrameKey(); };
        deleteFramekeyButton.onclick = function() { deleteCurrentAnimationDataKey(); };
        leftSideContent.onmouseover = function(){ controls.enabled = false; };
        leftSideContent.onmouseout = function(){ controls.enabled = true; };
        rightSideContent.onmouseover = function(){ controls.enabled = false; };
        rightSideContent.onmouseout = function(){ controls.enabled = true; };
        camPropCloseButton.onclick = function (){ cameraPropertiesPanel.style.display="none"; };
        
        function propertiesCapturer(){
            $("#framer")[0].innerHTML = frameCount;
            $("#cam-pos-x")[0].innerHTML = camera.position.x.toFixed(3);
            $("#cam-pos-y")[0].innerHTML = camera.position.y.toFixed(3);
            $("#cam-pos-z")[0].innerHTML = camera.position.z.toFixed(3);
            $("#cam-rot-x")[0].innerHTML = camera.rotation._x.toFixed(3);
            $("#cam-rot-y")[0].innerHTML = camera.rotation._y.toFixed(3);
            $("#cam-rot-z")[0].innerHTML = camera.rotation._z.toFixed(3);
            $("#cam-quat-w")[0].innerHTML = camera.quaternion._w.toFixed(3);
            $("#cam-quat-x")[0].innerHTML = camera.quaternion._x.toFixed(3);
            $("#cam-quat-y")[0].innerHTML = camera.quaternion._y.toFixed(3);
            $("#cam-quat-z")[0].innerHTML = camera.quaternion._z.toFixed(3);
            $("#cam-far")[0].innerHTML = camera.far;
            $("#cam-fov")[0].innerHTML = camera.fov;
            $("#mouse-x")[0].innerHTML = mouse.x.toFixed(3);
            $("#mouse-y")[0].innerHTML = mouse.y.toFixed(3);
        }

/*
    //  Text.
        var materialFace = new THREE.MeshBasicMaterial( { color: 0xffffff } );
    	var materialSide = new THREE.MeshBasicMaterial( { color: 0x888888 } );
    	var materialArray = [ materialFace, materialSide ];
        var textMaterial = new THREE.MeshFaceMaterial(materialArray);

        h0Style = {size: 40, height: 2, curveSegments: 10, font: "helvetiker", weight: "normal", style: "normal", bevelThickness: 1, bevelSize: 2, bevelEnabled: false, material: 0, extrudeMaterial: 1}
    	h1Style = { size: 20, height: 1, curveSegments: 10, font: "helvetiker", weight: "normal", style: "normal", bevelThickness: 1, bevelSize: 2, bevelEnabled: false, material: 0, extrudeMaterial: 1 }
    	h2Style = { size: 10, height: 1, curveSegments: 10, font: "helvetiker", weight: "normal", style: "normal", bevelThickness: 1, bevelSize: 2, bevelEnabled: false, material: 0, extrudeMaterial: 1 }
    	h3Style = { size: 5, height: 0.5, curveSegments: 10, font: "helvetiker", weight: "normal", style: "normal", bevelThickness: 1, bevelSize: 2, bevelEnabled: false, material: 0, extrudeMaterial: 1 }

    // "+x"
        var thetext = "+x";
    	var textGeometry = new THREE.TextGeometry( thetext, h1Style );
    	var textMesh = new THREE.Mesh(textGeometry, textMaterial );
    	textGeometry.computeBoundingBox();
    	var textWidth = textGeometry.boundingBox.max.x - textGeometry.boundingBox.min.x;
    	textMesh.scale.set( 2, 2, 5); 
    	textMesh.geometry.center();
    	textMesh.position.set( 900, 20, 0 );
    	textMesh.rotation.x = 0;
    	textMesh.rotation.y = -Math.PI * 0.5;
    	textMesh.rotation.z = 0;
    	group.add(textMesh); 

    // "-x"
        var thetext = "-x";
    	var textGeometry = new THREE.TextGeometry( thetext, h1Style );
    	var textMesh = new THREE.Mesh(textGeometry, textMaterial );
    	textGeometry.computeBoundingBox();
    	var textWidth = textGeometry.boundingBox.max.x - textGeometry.boundingBox.min.x;
    	textMesh.scale.set( 2, 2, 5); 
    	textMesh.geometry.center();
    	textMesh.position.set( -900, 20, 0 );
    	textMesh.rotation.x = 0;
    	textMesh.rotation.y = Math.PI * 0.5;
    	textMesh.rotation.z = 0;
    	group.add(textMesh); 

    // "+z"
        var thetext = "+z";
    	var textGeometry = new THREE.TextGeometry( thetext, h1Style );
    	var textMesh = new THREE.Mesh(textGeometry, textMaterial );
    	textGeometry.computeBoundingBox();
    	var textWidth = textGeometry.boundingBox.max.x - textGeometry.boundingBox.min.x;
    	textMesh.scale.set( 2, 2, 5); 
    	textMesh.geometry.center();
    	textMesh.position.set( 0, 20, 900 );
    	textMesh.rotation.x = 0;
    	textMesh.rotation.y = -Math.PI;
    	textMesh.rotation.z = 0;
    	group.add(textMesh); 

    // "-z"
        var thetext = "-z";
    	var textGeometry = new THREE.TextGeometry( thetext, h1Style );
    	var textMesh = new THREE.Mesh(textGeometry, textMaterial );
    	textGeometry.computeBoundingBox();
    	var textWidth = textGeometry.boundingBox.max.x - textGeometry.boundingBox.min.x;
    	textMesh.scale.set( 2, 2, 5); 
    	textMesh.geometry.center();
    	textMesh.position.set( 0, 20, -900 );
    	textMesh.rotation.x = 0;
    	textMesh.rotation.y = 0;
    	textMesh.rotation.z = 0;
    	group.add(textMesh); 

    // "+y"
        var thetext = "+y";
    	var textGeometry = new THREE.TextGeometry( thetext, h1Style );
    	var textMesh = new THREE.Mesh(textGeometry, textMaterial );
    	textGeometry.computeBoundingBox();
    	var textWidth = textGeometry.boundingBox.max.x - textGeometry.boundingBox.min.x;
    	textMesh.scale.set( 2, 2, 5); 
    	textMesh.geometry.center();
    	textMesh.position.set( 0, 900, 0 );
    	textMesh.rotation.x = Math.PI * 0.5;
    	textMesh.rotation.y = 0;
    	textMesh.rotation.z = 0;
    	group.add(textMesh); 

    // "-y"
        var thetext = "-y";
    	var textGeometry = new THREE.TextGeometry( thetext, h1Style );
    	var textMesh = new THREE.Mesh(textGeometry, textMaterial );
    	textGeometry.computeBoundingBox();
    	var textWidth = textGeometry.boundingBox.max.x - textGeometry.boundingBox.min.x;
    	textMesh.scale.set( 2, 2, 5); 
    	textMesh.geometry.center();
    	textMesh.position.set( 0, -900, 0 );
    	textMesh.rotation.x = -Math.PI * 0.5;
    	textMesh.rotation.y = 0;
    	textMesh.rotation.z = 0;
    	group.add(textMesh); 
*/
    </script>
     

     
        
</body>

</html>
